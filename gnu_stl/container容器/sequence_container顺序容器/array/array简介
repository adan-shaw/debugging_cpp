1.c++什么时候开始有array 容器?
答:
	C++11





2.为什么c++11会重写array 容器?
答:
	实际上, c++11的array 容器, 功能上根本没有任何突破, 实际上还是跟c 语言'array传统数组'一样的, 只是有唯一的一点不同:
		通过封装函数at(), front(), back(), data() 访问array 容器的时候,
		如果出现内存访问越界, 崩溃的时候会提供更详细的报错信息, 仅此而已;

	实际上, 一旦内存访问越界, c++ 该崩溃的时候, 还是会崩溃, 
	并不是说c++11 重写了array 容器, 就可以解决这种内存访问越界导致崩溃的问题;
	c++11新标准推出array 容器, 是为了彻底和c 语言做交割, 彻底告别过去;
	(但实际上有点新瓶装旧酒, 实际没啥实用意义)

	如果对语法依赖性强的程序员来说, c++11 就是福音, 
	因为新版c++11 可以让二进制编码语言c++ 彻底跟'机器/系统'做交割, 
	让一切跟'机器/系统'打交道的工作, 交给c++编译器就可以了;
	c++ 也可以像脚本一样, 轻松通过语法糖进行大规模面向对象编程, 弱化面向过程的存在感;
	这也可以看成是: 
		c++ 面向人工智能的重要一步改造;
		人工智能时代, 对c++ 提出了更大规模面向对象编程的需求, 为了适应时代, c++ 必须改革, 否则后面会被go 取代;
		目前c++ vs go, 有点像java vs python, 喜欢传统面向对象编程的程序员, 会选择c++/java, 喜欢脚本式编码的程序员, 会选择go/python;
		效率上, go 的确性能和效率比不上c++,
		但敏捷开发上, go 是二进制封装编码的敏捷开发代表;

	anyway, c++ stl库, 是c++ 最大的价值所在, 适应时代, 好好利用起来;





3.补漏:array 容器的'聚合初始化'
	由于array 容器的类型, 使用了'泛型类型模板T', 
	因此, 当array 容器的元素类型为:
		std::string
		std::queue
		...
		等等
	这样就会出现容器内嵌进数组的问题, 这时候就会出现一个非常严重的问题:
		c 语言要实现这种内嵌结构, 必然是使用void*指针来完成这种内嵌结构的实现,
		使用的时候, 将void* 指针取出来, 然后再强转为内嵌对象类型指针;

	这种繁琐的操作, c++ 直接帮你省掉了,
	c++ 允许'泛型类型模板T', 允许你直接进行内嵌, 如:
		std::array<std::string, 2> b1 = { std::string("i'm b1[0]"), "i'm b1[1]" };
	这样一来, 将std::string 替换为void 指针的工作, 就全部交给c++ 编译器去完成, 你可以专心focus 在你的业务设计上面, 十分方便;

	这样才是c++11 改革的真正意义所在, 简化设计过程, 让机器语言更简单地完成面向对象变成, 面向人工智能, 做更敏捷的开发;

	这样一来, 以后c++ 编码, 数组也一般使用array 容器比较好;
	当然如果你不打算进行内嵌的话, 用c 语言的'array传统数组'也可以;
	注意:
		array 容器的'聚合初始化', 元素类型必须一致, 不能内嵌两种不同的类型!! 否则报错;
		例如:
			std::array<std::string, 2> b1 = { std::string("i'm b1[0]"), "i'm b1[1]" };
		由于std::array<std::string, 2>, 已经将b1 初始化为std::string类型的std::array,
		因此, b1[0] = std::string("i'm b1[0]"), b1[0]元素是一个std::string 容器;

		b1[1]元素是"i'm b1[1]", 看上去没有声明b1[1]的元素类型为std::string, 
		但实际上编译器会自动用std::string, 将"i'm b1[1]"装入std::string;





4.补漏:迭代器访问array 容器, 更安全, 内存访问越界的问题, 更不容易出现;
