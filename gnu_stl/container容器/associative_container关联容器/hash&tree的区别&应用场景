1.hash 结构的容器简介:
	理想情况下, 可以实现O(1)时间内找到数据(常用来存放已知且确定的数据, 热cache缓存数据);

	哈希表主要可以在O(1)时间内对查找对象定位, 
	但事实上, 如果'输入集合'不确定的情况下, 可能出现大量的冲突, 
	虽然'好的哈希函数'可以缓解随机输入造成的性能损耗和冲突问题, 但随着随机输入, 大量冲突还是不可避免, 可能出现最差情况;

	所以, 哈希表如果用在'输入集合'确定(即以后只会做查询操作)的情况下, 
	选择合适的函数函数和解决冲突的方法(perfect hash最理想的情况), 可以在O(1)时间内完成查找;





2.tree 结构的容器简介:
	二叉树支持动态的插入和查找, 保证操作在O(height)时间, 这就是完成了哈希表不便完成的工作, 即不确定的随机输入, 随机查找数据, 复杂的离线cache 缓存数据;
	但二叉树有可能出现worst-case, 如果输入序列已经排序, 则时间复杂度为O(N);

	平衡二叉树/红黑树就是为了将查找的时间复杂度保证在O(logN)范围内;





3.hash结构的容器, 优点缺点分析:
	hash索引本身由于其特殊性也带来了很多限制和弊端, 主要可以分为以下几个方面:
		(1)hash索引仅仅能满足"=","IN"和"<=>"查询, 不能使用范围查询;
		(2)hash索引无法被用来避免数据的排序操作;
		(3)hash索引不能利用部分索引键查询;
		(4)hash索引在任何时候都不能避免表扫描;
		(5)hash索引遇到大量hash值相等的情况后性能并不一定就会比B-Tree索引高;

	hash索引的不足:
		* hash索引不支持范围查询;
			这是为什么呢? 是因为hash操作并不能保证顺序性, 所以值相近的两个数据, hash值相差很远, 被分到不同的桶中;

		* hash索引无法做 like 'xxx%' 这样的部分模糊查询;
			这是为什么呢? 因为需要对 完整 key 做 hash计算, 定位bucket, 而模糊查询的时候, key不完整, 无法用key定位到对应的桶找到对应的hash值;

		* hsah索引无法进行排序;
			这是为什么呢? 通过key计算出来的hash值, hash值的大小关系并不一定和hash运算前的键值完全一样;

		* hash索引不支持多联合索引;
			这是为什么呢? 多联合索引是根据最左匹配原则进行, 而hash索引会将多列合并算出hash值, 从而导致联合索引无法被利用;

		* hash索引存在hash碰撞, 当重复的键过多的时候就会效率大大降低, 不稳定;

		* hash索引不是我们自己控制的, 而是由数据库自身创建并使用, 我们不能够对他进行干预;





4.B+树索引相对于hash的优点:
	* B+tree 索引的叶子节点形成有序链表, 便于范围查询;
	* B+tree 索引的叶子节点形成有序链表, 可用于排序;
	* B+tree 索引具有最左前缀匹配, 可以进行部分模糊查询;比如(xxx%)但是这种就不会走索引(%xxx);
	* B+tree 相对稳定, 而hash索引会产生hash碰撞, 不稳定;





5.hash vs tree 结构的容器对比:
	tree是有序的, hash是无序的;
	tree可以遍历的, hash是不能遍历的;

	hash不适合使用'聚合函数操作'(因为不能遍历), 只能做简单新增, 删除, 修改, 查找, hash消耗较多的内存;
	tree适合使用'聚合函数操作', 也有较高的新增, 删除, 修改, 查找能力, 综合性能最好, 内存消耗也小, 但cpu 消耗较大;

	如果输入结合确定, 所需要的只是查询, 则可以考虑使用hash;
	如果'输入集合'不确定(模糊查询), 不确定容器中是否u存在相同的值, 则考虑使用tree, 保证达到最大效率;
	也就是:
		在'输入值集合'中, 如果确认'输入的值'一定会命中的情况下, hash性能好;
		如果输入值只是一次偶然查询, 则使用tree 性能更好;

	如果内存要求苛刻的项目, 就用tree;
	如果内存足够大, 牺牲内存换取更快的速度, 就用hash;

	应用场景分析:
		向容器存放一个数据(类/结构体/常规数据), 作为cache 缓存, 经常性查看, 偶尔性查看, 
		通常来说, 这种情况下, 使用hash性能更好;
		也就是热缓存, 存放在内存中的数据, 默认情况下, 使用hash会性能更好, 但需要满足组建hash的几个关键条件:

		如果是离线数据存放, 存放之后, 程序可能会经历多次重启, 关闭, 甚至是多个程序, 不同程序进行查询, 
		这种情况下, tree 是最好的选择, 这也是为什么db 常用的存储数据结构是tree;
		而lua 够胆用hash来做table 的原因;

		热缓存, 满足hash条件的, hash性能强;
		离线缓存, 统一都是tree, 唯一选择;


