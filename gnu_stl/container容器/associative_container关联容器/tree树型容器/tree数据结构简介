* 二叉树(BST)
	最基础的tree型数据结构;





* 平衡二叉树(AVL)
	由于二叉树可能会有极端的情况, 就是某个节点的深度无限大, 这样的二叉树和链表没啥区别, 
	于是为了限制二叉树极端的情况, 满足二叉树深度较小的情况, 介继而推出了平衡二叉树;

	优缺点:
		比二叉树比较有规则, 深度比二叉树小, 任何节点的左右子树高度相差不超过1;
		因此数据量大的时候, 查询和插入速度都大于二叉树;





* 红黑树(rbtree, 多叉平衡查找树, 二叉树的巅峰之作!!)
	rbtree 是一种多叉平衡查找树;
	rbtree 是基于平衡二叉树上实现的, 由于平衡二叉树是严格按照规定执行, 因此每次的插入, 删除, 都就会引发树的调整(维护成本略高);
	rbtree 可以看作是二叉搜索树和AVL树的一个折中, 维持平衡的同时, 也不需要花太多时间维护数据结构的性质.

	优缺点:
		数据量小的时候, 增删的效率仅小于链表, 优于AVL平衡二叉树;
		数据量大的时候, 也具备AVL平衡二叉树的特点, 尽量减少树的深度, 优于普通二叉树;
		是一个折中选择, 结合了'AVL平衡二叉树 & 普通二叉树'的优点;





* B-tree(又叫B树,N叉树)
	因为(平衡)二叉树的每个节点只存储一个键值和数据的, 二叉树的节点将会非常多, 高度也会及其高;
	这种多碎片, 多分次的结构, 在实际存储设备中, 是大忌, 内存中容易产生内存碎片, '磁盘/SSD闪存'中伤害更大;
	因此, (平衡)二叉树在'查找/增删'数据时, 也会进行很多次磁盘IO, 查找的效率极低;
	因此, 才诞生了B-tree;

	B-tree 实际上是两层brtree:
		外层树: 以数据块为'节点元素', 构建'数据块brtree', 每个节点提供范围关键字, 方便索引;
		内层子节点: 每个数据块节点, 实际还是一个brtree, 每个元素, 都是一个存储数据;

	可以看成是:
		外层树 = 索引树(等价于: n 个红黑树, 装到一个新的红黑树中)
		内层子节点 = 子索引树 + 存储数据(等价于: 一个子节点, 一棵红黑树)

	这样做十分方便存储设备对数据进行起块处理, 减少碎片率;
	(并不是说B-tree 在逻辑搜索上有多优秀, 逻辑理论上, B-tree 的搜索, 处理性能, 并不比rbtree 优秀;
	 但结合到实际存储设备的时候, 结合到计算机存储设备的特性, 减少碎片化的B-tree, 性能必然比rbtree 要优秀);





* B+tree(又叫B+树)
	B+tree是在B-tree的基础上进行了优化:
		* 将'外层树'独立存放到内存中, 提高索引性能, 同时可以提供更多的关键字, 以提高索引能力;
		* 将'内层子节点'独立存放到disk 中, 按块存储, 提高存储效率(节约空间, 减少碎片, 提高索引能力);

	可以把B+tree, 看成是B-tree 的物理设备优化版:
		逻辑上, B+tree 也没有比B-tree 先进, 
		只是在实际物理存储设备中, B+tree 更优;

	最终:
		B+tree 都需要在复杂数据体中, 指定一个key, 用作索引, 这个key 常驻内存中;
		B+tree 的所有二级'内层子节点', 作为数据块, 这个数据块存放在disk 中;

	(ps: 如果你以简单int 作为元素来存储, 何必造这么复杂的存储结构? 一棵rbtree 满足你的所有需求;
			 因此, 使用B+tree 基本上都是用来存储struct/class/table 的;
			 B+tree 一般情况下是用来存储struct的(即一维数据), 组建B+tree 之后, 就变成了二维table;
			 B+tree 如果用来存储二维table, 组建B+tree 之后, 就变成了三维数据空间了;
			 B+tree 的数据维度 = 元素的数据维度 + 1;
	)

	db 数据库引擎, mysql 默认存储引擎innodb 使用B+tree;





* B*tree(又叫B*树)
	B*树是B+树的变种, 与B+树同级, 都是对B-tree 的优化, 只是优化算法不一样而已;

	B*树不同于B+tree的地方:
		(1)首先是关键字个数限制问题, B+树初始化的关键字初始化个数是cei(m/2), b*树的初始化个数为(cei(2/3*m))

		(2)B+树节点满时就会分裂, 而B*树节点满时会检查兄弟节点是否满(因为每个节点都有指向兄弟的指针), 
				如果兄弟节点未满则向兄弟节点转移关键字, 如果兄弟节点已满, 则从当前节点和兄弟节点各拿出1/3的数据创建一个新的节点出来;

	在B+树的基础上因其初始化的容量变大, 使得节点空间使用率更高, 而又存有兄弟节点的指针, 可以向兄弟节点转移关键字的特性使得B*树额分解次数变得更少;





总结:
	内存中的tree, 应该是红黑树;(c++ tree 型容器)
	disk 中的tree, 应该是b+树;(mysql innodb 存储引擎)
