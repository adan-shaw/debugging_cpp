迭代器共有五(C++17前)/六(C++17起)种:
	LegacyInputIterator											旧式输入迭代器					只读/自增(非多趟)
	LegacyOutputIterator										旧式输出迭代器					只写/自增(非多趟)
	LegacyForwardIterator										旧式向前迭代器					读(引用写)/自增(多趟)
	LegacyBidirectionalIterator							旧式双向迭代器					读(引用写)/自增&自减(多趟)
	LegacyRandomAccessIterator							旧式随机访问迭代器			读(引用写)/自增&自减(多趟)/随机访问
	LegacyContiguousIterator(C++17起)				旧式连续迭代器					相接存储

	ps:
		一般迭代器的类型, 不需要你记住, 由编译器根据容器类型, 自动选择;
		使用时, 你只需要根据容器的类型, 定义与容器对应的迭代器即可;
		汇总这些迭代器的功能, 主要是要清楚, stl迭代器大致都有那些功能,
		当你使用容器配套的迭代器时, 根据容器的存储数据结构, 你大致心里面也知道, 这个容器所对应的迭代器类型了,
		此时, 你也应该明白, 这个容器配套的迭代器, 大致有什么样的功能;



下列的标准库迭代器, 是输出迭代器而非向前迭代器:
	std::ostream_iterator
	std::ostreambuf_iterator
	std::insert_iterator
	std::back_insert_iterator
	std::front_insert_iterator

下列标准库类型是, 旧式连续迭代器(LegacyContiguousIterator)
	array::iterator
	basic_string_view::iterator
	vector::iterator, 对于除bool以外的value_type
	begin(valarray)和end(valarray)的返回类型



声明for all:
	迭代器自增/自减, 返回移动后的迭代器, 即it&;
	那么, 返回移动后的值, 写法是: *(it++)
	那么, 返回迭代器的值后移动, 写法是: *it++

	ps: 非多趟迭代器慎用!!


#
# 迭代器详情
#
1.LegacyInputIterator旧式输入迭代器, 支持:
		- 逻辑判断
			(it == it2) -- 两个迭代器比较
			(*it == 18) -- 迭代器与'常量/变量'的值比较
		- 只读
			*it         -- 读迭代器指向的常规变量值
			it.body     -- 读迭代器指向的内嵌变量的子元素值( 等价于: (*it).body )
		- 自增(非多趟)
			++it        -- 先移动, 后返回迭代器; 非多趟自增: 移动一次后, 迭代器pos 永久向前移动, 不能复位到x.begin();
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;



2.LegacyOutputIterator旧式输出迭代器, 支持:
		- 只写
			*it=1       -- 写迭代器指向的常规变量值
		- 自增(非多趟)
			++it        -- 先移动, 后返回迭代器; 非多趟自增: 移动一次后, 迭代器pos 永久向前移动, 不能复位到x.begin();
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;



3.LegacyForwardIterator旧式向前迭代器, 支持:
		- 逻辑判断
			(it == it2) -- 两个迭代器比较
			(*it == 18) -- 迭代器与'常量/变量'的值比较
		- 读(引用写)
			*it         -- 读迭代器指向的常规变量值
			*it=1       -- 引用写迭代器指向的常规变量值
			it.body=1   -- 引用写迭代器指向的内嵌变量的子元素值( 等价于: (*it).body )
		- 自增(多趟)
			++it        -- 先移动, 后返回迭代器;
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;



4.LegacyBidirectionalIterator旧式双向迭代器, 支持:
		- 逻辑判断
			(it == it2) -- 两个迭代器比较
			(*it == 18) -- 迭代器与'常量/变量'的值比较
		- 读(引用写)
			*it         -- 读迭代器指向的常规变量值
			*it=1       -- 引用写迭代器指向的常规变量值
			it.body=1   -- 引用写迭代器指向的内嵌变量的子元素值( 等价于: (*it).body )
		- 自增/自减(多趟)
			++it        -- 先移动, 后返回迭代器;
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;
			(自减同理, 请自己把++换成--)



5.LegacyRandomAccessIterator旧式随机访问迭代器, 支持:
		- 逻辑判断
			(it == it2) -- 两个迭代器比较
			(*it == 18) -- 迭代器与'常量/变量'的值比较
		- 读(引用写)
			*it         -- 读迭代器指向的常规变量值
			*it=1       -- 引用写迭代器指向的常规变量值
			it.body=1   -- 引用写迭代器指向的内嵌变量的子元素值( 等价于: (*it).body )
		- 自增/自减(多趟)
			++it        -- 先移动, 后返回迭代器;
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;
			(自减同理, 请自己把++换成--)
		- 随机访问(连续内存, 连续存储空间)
			it += n     -- 迭代器向后移动n 个元素
			it -= n     -- 迭代器向前移动n 个元素
			it + n      -- 迭代器向后移动n 个元素
			it - n      -- 迭代器向前移动n 个元素
			it[n]       -- 等价于*(it + n), 返回移动n 个元素后, 指向的元素的值;



6.(C++17起)LegacyContiguousIterator旧式连续迭代器, 支持:
		- 逻辑判断
			(it == it2) -- 两个迭代器比较
			(*it == 18) -- 迭代器与'常量/变量'的值比较
		- 读(引用写)
			*it         -- 读迭代器指向的常规变量值
			*it=1       -- 引用写迭代器指向的常规变量值
			it.body=1   -- 引用写迭代器指向的内嵌变量的子元素值( 等价于: (*it).body )
		- 自增/自减(多趟)
			++it        -- 先移动, 后返回迭代器;
			*(++it)     -- 先移动, 后返回值;
			it++        -- 先返回迭代器, 后移动;
			*(it++)     -- 先返回值, 后移动;
			(自减同理, 请自己把++换成--)
		- 随机访问(连续内存, 连续存储空间)
			it += n     -- 迭代器向后移动n 个元素
			it -= n     -- 迭代器向前移动n 个元素
			it + n      -- 迭代器向后移动n 个元素
			it - n      -- 迭代器向前移动n 个元素
			it[n]       -- 等价于*(it + n), 返回移动n 个元素后, 指向的元素的值;





