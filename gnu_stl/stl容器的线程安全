< stl容器的线程安全 >
	一般来说, stl容器都是没有线程安全设计的, 多线程写访问, 需要自己加锁;
	自己解决脏写, 脏读的问题, 做好线程同步的操作, 保证多线程安全地访问stl容器;



	不要相信所谓的无锁队列, 无锁队列实际上使用的是'CAS锁', 逻辑死等, 在情况好的情况下, 的确也很好用, 安全高效实时, 不切换线程;
	但实际上, 还是加锁用得舒服;



	由于有迭代器失效的问题, 如果多线程访问同一个stl容器, 会有很多脏写, 脏读的问题;
	千万别不加锁, 否则数据的准确性很难保证:
		例如你以为, 多个线程读共享, 会没问题;
		只有一个线程写, 其他线程读, 这样一来, 只要队列容器, 保证一端读, 一端写, 就不会有问题?
		不是的, 如果你用迭代器访问的话!!

		写操作, 可能会导致其他线程的读迭代器失效, 导致他们崩溃;
		当然你用原始数组, 构造出来的队列, 这种做法相对安全很多, 但是标准stl 容器, 是不能这样做的;

	因此, 为了不必要的麻烦, 多线程访问同一个stl容器, 第一, 你应该避免这种情况的出现;
	第二, 如果没办法避免, 你应该加个读写锁/互斥锁, 这样比较安全;

	读写锁性能强一点!!
	读写锁也可以在保护数据安全的情况下, 最大限度提高性能:
		例如你用迭代器进行遍历读操作的时候, 突然来一个写操作, 那么写操作会被阻塞;
		如果继续是读操作, 则继续共享, 无阻塞读操作;
	这种读写锁, 适合多读, 少写的场合;





old 理论(已废弃, 不重要):
	一般说来, stl容器对于多线程的支持仅限于下列两点:
		1.多个读取者是安全的, 即多个线程可以同时读取一个容器中的内容;
			即此时多个线程调用'不涉及到写操作的接口'都可以find, begin, end等.

		2.对'不同容器'的'多个写入者'是安全的, 即多个线程对不同容器的同时写入合法;
			(这里证明了stl 容器并'没有用任何全局变量来实现', 全部都是局部容器, 
			 如果不同的容器对象同时写入都实现不到, 
			 那么就是这个stl 容器有全局变量/静态变量来实现的)


	但是对于'同一容器'当有线程写,有线程读时,如何保证正确?
	需要程序员自己来控制, 比如:
	线程A读容器某一项时, 线程B正在移除该项;
	这会导致一下无法预知的错误;
	通常的解决方式是用开销较小的临界区(CRITICAL_SECTION)来做同步;


	以下列方式同步, 基本上可以做到线程安全的容器(就是在有写操作的情况下仍能保证安全):
		1.每次调用容器的成员函数的期间需要锁定;
		2.每个容器容器返回迭代器的生存期需要锁定;
		3.每个容器在调用算法的执行期需要锁定;
