1.gun 公版的allocator 十分简陋, 没有二级重用; 
	(推荐使用'自己封装的my_alloc')





2.allocator 并不是一个通用意义上的内存重用管理器;
	一个allocator, 只能管理一个类定义;
	allocator 属于编程逻辑上的'内存重用管理器';

	无论这个类实化了多少个实体, 只要类型一致, 都可以使用allocator 空间管理器, 来提高逻辑上的重用效率;
	但实际上, ptmalloc, jemalloc 才是通用意义上的内存重用器!!

	allocator 方便程序员实现工厂模式, 效率非常不错;

	使用'自己封装的my_alloc' 只是提高某个类的重用率, 
	如果你将ptmalloc 切换为jemalloc, 那就更完美了.





3.在一个类的定义里面, 实现一个规模化类工厂, 实现自我生产;
	把类工厂的全局共有数据, 变成static 数据;
	把类实体的固有数据, 变成public, private, protected 普通数据;

	这样类工厂在自我生产的时候, 就能实现共享数据, 自我复制, 两者完美结合;

	需要把类工厂变成单例? 
	不需要, 也不可能!!
	类工厂只有static 的数据, 是共享的, 把这些数据放进单例实体中, 极度不适合;
	所以, 类工厂是类工厂, 单例是单例;





4.工厂模式, 必然会自己携带一个allocator, 
	而且这个allocator 必然是static 变量, 在工厂内共享;
