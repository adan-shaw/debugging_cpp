互联网fastCGI与点播的区别:
问:
	同样是一对一服务, 为什么不用fastCGI来实现'tcp 点播服务'?

答:
	不用fastCGI来实现'tcp 点播服务'的原因:
		1.实时传输的'服务质量(QoS)保障协议'性能太差, 不能支撑实时性, 更别说'会话级的服务质量(QoS)保障协议'了;
			其次, CGI/fastCGI 表示:
				把'被选中的exe/script file执行后的标准output结果', 以字符串的形式, 返还给客户端;
			从字符串到mp3/mp4媒体流的转变, 难以实现, 转换性能消耗也不小, 不划算(这个倒是小问题);

		2.CGI/fastCGI 实时性要求不高, 可以实现异步轮询;
			'tcp 点播服务', 如果实现异步轮询, 延时率会提高;
			(但鉴于服务器的io 吞吐量, 本来就是那么大, 这种延时是可以通过多线程/多进程技术摆平的, 
			 只是编码实现难度大而已, 真的推行, 也不是不可能)

		3.流量太贵, 现在基本是p2p, 集中消耗服务器流量的流媒体server, 已经是夕阳工业了,
			大部分'流媒体server营运商', 都会通过p2p 来实现'节约流量'的目的, 这用屁股想想都知道的猫腻, 是必然趋势;
			如果单纯用类似'CGI/fastCGI'的模式, 来实现一对一点播服务,
			这种方式, 不符合'流媒体server营运商'的实际利益, 负担巨大的流量费用, 不是一个好主意;

		...


	综上所述, 流媒体server基本不用类似于'CGI/fastCGI'的模式, 来实现'tcp 点播服务';





问:
	不用fastCGI来实现'tcp 点播服务', 那互联网点播服务, 是怎么实现的?

答:
	* 部分由'流媒体server营运商'提供一对一点播;

	* 部分由用户p2p提供一对一点播, '流媒体server营运商'根据'STUN协议'提供'NAT穿墙'服务(优先策略);
		所以, 有时候看点播视频, 网速差, 不一定就是'流媒体server营运商'的网速不行,
		而是与你p2p 匹配的用户, 对方发数据过来的时候, 他的网速不行or 他的'电脑/路由器'太卡, 导致发包性能太差;





问:
	部分互联网点播服务, 由'流媒体server营运商'提供, 那他们是怎么提供点播服务的?

答:
	如果迫于无奈, '流媒体server营运商'必须为你提供服务, 
	比如说你是会员, 或者网速太差, 附近没有优质p2p 的情况下, 
	'流媒体server营运商'会根据下面的步骤给你提供服务:
		1.先用http/https, 超文本服务器, 获取你要播放的资源url, 
			包含: 文件位置, 码流帧速(普清/高清/超清)等关键信息;

		2.fork()/docker, 启动一个流媒体server, nginx/rtsp-simple-server;

		3.通知你的web浏览器, 告诉你可以开始拉流
			(ps: 服务器的默认拉流端口是固定的, 类似80/443, 也可以告诉你一个新的拉流端口)

		4.web浏览器发送拉流ready, 流媒体server开始对'自己的推流端口'进行推流;
			fork()/docker, 启动一个ffmpeg, 对推流端口进行推流;

		5.自此, web浏览器也开始拉到了media流媒体数据了;

	点播服务的特殊技能:
		用户手动移动时间轴, 具体的实现过程:
			重置:
				web浏览器发送重置命令, 流媒体server停止&取消ffmpeg推流;
				流媒体server准备好之后, 重新通知web浏览器开始拉流,
				web浏览器发送拉流ready, 流媒体server开始对'自己的推流端口'重新开始推流;
				(重新开始ffmpeg 推流命令)

			暂停:
				与重置步骤的描述差不多, 只不过ffmpeg 是停止推流, 并未取消推流任务;
				等web浏览器再次发送'拉流ready'指令, 流媒体server再继续推流;

			跳跃:
				与重置步骤的描述差不多, 流媒体server停止&取消ffmpeg推流;
				(重新开始ffmpeg 推流命令的时候, 新增-ss 轨道起点的参数)





问:
	WebRTC支持UDP 模式吗?
答:
	支持的, 使用UDP 还能节省流量带宽;
	目前的主流WebRTC浏览器, 是基于SRTP实现的, SRTP支持TCP/UDP 模式;






