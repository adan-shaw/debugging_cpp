(.exe)4.链接	 <x.o> <x2.o> -lm -lpthread -o <x.exe>
	* 附加'ELF封装头'

	* 补全'静态/动态共享链接库'的二进制代码块.

	ps:
		使用'静态共享链接库'的好处是:
			共享链接库依赖的代码块, 之前嵌入到.exe程序中;
			不会说有共享链接库缺失, 版本不对, 各种差异;
			跨平台移动性好, 版本更新好, 兼容性好.
		缺点:
			生成的程序比较大, 装载.exe时, 消耗的起始内存较多.

		使用'静态共享链接库'的好处是:
			生成的程序比较小, 消耗的起始内存较少;
		缺点:
			运行程序时, 需要初始化, 要找齐所有依赖的'动态共享链接库', 并版本正确, 装载正确.
			有5%的CPU 运算性能损耗(但节约了内存)


	生成可执行文件后, 无论什么后缀都可以直接运行,
	linux不认后缀, 但认ELF封装.

	可以使用ldd 命令查看'链接后的二进制file'的信息:
		ldd ./<x.exe>

	如果'.so 共享链接库'找不到, 说明还没装载, 你可以:
		# 导入拼接变量, 在原来的/lib /usr/lib 的基础上, 加入自己的'.so 共享链接库'路径
		export LD_LIBRARY_PATH=<your .so library path>:$LD_LIBRARY_PATH
		或者:
			cd /usr/lib # cd /lib
			ln -s <your .so library path>
			# 更新一下系统默认装载的'.so 共享链接库'
			ldconfig





总结:
	当你查看第二步: 
		how2阅读:编译处理后的.s文件

	你会看到一些外部调用, 如:
		call	printf
		你却找不到任何关于'#include <stdio.h>所指向的.so共享链接库'的信息.
		为什么会这样??
		因为:
			链接'.so 共享链接库'的任务, 是第四步才实现的.
			所有'.so 共享链接库'的信息, 都会封装在ELF 头部.
			程序运行前, 都会向系统询问'.so 共享链接库'的信息first!!
			然后再启动程序.
			(ELF 并不会记录'.so 共享链接库'的具体装载位置, 
			 系统每次装载'.so 共享链接库'的位置都不一样, 肯定不是装载位置!!
			 只能通过运行程序前, 向系统询问一次, '.so 共享链接库'的位置信息)


	汇编码:
		call	printf
	printf 哪里来?? 
	实际上就要看第四步-链接了, ELF 封装时, 肯定会指明: 有多少个.so 依赖文件.

	无论静态链接库, 还是动态链接库, 都是: call	printf
	只有真正链接的时候, 才会决定是静态链接, 还是动态链接:
		静态链接, 从.a 库中抽取该函数的二进制代码块, 嵌入到.exe 程序中.
		动态链接, 将系统中.so 库的引用声明, 嵌入到ELF 文件头中.



