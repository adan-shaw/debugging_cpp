#
# 1.g++ 与gcc 的区别:
#
g++ 本质上, 只是对c++11 c++14 c++17 的语法翻译支持库;
g++ 本质上, 还是基于gcc 编译器的, 可以把g++ 看成是gcc 的复杂语法拓展库;

g++ 的运行时库是: libstdc++.so.6
gcc 的运行时库是: libc.so.6

总的来说, g++ 的实现, 离不开linux kernel 和gcc 底层的支撑.
g++ 只是gcc 的一个语法拓展库, 按照c语言的实现方式, 将C++ 语法翻译出来.


默认情况下, gcc 不能编译.cpp 文件, gcc 也不支持c++ 特性, 如类class{} 规则.
g++ 则兼容所有, 兼容gcc, 兼容所有支持的c++ 语法.
g++ 会自动调用gcc 解决问题.







#
# 2.编译链接原理
#
(.i)1.预编译 -E <x.cpp> -o <x.i>
	* 展开所有宏, 编译器进行宏字符串替换.

	* 展开#include <>, 所有引用到的API, 都会从#include <>抽出来, 
		声明函数指针和#include <>文件位置.

	* 去除所有注释

	* 这一步, 还不会进行语法进行检查, 除非是宏定义出错.
		变量/结构体/类声明, 函数声明, 再荒谬也不会报错.



(.s)2.编译 -S <x.i> -o <x.s>
	* 检查语法, 彻底检查'变量/结构体/类声明/函数声明'的用法, 是否正确.

	* 生成汇编代码, 如果通过语法检查, 就生成对应的汇编码.



(.o)3.汇编 -c <x.s> -o <x.o>
	* 将汇编码, 按照gcc 版本, 平台信息, 
		按照ELF标准, 直译出机械语言(此时已经是二进制文件了);
		但此时还没有'ELF封装头', 也没有嵌入'静态/动态共享链接库'

		可以使用file 命令查看'汇编后的二进制file'的信息:
			file ./<x.o>




(.exe)4.链接 <x.o> <x2.o> -lm -lpthread -o <x.exe>
	* 附加'ELF封装头'

	* 补全'静态/动态共享链接库'的二进制代码块.

	ps:
		使用'静态共享链接库'的好处是:
			共享链接库依赖的代码块, 之前嵌入到.exe程序中;
			不会说有共享链接库缺失, 版本不对, 各种差异;
			跨平台移动性好, 版本更新好, 兼容性好.
		缺点:
			生成的程序比较大, 装载.exe时, 消耗的起始内存较多.

		使用'静态共享链接库'的好处是:
			生成的程序比较小, 消耗的起始内存较少;
		缺点:
			运行程序时, 需要初始化, 要找齐所有依赖的'动态共享链接库', 并版本正确, 装载正确.
			有5%的CPU 运算性能损耗(但节约了内存)


	生成可执行文件后, 无论什么后缀都可以直接运行,
	linux不认后缀, 但认ELF封装.

	可以使用ldd 命令查看'链接后的二进制file'的信息:
		ldd ./<x.exe>






#
# 3.ld 链接器
#
gcc 只是一个编译器, ld 才是链接器.
默认情况下, gcc 会自动调用ld 做所有链接的工作.

最后还会附加ELF 头部, 并将共享链接库的信息, 全部附上到ELF 头部中.





第二部.s编译好之后, 所有的函数API调用, 都只是:
	call printf
	call open
	call close
	call printf
一个call 中断调用和printf,open,close函数指针定义而已.
函数体API 哪里去了??

	如果是'.a 静态库': 
		ld 链接器在链接的时候, 会将函数体整个拷贝一份出来, 插入到程序中.
		因此你可以看到, 使用ld 链接之后, .exe 文件远比.o 编译文件'大得多'.

		[ 微软的静态库与gcc 静态库有些不一样, 由于微软是商业系统, 对自家的静态库管理比较简单,
			微软提供: #program comment(lib,"") 来包含.a 静态库, 但是gcc 并没有相关的实现.]

		总体来说, 静态库需要直接用-l 'LDFLAGS链接选项'指明静态库的路径!!
		-lpthread 实际上, 就是链接静态库'libpthread.a', 在glibc 的实现中, 你可以找到:
			-lpthread = /lib/x86_64-linux-gnu/libpthread.so.0
			-lm       = /lib/x86_64-linux-gnu/libm.so.6
			(去掉lib 前缀和.so .a 后缀 + 版本号, remember??)



	如果是'.so 动态链接库':
		那么你需要在编译的时候, 指明编译选项-fPIC;
		否则编译出来的函数, 不具备T 共享属性, 外部程序无法访问到这样的函数;
		.so链接库的私有函数, 外部也是没办法调用的,
		.so也有私有函数的概念, 这类似于OOP 面向对象的封装原理一样.

		.so有一个自定义的'导出函数列表', 用来封装'私有函数/导出函数'.
		*** .a 静态链接库, 就应该没有这个概念了 ***
		然后在'编码调用库函数'之前, 先要询问系统, '.so 共享链接库'的位置,
		如果系统还没装载'.so 共享链接库', 则找不到, 你需要:
			# 导入拼接变量,在原来的/lib /usr/lib的基础上,加入自己的'.so共享链接库'路径
			export LD_LIBRARY_PATH=<your .so library path>:$LD_LIBRARY_PATH
			或者:
				cd /usr/lib # cd /lib
				ln -s <your .so library path>
				# 更新一下系统默认装载的'.so 共享链接库'
				ldconfig
			或者:
				在C/C++ 程序中, 自己描述装载过程:
				dlopen() dlerror() dlsym() dlclose()
		(总之, 询问, 装载'.so 共享链接库' 会有1-5% 的性能损耗)

		再有, '.so 动态链接库'需要指明'链接选项' -shared,
		否则不能达到节省内存的作用, 跟.a 静态链接库无异,
		每个使用它的进程, 都自己维护一套'.so 动态链接库'的代码块.







#
# 4.gcc 调试工具
#
* gcc 除错的首选工具是< GNU 除错器 >, 即gdb;

* 其他特殊用途的除错工具是Valgrind, 用以发现内存漏失(Memory leak)

* GNU 测量器 (gprof) 可以得知程序中某些函式花费多少时间, 以及其呼叫频率;
	此功能需要使用者在编译时选定测量<profiling>选项, 即编译选项-pg







#
# 5.gcc 编译选项
#
优化选项: 
	gcc编译C/C++代码时, gcc会试着用最少的时间, 完成编译任务, 
	并且编译出易于调试的程序.
	易于调试, 意味着:
		编译后的程序, 与源代码有同样的执行顺序, 基本没有做cpu 执行顺序优化, 尽量保持源代码和程序, 一对一, 方便debug(断点/coredump);

	有很多的选项可以告诉gcc, 在耗费更多编译时间, 和牺牲易调试性的基础上, 编译出更小更快的可执行文件.

	*** 自动编译优化方案集 ***
	这些选项中最典型的就是-O和-O2(-O, -O2 都是'自动编译优化方案集')
	-O:  gcc进行基本优化编译
	-O2: gcc进行深度优化编译
	-O3: gcc进行极限优化编译
	还有一些很特殊的选项可以通过man gcc察看.
	-O -O2 -O3 优化方案集中包含那些选项, 你可以查看gcc 的说明文档.

	优化程度越大, 编译消耗的时间和CPU资源就越多.





调试和剖析选项: 
	gcc支持数种调试剖析选项. 在这些选项中最常用的是-g和-pg.

	-g,  编译时, 加入'符号调试工具(GNU的gdb)所必要的符号资讯', 方便gdb 进行调试
	-pg, 编译时, 加入'性能测试统计的计算逻辑, 打印方法, 等信息', 方便gprof 进行调试








