//
//内核syscall 中的休眠函数, 跟glibc 中的休眠函数不一样!!
//
/*
	************************************************************
	在linux 内核驱动开发中, 经常要用到延迟函数:msleep, mdelay／udelay
	虽然msleep 和mdelay 都有延迟的作用, 但他们是有区别的．
	(上面的函数,不是linux api里面的函数,需要有头文件, 只有sleep-秒 是c 语言函数)

	而在服务器开发中, 一般不会用到忙等待, 做完任务就马上返回,
	等待也是同步数据时的死等, 很少故意睡眠线程的...
	************************************************************

	1.对于模块本身
	mdelay是忙等待函数, 在延迟过程中无法运行其他任务．
	这个延迟的时间是准确的．是需要等待多少时间就会真正等待多少时间．

	msleep是休眠函数, 它不涉及忙等待．你如果是msleep(10),
	那实际上延迟的时间, 大部分时候是要多于１０ms的, 是个不定的时间值．


	2.对于系统:
	delay函数是忙则等待, 占用CPU时间;
	mdelay() 会占用cpu资源, 导致其他功能此时也无法使用cpu资源.

	而sleep函数使调用的进程进行休眠,
	msleep() 则不会占住cpu资源, 其他模块此时也可以使用cpu资源.


	3.udelay() mdelay() ndelay() 区别:
	实现的原理本质上都是忙等待, ndelay和mdelay都是通过udelay衍生出来的.

	我们使用这些函数的实现往往会碰到编译器的警告:
	implicit declaration of function 'udelay',
	这往往是由于头文件的使用不当造成的. 

	在include/asm-xxx/delay.h中定义了udelay(),
	而在include/Linux/delay.h中定义了mdelay和ndelay.

	udelay一般适用于一个比较小的delay, 如果你填的数大于2000,
	系统会认为你这个是一个错误的delay函数, 
	因此如果需要2ms以上的delay需要使用mdelay函数.


	4.msleep, ssleep区别:休眠单位不同 ms and ss


	5.秒的单位
	ms是毫秒=0.001秒
	us是微秒=0.000001秒
	ns是纳秒=0.000000001秒
*/




