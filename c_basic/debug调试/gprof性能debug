gprof 缺点:
	运行带有gprof 的程序, 必然会自动生成烦人的gmon.out文件, 十分烦;





#
# <1. gprof 实现原理 >
#
通过在编译程序的时候(使用-pg 编译选项), 
gcc 在你应用程序的每个函数中都加入了一个名为mcount 
( or "_mcount" , or "__mcount" , 依赖于编译器或操作系统)的函数, 
然后记录每个函数的调用次数和调用时间等信息,
借此来统计出程序的运行性能.

应用程序里的每一个函数都会调用mcount, mcount 会在内存中保存一张函数调用图, 
并通过函数调用堆栈的形式查找子函数和父函数的地址. 
而'这张调用图'也保存了所有与函数相关的调用时间, 调用次数等等的所有信息, 
方便做性能调试统计.

注意: 
	-pg 选项, 只能应用在GNU 标准的代码中, 而且必须使用gprof 调试选项, 而并非gdb





#
# <2. gprof 性能调试命令 >
#
usage:
	gprof <options> ./<exe>

options:
	-b 不再输出统计图表中每个字段的详细描述. 

	-q 只输出函数的调用图(Call graph的那部分信息). 

	-p 只输出函数的时间消耗列表. 

	-e Name 不再输出函数Name 及其子函数的调用图(除非它们有未被限制的其它父函数). 
		 可以给定多个 -e 标志.
		 一个 -e 标志只能指定一个函数. 

	-E Name 不再输出函数Name 及其子函数的调用图, 此标志类似于 -e 标志, 
		 但它在总时间和百分比时间的计算中排除了由函数Name 及其子函数所用的时间. 

	-f Name 输出函数Name 及其子函数的调用图. 
		 可以指定多个 -f 标志. 一个 -f 标志只能指定一个函数. 

	-F Name 输出函数Name 及其子函数的调用图, 它类似于 -f 标志, 
		 但它在总时间和百分比时间计算中仅使用所打印的例程的时间. 
		 可以指定多个 -F 标志. 一个 -F 标志只能指定一个函数. -F 标志覆盖 -E 标志. 

	-z 显示使用次数为零的例程(按照调用计数和累积时间计算). 

demo:
	gprof -b test gmon.out |less





#
# <3. gprof 使用要点 >
#
1) 一般gprof只能查看用户函数信息. 
   如果想查看库函数的信息, 需要在编译时再加入"-lc_p"编译参数代替"-lc"编译参数, 
   这样程序会链接libc_p.a库, 才可以产生库函数的profiling信息. 

2) gprof只能在程序正常结束退出之后才能生成程序测评报告, 
   原因是: gprof通过在atexit()里注册了一个函数来产生结果信息, 
   任何非正常退出都不会执行atexit()的动作, 
   所以不会产生gmon.out文件. 
   如果你的程序是一个不会退出的服务程序, 那就只有修改代码来达到目的. 
   如果不想改变程序的运行方式, 可以添加一个信号处理函数解决问题(这样对代码修改最少)

3) 优点: 
   GNU工具, 人手一个;
   混合方法采集信息.

   缺点: 
   需要编译选项支持: 
     i.   使用gcc/cc编译和链接时需要加入-pg选项
          (编译和链接都要加-pg, 而且要指定-D_GNU_SOURCE, 只有GNU 源才能用)
     ii.  使用ld链接时需要用/lib/gcrt0.o代替crt0.o作为第一个input文件
     iii. 如果要调试libc库需要使用-lc_p代替-lc参数

   调试多线程程序只能统计主线程的信息(所以不能用于kingbase).







