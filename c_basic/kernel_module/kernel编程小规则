0.linux驱动程序, 可以编译成哪几种exe二进制文件:
	1)内部编译: 将驱动程序源码放在内核源码目录中进行编译
	2)外部编译: 将驱动程序源码放在内核源码目录外进行编译
	3)静态编译: 编译进uImage中
	4)动态编译: (.ko文件,动态加载驱模块)





1.内核程序与用户程序的区别:
  >用户程序: 
    拥有无限增大, 动态增长的堆栈(内存), 访问glibc '共享库'等特性.
    ps: 
      共享内存可以节省很多内存, 这样程序可以写很复杂.


  >内核程序: 
    拥有固定堆栈(根据CPU 架构决定的缓存), 不能访问glibc '共享库',
    所有函数均为'静态编译'函数(真实代码, 非共享)等特性.
     ps: 
       由于内核程序编译出来后, 可能比较大(全部是静态编译, 当然大)
       那么'内核代码必须是高效, 精简的'. linux kernel 所有代码都是自产的.
       没有调用gnu 的代码, 但是还是用了gnu 的代码解析器.

       只要你写用户程序, 那就调用std libc.so.6.
       然后实际使用是共享库存储代码的方式节省内存.
       只要你写内核程序, 编译时:-nostdlib 直接全部代码写实, 静态编译, 
       所以/use/include/Linux 里面的头文件指向的内核函数都是又小又高效.


    ps2: 
      你引用/usr/include/linux 中的头文件, 说明你引用了kernel 精简代码,
      用户程序同样可以引用这里的部分函数, 有部分则不可以.
      比如数据结构, 你仍然可以使用.

      但涉及内核设备配置的文件, 建议你还是不要直接引用.
      最好还是用/usr/include 下面的比较好.
      使用/usr/include 下的文件, 可以使用glibc 共享库减少内存的使用.


    ps3: 
      内核的实现与glibc 的实现差别很大!!
      glibc 主要是以posix 为标准, 也提供gnu 拓展特性.
      内核则更像一个设备管理器, 资源管理器, 内核可不管什么posix 标准.
      内核只是尽量满足posix 的功能需求, 自身编码却是清一色的gnu 标准!!
      linux 内核项目有很多gnu 编码特性, 而不是一个posix 内核.


    ps4: 
    	glibc 代码也支持'静态编译', glibc 和内核, 都支持'静态编译'.
      静态编译, 动态编译共享库, 只是一种内存节省手段,
      本身并不区分'内核代码库', 还是glibc 库.
      但是有一点:
      linux 程序规定:只有linux内核程序才能创建新的内核程序.[书本上验证ok]
                    而且内核程序不能访问glibc.
      这样说, 内核程序只能静态编译!! 
      不过你不嫌弃效率地, 也可以用glibc 库的函数写内核程序.
      但不能在用户程序上, 使用'内核函数库'中的函数.
      内核内存申请使用kmalloc(),跟malloc() 有点差别,可能会出现兼容性问题.
      操作系统用户态的api != 内核态的api

      如果你引用内核程序的头文件,无他的,就是速度快,就是消耗小,不过功能也少.
      至于你写的程序运行在内核空间还是用户空间, 那是你编译好之后的事.





2.linux kernel programming:

>2.1: 内存非法访问的问题:
  内存非法访问, 实际是指: 空指针, 内存块溢出等, 就叫‘内存非法访问’!!
  内核程序, 如果出现非法访问, 结果是未知的, 
  可能系统崩溃, 但你也收不到通知, 没人通知你.
  用户程序, 只要进程出现非法访问, 马上会被内核发送信号, 终止运行.


>2.2: 内核程序与用户程序的差异(再次包括):
  内核程序不能访问C 库文件!! 也不能访问posix c 的头文件.
  (主要是效率不行, 静态编译太大)
  内核只有一个很小的定长堆栈(这就是关键, 你还用c 库函数, 会直接挤爆堆栈的)
  内核并没有内存保护, 如果访问到空指针, 你就可能要重启系统了.(这样debug 也很麻烦)
  内核很难算浮点数.
  内核支持异步中断, 抢占, SMP(多核CPU 抢占), 并发抢占方式多, 整形数有专用原子操作函数,
    甚至不需要加锁来进行线程同步(主要是加锁对内核来说太慢了).
    但内核程序的竞争性很容易产生, 多线程同步最麻烦.


>2.3: 内核栈的大小, 内核栈一般是2 页的(x86 架构为例-不分amd/intel)
    32 bit=4kb*2=8kb
    64 bit=8kb*2=16kb


>2.4: linux 进程
  内核把进程的列表存放叫做任务列表(task list) -- 双向循环链表.
  节点结构: struct task_struct; 在32 bit 机器上, 单个节点大概有1.7KB.
  '节点结构=进程描述符'指向的内存块, 里面包含的数据能完整描述一个程序:
  打开的文件, 进程的地址空间(堆内存?), 挂起的信号, 进程状态, 等等...
  (这个结构体可以被重用, 但必须先wait() 释放后, 才会被自动重用.)

  struct thread_info{struct task_struct;...}
  
  pid 默认极限=32768(short int max), 但可以修改, 以容纳更多进程.

  frok 写时复制, 复制出来的变量统一存放在每个进程的共享资源中
  (文件句柄, 进程地址空间等都可被共享)这部分必定释放, 不会被重用, 
  你可以想想一个fork ()的消耗.
  进程结束回收task_struct原则上是需要手动wait(), 
  如果父进程之间结束, 子进程会被init 收了, 
  但子进程未结束init 不会强制结束, 只是会调用Wait 询问其状态.
  所以'子进程'也有假死的可能, 阻塞僵死, 不能被回收.

  Linux 线程也有task_struct,实际就是一种特殊进程. 


>2.4: 进程调度
  linux 并不是时间片方式的分时抢占系统, 具体实际是1/n 这样分时的(n 指系统进程的数量)
  当进程太多, 导致1/n 少于1ms 时, linux 最小保留1ms 作为时间片.
  windows 就是以时间片的方式, 做分时抢占的.
  (注意: 抢占, 切换进程, 是有一定消耗的, 这种切换属于内耗.
        良好的调度应该是: 兼容响应速度和执行效率, 切换进程只是手段.)

  非抢占式多任务系统, 就是:除非进程自己主动停止, 否则它会一直运行.

  你可以用ps -el 查询系统中所有进程的运行优先级(NI = nice 值).


  休眠和running 进程是两个不同数据结构存放, 
  进程拉进休眠队列中就无人问津(休眠队列无轮询扫描), 
  直到有明确操作将它拉进running 红黑树中(唤醒), 才会再次分享到CPU 时间. 
  

  只要没有锁的进程, 就可以被抢占. 锁, 是进程非抢占的标志!!
  SMP 多核, 指的是N 个任务, 自动平分到M 个核心上, 抽象隔离物理空间.


>2.5: 中断
  应用程序大部分都是软中断, 即函数调用时的压栈, 栈还原操作.
  跟其他中断有点不一样, 其他中断都是内核编码时, 才会用到的.
  内核中断和软中断的处理流程类似, 但是实现是两个不同的概念,
  内核中断主要面向驱动, 这里不再叙述.


>2.6: 临界区
  临界区, 就是指: 访问和操作共享数据的代码段, 实现原子操作.
  操作执行结束前, 不可被打断, 整个代码段像一个系统api 一样不可分割. 这就是临界区.
  单个临界区, 也是一个加锁粒度.
  在内核程序中, 锁的使用显然速度较慢, 频繁被持有的锁, 长时间持有的锁, 
  或者又频繁, 又长时间持有的锁(更慢), 对内核程序都造成不少影响.

  内核支持两组'原子操作函数', 可以直接对atomic_t 变量直接原子操作不需要加锁, 
  一组面向int 数据, 一组面向bit 位数据. 


>2.7: 节拍
  x86 架构的节拍默认是100hz=10ms, 其他体系架构的节拍默认是:250/1000 = 4ms/1ms
  节拍实际上系统定时器hitting popping 的频率.
  节拍率越高, 意味着始终中断的频率越高.
  也意味着系统的负担越重, 对于arm, 由于外设繁多(移动设备外设比较多, 所以默认节拍才会高)

  poll(), select() 书上明确表明与系统节拍有关, 不知道epoll 是不是??
  
  Linux 节拍会自己变动, 以达到节省电能的效果, 长时间不操作节拍会变慢.


>2.8: 内存管理
  主要是页, 还有slab 内存分配重用之类的.
  比较特别的是kmalloc 所谓申请内核内存, 应该就是指: 
  kmalloc() 申请的内存, 就是8/16kb 的高速缓存.
  内核程序是固定堆栈的嘛.










