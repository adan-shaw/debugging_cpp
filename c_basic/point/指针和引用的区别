*指针在动态链接库编程中, 有比较好的使用优势, 因为: 构建函数指针时, 定义形参比较容易;

&虽然比较节省内存, 但一般用在.exe 可执行二进制程序中, 
如果不确定使用'*/&', 建议还是别省内存, 直接多定义一根指针, 更划算!!



* 指针:
	指针需要先定义, 使用规则: 定义*指针, 传入*指针;
	指针有阶级, *p, **p, ***p ... 
	(虽然多阶指针并没有什么实用意义, 但指针是可以这么玩的, 一般最多就用到**p 二阶指针, 也就是指向指针的指针)



& 引用:
	引用不需要定义, 使用规则: 定义变量实体, 传入&引用;
	引用无阶级, 引用操作没有阶级, 只是引用值所在的内存地址而已;



指针和引用的共同点:
	指针可以做的事情, 引用也可以做;
	指针是指向'变量地址'的变量,
	引用是引用'变量地址'的操作,
	都是徘徊在'变量地址上的值', '变量地址', 这两个概念上徘徊;



指针和引用的不同点:
	指针需要先定义一个变量, 消耗多一个内存地址(32bit/64bit), 指针本身是一个变量;
	引用不需要定义, 直接使用, 引用本身是一个操作;

	引用比指针稍微节省一点内存, 在极度苛刻的嵌入式领域中, 比较常用;
	指针常见于c++ 程序中;

	指针的优点:
		当变量实体是'堆内存'变量时, 指针可以在多个函数之间, 多个线程指针轻松流转;
		而引用一般情况下, 只能流转在上下级函数中, 多级函数中流转比较麻烦, 费时费力, 还不如一根指针;
		(当然, 如果函数之间, 线程之间, 没有访问'该变量实体'的权限, 则指针和引用都不能访问, 没有访问权, 肯定不能访问啊, 废话)
		ps:
			谈引用全局变量/静止变量, 没意思, 访问全局变量/静态变量, 根本不需要引用, 就能直接访问;



指针和引用的使用要点:
	指针和引用不能混用, 指针引用一下, 就是指向指针本身的地址!!
	但一般情况下, 编程很少需要在乎指针地址的, 除非你用到了**p 二阶指针;
	所以一般情况下, 用了指针就不用引用, 用了引用就不用指针;

	(一阶指针引用一下, 并不是就会降级成为二阶指针, &引用不会导致降级;
	 但二阶指针赋值, 可以是: **p = &(*p);
	 所以, 也不是说完全不会混用, 看场合, 一般来说, 很少混用的)





常见的指针使用方式(特点: 如果有访问权, 指针可快速流动于多个函数, 线程之间):
	定义变量, 定义指针, 传递指针->'带指针参数的函数':
		void func1(int* p);	//定义'带指针参数的函数'
		int money=99999999;
		int* p = money;			//这是一种省缺写法, 编译器自动翻译为: int* p = &money;
		func1(p);						//传递指针->'带指针参数的函数'

	定义变量, 定义指针, 直接引用传递变量->'带指针参数的函数':
		void func2(int* p);
		int money=99999999;
		func2(&money);			//直接引用传递变量->'带指针参数的函数'



常见的引用使用方式(特点: 如果有访问权, 引用也只能在函数上下级之间流动, 但节省内存):
	定义变量, 直接引用传递变量->'带引用参数的函数':
		void func3(int &p);	//定义'带引用参数的函数'
		int money=99999999;
		func3(&money);			//直接引用传递变量->'带引用参数的函数'

	定义变量, 定义指针, 传递指针->'带引用参数的函数': [[极度不推荐这种傻逼用法, 都定义了引用参数函数了, 还要指针作甚, 十分无聊, 这是个反面教材!!]]
		void func4(int &p);	//定义'带引用参数的函数'
		int money=99999999;
		int* p = money;			//这是一种省缺写法, 编译器自动翻译为: int* p = &money;
		func4(p);						//传递指针->'带引用参数的函数'





指针参数函数/引用参数函数的区别:
	指针参数函数:
		把指针地址压栈, 压栈后, 指针参数相当于一根已赋值的指针, 可当成普通指针使用, 
		结构体/类的元素引用方式: Struct->A; Class->B;

	引用参数函数:
		把引用地址压栈, 压栈后, 引用参数是一个变量实体, 可当成变量实体使用(相当于直接把变量挪过来用, 把变量实体从A 函数转移到B 函数), 
		结构体/类的元素引用方式: Struct.A; Class.B;




