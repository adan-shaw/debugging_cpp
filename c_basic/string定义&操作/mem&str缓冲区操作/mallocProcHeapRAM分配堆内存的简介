//
//*1.进程堆的运行机制, 使用方法简介
//
* 进程的变量存储空间分布:
		.exe自身已经装载的变量空间.data
		进程运行时'分配&初始化'的变量空间.bss
		进程运行过程中申请的'malloc 或new'空间, 进程堆内存
		函数内部的局部变量, 线程栈数据


* malloc,new 申请的内存, 归属ptmalloc 重用,管理,二次分配.
	free,delete 不一定是直接释放, 也有可能被ptmalloc重用.


* 如果发生程序内存泄漏, 
	最终只能等进程结束, 由linux内核init 进程释放进程资源时, 将泄漏内存全部清空.
	如果用特殊方法绕开linux内核init 进程, 
	那么, 可能最终泄漏内存没办法回收, 需要重启系统.


* 内存申请几乎是不限定大小的, 32bit 有限制:
		windows: 2+2=4GB(系统保留2G)
		linux: 1+2=4G(系统保留1G)


* cpu访问缓存的速度:
		主频是2.6G, 也就是说: 每秒可以执行2.6*10^9个指令, 每个指令0.38ns
		分支预测错误需要耗时5ns, 
		一级缓存读取大概是0.5ns, 
		二级缓存大概是7ns, 
		三级缓存大概是50ns,
		加锁解锁一次大概是25ns*2=50ns
		内存大概是100ns; 从内存中读取1MB的连续数据,耗时大约为250us

		一次CPU上下文切换, 大概是1500ns
			(上下文切换更恐怖的事情在于, 这段时间里 CPU 没有做任何有用的计算, 
			 只是切换了两个不同进程的寄存器和内存状态;
			 而且这个过程还破坏了缓存, 让后续的计算更加耗时.)

		在1Gbps的千兆网络上, 传输2K的数据需要20us; 同一个数据中心网络上跑一个来回需要0.5ms
			(网络数据,数据量越大,性能越慢,tcp/ip包协议的硬伤)

		SSD随机读取耗时为150us
			(磁盘虽然寻址慢,但是持续数据读取性能强,比网络好;
			 从SSD读取1MB的顺序数据, 大约需要1ms)

		disk磁盘寻址时间为10ms, 从磁盘读取1MB连续数据需要20ms
			(磁盘同理,寻找虽慢,但是找到数据后,持续传输的速度比较快)


* 修改ptmalloc 回收策略:
		'进程堆'接受ptmalloc 的管理, 申请和释放, 都交由ptmalloc 负责;
		因此, ptmalloc策略也有一定重要性, 详细配置策略, 请看: 
			./ptmalloc内存回收策略&OOM策略
		(实际由于内存性能比较好, 一般情况下, 不会是系统瓶颈)








//
//*2.进程堆使用API 分析
//
在大多数情况下, 编译器和C库透明地帮你处理对齐问题. 
POSIX标明了通过malloc(),calloc(),realloc()返回的地址, 对于任何的C类型来说都是对齐的. 


在Linux中, malloc(),calloc(),realloc()这些函数返回的地址,
在32bit系统是以8字节为边界对齐, 在64bit系统是以16字节为边界对齐的.
也就是:
	假设申请1024 字节内存, 那么32bit 的一节'内存边界'是8字节, 64bit是16字节;
	有些程序对内存边界大小敏感.


有时候, 程序需要更大的边界, 例如: 
	页面数据, 程序员需要动态的对齐'页面数据'.
虽然'页面数据的需求动机'是多种多样的, 
但最常见的是:
	直接块I/O的缓存的对齐, 或者其它的软件对硬件的交互, 
	因此, POSIX 1003.1d提供一个叫做posix_memalign()的函数

* Linux has memalign() or posix_memalign()
* Solaris has memalign()
* FreeBSD 7.0 has posix_memalign(), besides, early version's malloc()
* aligns allocations bigger than page size at the page boundary


memalign(), valloc(), 无法在BSD系统中使用, 
而且BSD系统中并未提供"释放memalign()和valloc()申请的'堆内存块'的途径",
因此不推荐使用!!
可以使用posix_memalign()来代替.



