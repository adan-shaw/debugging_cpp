要阅读本文, 请先清楚并理解:
	./dll全量编译装载,dll选择性动态装载的区别



**********************************重申*************************************
注意:
	调用dlclose()/FreeLibrary(), 只是会减少'dll/so 共享链接库'在系统中的引用计数;
	具体'dll/so 共享链接库'是否释放, 要看'dll/so 共享链接库'在系统中的引用计数是否为0, 为0 则自动释放, 不为0 则继续使用;



dll 一般也可以全量装载&映射, 仅限编译期间进行, 简单来说就是编译链接; 但ld 连接器仍然会选择需要用到的函数API 进行烧写, 而不会全部都烧写到.exe 程序中;

编译后, .exe 可执行程序中, 会保留一根指针(或者说API 符号), 
.exe 程序在运行时, 会将该API 符号指向的函数体的.code 段, copy 到.exe .code 段, 完成elf 头解析;
.exe 程序的.data 段, 会在函数调用时, 自动将局部变量入栈;
**********************************重申*************************************



1.lib 共享链接库的封装简介:
	共享链接库的封装, 实际上是比普通编写.exe 编码, 要稍微复杂一点;

	普通.exe 编码:
		合理使用全局变量, static 变量, 局部变量, 常量;
		需要考虑多线程问题的话, 首先就要学会封装'线程安全函数', 
		如果要面向对象编程, 还要学会封装类;

	共享链接库的封装编码:
		需要考虑多线程的话, 共享链接库同样需要会封装'like-线程安全函数', 不同点是:
			共享链接库函数, 允许阻塞(既然阻塞就不要加锁)





2.关于'dll/so 共享链接库'中的全局变量, 静态变量:
	static 静态变量:
		在所有情况下, static 修饰的全局变量/函数, 永远不会被'so/dll/exe可执行文件'模块外部看到;
		C++ 标准要求它们具有内部链接, 这意味着static 变量不对外开放访问, 等价于类里面public/private 的关系;
		外部类想要访问private 变量, 得做一个public 跳转;
		外部'so/dll/exe可执行文件'访问内部static 静态变量, 也需要做一个跳转;
		windows/linux 都不允许在共享链接库中的static 变量对外暴露;


	全局变量:
		当你的dll 中有全局变量时, 事情就变得复杂了(Windows 和Unix 系统完全不同):
			Windows(.exe和.dll):
				全局变量不是导出符号的一部分, 不能使用extern 关键字引用全局变量;

			Unix环境(.exe和.so):
				.so 共享链接库, 可以导出全局变量, 可以使用extern 关键字引用全局变量;

	总结:
		为了保证跨平台, 线程安全原则, 编写'so/dll 共享链接库', 尽量禁用全局变量, 减少差异;
		而使用static 变量时, 尽量保证仅供'so/dll 共享链接库'内部可见;





3.windows/linux 要导出'dll/so 共享链接库'API 函数, 都需要两步:
	1.windows/linux 要导出'dll/so 共享链接库'API 函数, 都需要加一个导出声明前缀:
		for linux:
			// demo: 强制命令main() 函数在.so 中对外可见
			__attribute__ ((visibility("default"))) int main(void) {}
		for windows:
			// demo: 强制命令main() 函数在.dll 中对外可见
			__declspec(dllexport)

		否则call 引用dll/so API 时, 会报错:
			dlsym() failed: undefined symbol API_name


	2.是否需要加extern "C" {}:
		无论linux/windows 平台, 都必须要加extern "C" {}, 否则导出dll API 时, 函数符号不能识别
		(非extern "C" 标准的函数符号, 大部分不能被识别, 调用时会找不到改API 函数符号)
		[在.h 头文件中添加extern "C" {}即可, .cpp 文件中不需要添加]
		linux:
			linux 定义so 导出函数时, c/c++ 函数都要强制加一个extern "C" {} ;
			gcc 编译器强大, 兼容能力强, 能直接在API 返回类型中, 返回c++ 类实体(new/malloc);
			(gcc 编译器统一当成指针来处理, 兼容能力强一点)
			因此, 在.so 共享链接库中使用std::string 等c++ 特性时,
			不用管, 照样定义就行, 别以为在extern "C" {} 中就不能使用c++ 特性, 具体解析交给编译器去做;
		windows:
			windows 定义dll 导出函数时, 如果使用到std::string 等c++ 特性时, 规则约束比linux 复杂, 有可能不通过;





4.尽量使用c 语言标准封装'dll/so 共享链接库'!!
	否则你就算封装出'dll/so 共享链接库', 但API 函数符号不能识别, 照样调用不了这个API(编译通过不代表程序没问题)!!
	c++ 的API 函数符号非常复杂, 而且'dll/so 共享链接库'中不允许出现c++ 的 :: 域限定符, 
	因此, 虽然你可以在'dll/so 共享链接库'中, 使用c++ 的类, 作为参数or 返回值,
	但你还是需要在extern "C" {} 中定义导出函数, 否则'dll/so 共享链接库'的API 函数符号, 可能会不能识别;
	因此, 还是要以c 语言标准来封装'dll/so 共享链接库'的;





5.'dll/so 共享链接库'的APi 函数封装标准:
	* 线程安全函数封装标准
	* 还要考虑参数的导出导入:
			线程安全函数, 大部分可以使用线程内数据段共享data 的, 加锁建立临界区即可;
			但'dll/so 共享链接库'导出API, 是没有线程内数据段共享data 的, 
			'dll/so 共享链接库'和调用的进程, 是两个独立的进程, 两个独立的进程段, 因此不能实现共享段数据;
	* 'dll/so 共享链接库'封装, 不允许线程同步手段, 否则容易死锁!!
		在'dll/so 共享链接库'API 内, 你不需要对自己加锁,
		但在'dll/so 共享链接库'API 之外加锁/解锁, 'dll/so 共享链接库'内部加锁/解锁, 就十分容易触发死锁, 
		所以严重不建议在'dll/so 共享链接库'中使用任何一种IPC 线程同步方式: 锁和信号灯都不允许;

	所以, 'dll/so 共享链接库'封装, 比编写多线程/多进程程序, 还要复杂一点:
	难度:
		多线程 < 多进程 < 'dll/so 共享链接库'





6.关于'dll/so 共享链接库'中的阻塞:
	共享链接库很有意思的部分是: 
		它允许阻塞, 只要业务允许即可(但绝对不建议你这么做0.0), 
		但API 调用过程中, 不允许挂起;

	一般来说线程安全函数连阻塞和static全局变量都不能用;
	'dll/so 共享链接库'可以使用static 变量, 但static 变量对外不可见, 不推荐使用全局变量!!




