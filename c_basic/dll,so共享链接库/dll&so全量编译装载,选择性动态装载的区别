'dll/so'全量编译装载:
	'dll/so' 共享链接库全量编译装载, 是指编译过程中, 编译器会要求将用到的所有'dll/so' 共享链接库, 提供给编译器;
	而编译器拿到'dll/so' 共享链接库后, 会根据需求, 将需要用到的API 函数, 映射到.exe 可执行程序中;
	最终烧制出.exe 二进制封装文件;

	实际上这个链接过程, 并没有编译过程那么漫长, 
	link 链接时的顿卡, 相比于漫长的编译过程, 简直九牛一毛;
	所以, link 连接器链接'dll/so' 共享链接库, 实际上就是: 'dll/so'全量编译装载;





'dll/so'选择性动态装载:
	'dll/so'选择性动态装载, 是指程序在执行前, 会先进行elf 头文件映射检查,
	此检查步骤中, 会有一步:
		检查elf 头中需要用到的'dll/so' 共享链接库, 并向系统索取映射, 
		将需要用到的API 函数映射到.exe 可执行程序的.code 区, 然后才能运行程序;

	这种动态装载的方式, 也可以被编程人员使用:
		编程人员自己装载'dll/so' 共享链接库到内存中,
		然后通过自定义的函数指针, 定位到'dll/so' 共享链接库中的匹配符号区域(一个符号, 一个函数API)
		最后, 完成选择性动态调用'dll/so' 共享链接库中的API;



注意:
	调用dlclose()/FreeLibrary(), 只是会减少dll/so 共享链接库在系统中的引用计数;
	具体dll/so 共享链接库是否释放, 要看dll/so 共享链接库在系统中的引用计数是否为0, 为0 则自动释放, 不为0 则继续使用;



dll 一般也可以全量装载&映射, 仅限编译期间进行, 简单来说就是编译链接; 但ld 连接器仍然会选择需要用到的函数API 进行烧写, 而不会全部都烧写到.exe 程序中;

编译后, .exe 可执行程序中, 会保留一根指针(或者说API 符号), 
.exe 程序在运行时, 会将该API 符号指向的函数体的.code 段, copy 到.exe .code 段, 完成elf 头解析;
.exe 程序的.data 段, 会在函数调用时, 自动将局部变量入栈;
