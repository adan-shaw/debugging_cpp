#
# 0.py编码优化技巧简介
#
优化通常包含两方面的内容: 
	* 减小代码的体积;
	* 提高代码的运行效率;


	lua 的很多特性, 在python 中都适用(解析型语言的通病):
	例如:
		交换变量:
			x, y = y, x 
		不需要: 
			temp = x 
			x = y 
			y = temp

	例如:
		尽量使用局部变量!! py检索局部变量比检索全局变量快.
		脚本机都一样, 检索全局变量, 需要先读全局变量表,
		检索局部变量, 需要多少内容, 就直接检索多少内容, 性能更好


	python的内置API, 标准库API, 性能出色, 因为底层都是直接套用c API的;
	不要用python 编写自定义算法function, 
	直接用python 内置的函数实现功能, 性能更好.

	python内置函数list, 参考:
		./web网文/python常用内置函数.html

	例如:
		直接用map() 来替代for 循环, 其实性能比py 跑for 循环更好!!
		lua 也是一样的, 直接使用map set 等内置函数, 将数据重建, 比你跑lua for逻辑循环, 性能优秀很多.

	在计算密集的地方, 很大次数的循环体中, 要尽量减少函数的调用及调用层次;
	(能用内置函数, 达到相同的效果, 首选内置函数, 不用计较内存的频繁创建与释放, python 有GC, 会自动重用内存的)





#
# 1.字符串拼接优化
#
python 字符串的更换, 会触发缓冲区free() and malloc(),
如果是python 字符串的值修改, 那字符串的内容都更改了, 你就没有优化的必要了;
例如:
	s1 = "fuck"
	s2 = "you"
	ss = s1 + s2

	对少数几个字串相并, 应避免用:
		all = str0 + str1 + str2 + str3 
	而用: 
		all = '%s%s%s%s' % (str0, str1, str2, str3)



如果是字符串自加拼接, 在末尾添加, 应该使用join() 函数.
例如:
	s1 = "fuck"
	s2 = "you"
	ss = "007"
	# 这样python 会先释放ss 原来的str_buf缓冲区, 再新建一个str_buf缓冲区, 来装在数据,
	# 造成缓冲区频繁free() and malloc()
	ss += s1
	ss += s2
	# 正确做法是: [ps: join() 函数, 遇到数字会报错, 先用str() 转换, 保证join() 正确运行]
	ss.join(str(s1))

join() 的好处是:
	减少缓冲区释放, 只新增, 不释放, 更类似c++ 的字符串拼接, 性能更好.





#
# 2.import 导入模块(容易发生顿卡)
#
python的import 导入, 就是动态读文件的过程, 文件大, 读的就慢. 
如果不把导入模块设计好, 似乎会形成性能上的瓶颈.
简单来说, 两个import 原则:
	尽量使用初始化原则, 在程序运行初期, 导入大部分模块
	尽量最小化原则, 不要导入无关的模块(import 是要消耗时间的)

在一个py 文件中,只需一次导入一个外部模块即可.
最好能在__init__.py 中一次导入, 这样只会导致python 程序启动慢, 
启动之后, 模块内的所有.py 文件, 都不用再调用import 导入模块了.





#
# 3.用内置函数来拆for循环体, 性能更好[原则上, script 机都只适合跑if而已, for循环都是: 尽量用内置函数, 拆开重建更快]
#
例如你想把一个长数列 l=['a', 'b', ...]中的每个字串变成大写, 可能会用:
import string
newL = []
for s in l: newL.append( string.upper(s) )

用map就可以省去for循环的前头:
import string
newL = map (string.upper, l)


对循环的优化所遵循的原则是:
	尽量减少循环过程中的计算量, 能预处理的, 就先预处理, 能用内置函数拆解的, 直接用内置函数拆解.





#
# 4.减少周期性检查
#
这是python 的本征功能: 
	周期性检查有没有其它绪(thread)或系 统信号(signal)等要处理;
	可以用sys模块中的setcheckinterval 来设置每次检查的时间间隔;

	缺省是10, 即每10个虚拟指令(virtual instruction)检查一次;
	当你懒得搭理系统信号时, 将检查周期拉长, 会增加速度, 有时还会很显著.








