python 是否需要自己实现stl 容器?
答:
	不需要, 直接'语法糖'即可;

	python根本不需要swig, 不需要对接c/c++, 制造更多高性能容器,
	因为python 本身就有大量现成的容器, 可以直接import 导入后使用(语法糖, 太美妙);
	因此, python 很少会用到swig project, 除非你是写python 官方模块的开发者, 那你会用到swig project;
	(ps: swig project 太深奥了, 普通人耍不动)


python 是否需要手动释放stl 容器的内存?
答:
	一般情况下, 对于已创建的stl 容器, 
	如果不再使用, 可以使用del关键字将其删除;
	实际开发中, 并不经常使用del来删除列表, 因为Python自带的垃圾回收机制会自动销毁无用的列表, 
	所以即使开发者不手动删除, Python 也会自动将其回收;
	但有些庞大的容器, 开发者可以适当在用完之后, 手动删除容器;





#
# python 内置容器中的二进制数据块/array
#
* 二进制数据块(bytes, bytearray, memoryview):
	memoryview, 单纯的二进制块, 没啥操作API, 忽略, 不用理会;
	bytes, 与bytearray 功能几乎一致, 有不少二进制数据块操作API;
	bytearray, 与bytes 功能几乎一致;
	因此, 二进制数据块操作, 基本在bytes, bytearray 之间, 二选一;

* int 变量的位操作:
	只有int 数据类型, 才可以进行位操作, 与c 语言类似;

* array(字符,整数,浮点数):
	python array 与c 语言的数组类似, 支持字符,整数,浮点数, 也有大量操作api;
	array 与string 可以轻松互转;

* string:
	python 的字符串, 和c++ 的字符串一致, 支持各种匹配子字符串, 拆分, 剪切等操作;
	array 与string 可以轻松互转;





#
# python 4种内置容器概述:
#
*1.列表(List):
	读写容器, 有下标, 可排序, 可更改值, 可新增值, 允许重复的集合.

*2.元组(Tuple):
	只读容器, 有下标, 不可排序, 不可更改值, 不可新增值, 允许重复的集合.

*3.集合(Set):
	只读容器, 没有下标, 无序, 无key索引, 不可更改值, 可新增值, 不允许重复的集合.

*4.词典(Dictionary):
	读写容器, 没有下标, 无序, 有key索引, 可更改值, 可新增值, 不允许重复的集合.



Python标准内建容器dict, list, set, tuple 简介:
	list列表:
		python 中的list列表, 实际上是'array+指针'实现的(有疑问请看源码剖析), 并不是c/c++ 中的链表;
		而且list 是有序的, 自动排序, 因此索引性能也很强;
		而且list 是自动增长的, 当元素不够用时, 则自动新增array 空间, 实则更像c/c++ 中的vector;
		(增删会触发重新排序)
		当list 只含有数字时(int/float), 等同于数组;
		当list 含有字符串, 其他object 时, list等同于'array+指针';
		(这点跟lua table 差不多, 脚本都是大同小异的)


	tuple元表:
		python 中的tuple元表, 实际上也是'array+指针'实现的(有疑问请看源码剖析);
		由于tuple元表不能增删, 有序的, 自动排序, 因此索引性能也很强;
		而且不需要考虑增长, 直接一个固定array 即可解决问题, 性能更优!!
		ps:
			当tuple的大小不超过20时, Python就会把它缓存在内部的一个free list中;
			这样你以后再创建同样的tuple时, Python 会直接从缓存中载入, 效率极高;


	set集合:
		set 实际上也是一个hash, 无序;
		且插入set的元素, 必须是可以hash的;
		set 可随意增删(增删不会触发重新排序), set的元素具有唯一性(重复插入, 则自动覆盖);
		不可索引(也没有索引的必要, 只需知道set集合里面有没有这个元素即可, 需要索引, 请用dict);
		可手动遍历, 查找元素;
		不可排序, 不可交换, 如需要有序的set, 直接将set 导入到list 中重构, 这样反而性能更好;
		set 是哈希结构, 也十分方便进行集合运算: 差集, 交集, 补集;


	dict字典:
		Python的dict字典是通过哈希表实现的, 
		有key, 有value, 无序, 可随意增删(增删不会触发重新排序);
		key具有唯一性(重复插入, 则自动覆盖), key的要求必须为可hash;
		可根据key 进行索引, 取出value;
		可手动遍历, 查找元素;
		不可排序, 不可交换, 如需要有序的dict, 直接将dict 导入到list 中重构, 这样反而性能更好;



# python list 拓展:
	* heapq 堆队列
		python 要创建一个堆, 可以使用list来初始化为[], 或通过一个函数heapify(), 来把一个list转换成堆;
		heap[0]表示最小的元素, 同时heap.sort() 维护了堆的有序性;
		ps:
			堆是一个二叉树, 它的每个父节点的值, 都只会小于或等于所有孩子节点的值;

	* 二分法查找
		对于一个有序的list, 可以直接使用二分法进行维护, 这样可以提高性能, 减少维护成本;





collections 模块中的容器简介:
	Counter:
		基于字典的子类, 提供了可哈希对象的计数功能;
	defaultdict:
		基于字典的子类, 提供了一个工厂函数, 为字典查询提供了默认值;
	OrderedDict:
		基于字典的子类, 保留了他们被添加的顺序;

	ChainMap:
		类似字典的容器类, 将多个映射集合到一个视图里面;

	namedtuple:
		创建命名元组子类的工厂函数;

	deque:
		类似列表容器, 实现了在两端快速添加(append)和弹出(pop);







