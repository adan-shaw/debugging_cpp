前言:
	protobuff 的2/3 版本差异很大, 几乎等于了重写, 基于, 参考protobuff 的dds/someip, 相信也会有两个版本, 如opendds 就有: idl 3/4 两个版本;
	学习protobuff / dds / someip 的时候, 尽量选择新的版本去研究, 你也可以看看两个版本的差异;

	注意:
		protobuff 2/3 互相兼容的可能性不高, 而且*.proto 文件中, 只能声明使用一个版本, 你必须作出选择!!
		syntax = "proto2";//二选一
		syntax = "proto3";

总的来说, proto3 比proto2 支持更多语言, 
但更简洁, 去掉了一些复杂的语法和特性, 更强调约定而弱化语法; 
如果是首次使用Protobuf , 建议使用proto3 ; 





#
# proto 2/3 的主要区别如下:
#
1.在第一行非空白非注释行, 必须写: 
syntax = "proto2";
syntax = "proto3";


2.字段规则移除了"required", 并把"optional" 改名为"singular"1; 
	在proto2 中required 也是不推荐使用的;
	在proto3 直接从语法层面上移除了required 规则; 
	其实可以做的更彻底, 把所有字段规则描述都撤销, 原来的repeated 改为在类型或字段名后加一对中括号, 这样是不是更简洁? 


3."repeated"字段默认采用packed 编码; 
	在proto2 中, 需要明确使用[packed=true] 来为字段指定比较紧凑的packed 编码方式; 


4.语言增加 Go, Ruby, JavaNano 支持; 


5.移除了default 选项; 
	在proto2 中, 可以使用default 选项为某一字段指定默认值; 
	在proto3 中, 字段的默认值只能根据字段类型由系统决定; 
	也就是说, 默认值全部是约定好的, 而不再提供指定默认值的语法; 

	在字段被设置为默认值的时候, 该字段不会被序列化, 这样可以节省空间, 提高效率; 
	但这样就无法区分某字段是根本没赋值, 还是赋值了默认值; 
	这在proto3 中问题不大, 但在proto2 中会有问题; 
	比如, 在更新协议的时候使用default 选项为某个字段指定了一个与原来不同的默认值, 旧代码获取到的该字段的值会与新代码不一样; 
	另一个重约定而弱语法的例子是go 语言里的公共/私有对象; 
	Go 语言约定, 首字母大写的为公共对象, 否则为私有对象; 
	所以在Go 语言中是没有public.private 这样的语法的; 


6.枚举类型的第一个字段必须为0 ; 
	这也是一个约定; 


7.移除了对分组的支持; 
	分组的功能完全可以用消息嵌套的方式来实现, 并且更清晰; 
	在proto2 中已经把分组语法标注为"过期"了; 这次也算清理垃圾了; 


8.旧代码在解析新增字段时, 会把不认识的字段丢弃, 再序列化后新增的字段就没了; 
	在proto2 中, 旧代码虽然会忽视不认识的新增字段, 但并不会将其丢弃, 再序列化的时候那些字段会被原样保留; 
	我觉得还是proto2 的处理方式更好一些, 能尽量保持兼容性和扩展能力, 或许实现起来也更简单; 
	proto3 现在的处理方式, 没有带来明显的好处, 但丢掉了部分兼容性和灵活性; 

	[2017-06-15 更新]: 经过漫长的讨论, 官方终于同意在 proto3 中恢复 proto2 的处理方式了; 


9.移除了对扩展的支持, 新增了Any 类型; 
	Any 类型是用来替代 proto2 中的扩展的, 目前还在开发中; 
	proto2 中的扩展特性很像Swift 语言中的扩展, 理解起来有点困难, 使用起来更是会带来不少混乱; 
	相比之下, proto3 中新增的Any 类型有点像C/C++ 中的void* , 好理解, 使用起来逻辑也更清晰; 


10.增加了 JSON 映射特性; 
	语言的活力来自于与时俱进; 
	当前, JSON 的流行有其充分的理由, 很多"现代化"的语言都内置了对 JSON 的支持, 比如Go, PHP 等; 
	而C++ 这种看似保罗万象的学院派语言, 因循守旧, 故步自封, 以致于现出了熄灭的苗头; 

	(原作者真是会开玩笑, 哈哈, 看来是写go 语言的互联网程序员, 想法很天真^_^, 欢迎他去工业的世界里面走一走)



