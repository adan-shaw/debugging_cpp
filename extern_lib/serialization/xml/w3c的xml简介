前言:
	xml 结构化的标准描述语言, 实际上也是一种序列化语言, 也遵从序列化语言的原则: 
		就是为了'离线保存应用数据/传输应用数据'而设计的

	json 也是一种序列化语言, 只不过json 不是w3c 推出的标准而已;

	序列化语言的本质:
		都是为了离线保存应用数据, 或者为了传输应用数据;





1.简述w3c 与xml 的由来:
	World Wide Web Consortium万维网联盟(外语缩写:W3C)标准, 不是某一个标准(单个标准), 而是一系列标准组成的集合. 
		结构化标准语言: 主要包括XHTML和XML
		表现标准语言:   主要包括CSS
		行为标准语言:   主要包括对象模型(如W3C DOM)、ECMAScript等

	这些标准大部分由W3C起草和发布, 也有一些是其他标准组织制订的标准, 比如ECMA的ECMAScript标准(European Computer Manufacturers Association)
	总的来说, xml 的诞生, 本身就是为了web 网服务的.
	可以视为是'可视化标记数据'的始祖, 但本质上, 也是一种序列化语言!!

	非W3C 推出的语言, 但实际上已成为万维网的事实标准的有:
		web 后台应用数据序列化语言: json
		web 前台行为控制语言: javascript





2.xml 封装标准:
	expat是一个基于SAX模型的、非验证(默认, v1.2开始提供验证接口, 需要用户手动处理)的轻量级XML解释器. 
	目前XML的解析主要有两大模型:
	* SAX:
		SAX(Simple API for XML)是基于事件的解析方法. 
		基本工作原理是分析XML文档, 通过触发事件来通知用户解析的结果. 
		这种方式占用内存少, 速度快, 但用户程序相应得会比较复杂. 
	* DOM:
		DOM(DocumentObject Model), 则是一次性将整个XML文档进行分析, 在内存中以树结构保存解析结果. 
		同时, 向用户提供一系列的接口来访问和编辑该树结构. 
		这种方式占用内存大, 速度往往慢于SAX, 但可以给用户提供一个面向对象的访问接口, 对用户更为友好. 





3.各种版本的xml 解析库分析:
	expat: 
		expat是一个基于SAX模型的、非验证(默认, v1.2开始提供验证接口, 需要用户手动处理)的轻量级XML解释器. 
		expat是使用C所写的XML解释器, 采用流的方式来解析XML文件, 并且基于事件通知型来调用分析到的数据, 
		并不需要把所有XML文件全部加载到内存里, 这样可以分析'非常大'的XML文件.

	pugixml:
		是一个轻量级的C++ XML开源解析库, DOM形式的解析器、接口和丰富的遍历和修改操作, 快速的解析, 
		此外支持XPath1.0实现数据查询, 支持unicode编码; 

	tinyxml:
		tinyxml 是一个基于DOM模型的、非验证的轻量级C++解释器. 





4.为什么expat 只有解析xml, 没有生成xml?
	实际上, 生成xml 的过程必然是缓慢的, 而且大部分是客户端的工作.
	但解析xml 的过程, 很多时候需要快速解析, expat 就是专为解析而生的.

	expat 源码全部是纯C所写, 因此, 非常容易移植, 尤其是适用于嵌入式平台, 
	我在往联芯的手机平台上移植时, 几乎没改任何东西.
	不过, 优点也带来了缺点, 因为是采用流的方式解析XML, 
	所以不会像TinyXML那样在一块内存中生成基于DOM的树, 这样使得expat 解析起来略显麻烦.

	最后: 
		通常xml 都是用来描述'图形标签'的, 如果需要传输'轻量结构化语言', json 会是更好的选择!!



