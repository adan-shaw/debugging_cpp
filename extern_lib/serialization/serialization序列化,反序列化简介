前言:
	serialization序列化的本质意义, 就是'离线存储/在线传输'时, 把app data应用数据转化为一种可压缩, 还原, 存储, 转移的数据格式;

	序列化与反序列化概念:
		将程序的某些数据存储在内存中, 然后将其写入某个文件或是将它传输到网络中的另一台计算机上以实现通讯;
		这个将程序数据转化成能被存储并传输的格式的过程被称为"Serialization序列化", 而它的还原过程则可被称为"De-serialization反序列化";

	序列化/反序列化最终输出到:
		* 文件中, 静态离线存储
		* 内存缓冲区中, 用作: 
				打印显示, 
				网络传输, 
				'短暂数据共享/寄存', 
				...等等;
		* 存放在常见的数据库中:
				其实数据库也是一个大型序列化产品, 只不过数据库支持较多的查找, 统计等等算法, 存储之后, 还能做很多进一步操作而已;
				市面上常见的数据库, 无论是传统的mysql,pgsql,sqlite, 还是redis 等等, 基本上最基本的原始技术, 就是序列化;





#
# 1.互联网-文本式'serialization序列化/De-serialization反序列化'简介
#
序列化通常出现在互联网当中, 也偶见在嵌入式行业, 但通常, 序列化分为两种:
	app应用数据序列化: json/ini
	可视化数据序列化: xml/html/qml/wxml [一般还会配合css一起工作, css就是标签样式描述语言, 一般是可视化引擎的核心]


	简要说明:
		json: 常见的互联网应用数据序列化标准
		ini:  常见的应用程序配置文件序列化标准

		xml:  最原始的序列化标准, 可用于应用, 也可用于描述可视化数据(由于比较笨重,通常只用来描述可视化数据)
		html: web最常见的可视化数据序列化标准, 描述web控件标签;
		qml:  qt 开发的可视化数据序列化标准, 描述qt控件标签;
		wxml: 微信开发的可视化数据序列化标准, 描述微信小程序控件标签;
		...

	js 前端编程语言:
		js 一般是标签数据的行为描述语言, 属于前端, 目前独霸市场, 没有对手;





#
# 2.错误理解: 通信协议不是序列化
#
嵌入式序列化[错误理解]:
***********************************************************************
	通信协议, 一定程度上, 就是一种序列化, 只不过嵌入式行业, 序列化最小粒度是1bit;
	常见的有:
		i2c,rs385,spi,can,tcp/ip等, 都是通过1bit 1bit 实现通信协议, 
		从序列化的角度看, 这也是一种序列化的表现;
***********************************************************************

以上是对'serialization序列化/De-serialization反序列化'的一种错误理解, 通信协议不是序列化!!
	如果把通信协议看成是序列化, 就没办法解释:
		* tcp/ip 是按位操作的, 可以理解;
			但rtmp/rtsp/hls 也是按位操作的, 这就无解了;
			http 报文有必定的分隔符号'CRLF'回车换行, 容易理解(粒度=1byte=8bit);
			但tcp/ip, rtmp/rtsp/hls, 都是按照报头长度来按1bit 进行位操作的;

		* 嵌入式应用, 有时候也需要'serialization序列化/De-serialization反序列化', 用来保存应用数据;
			比如说: sqlite, ini, xml, cjson, 等等, 如果把网络协议看成是序列化的一种, 则会与网络协议混淆的;
			因此, 网络协议不算是序列化;

	总结:
		序列化存在固定的分割符号, 每段数据不一定相等, 格式不定, 但以分割符号为准;
		网络协议按照固定的格式, 固定的内容进行翻译, 格式长度也是固定的, 只能在一定范围内变动, 不能随意更改格式和内容长度;
		因此, 网络协议&序列化, 有一定的现实差异;

		本质上, 网络协议使用数据的本质, 是为数模转换, 网络传输服务, 做记号, 做可靠性保障的;
		而'serialization序列化/De-serialization反序列化'本质上, 使用来保存应用数据的, 导出应用数据的, 传输应用数据的, 侧重点不一样!!
		因此, 网络协议不算是序列化;





#
# 3.数据库与序列化的关系
#
数据库到底是不是序列化?
答:
	序列化的本质, 最终还是侧重在: 保存应用数据的, 导出应用数据的, 传输应用数据的, 侧重点是应用数据;
	数据库的本质, 最终还是侧重在: 
		* 账户密码
		* 文本, 图片, 音乐, 视频
		* 内存数据
	但这些数据, 本质上也可以看作是应用数据, 
	所以, 数据库与序列化的关系, 可以说是规模关系, 数据库本质上就是一个大型应用数据keeper 工具;
	你可以把:
		* 传统的disk 数据库, 看成是离线冷数据-序列化的存储工具, 偶尔读取一下;
		* 新型的内存型数据库, 看成是在线热数据-序列化的存储工具, 频繁读写, 频繁操作, 非常活跃的应用数据;

	正是因为有了数据库的出现, 应用数据的离线存储, 本机在线共享, 这类工具的市场被填满, 
	因此, 你常见的'serialization序列化/De-serialization反序列化'编程库: json/ini/xml/html/qml/wxml, 都是为了网络传输和显示而准备的,
	潜移默化, 让你觉得'serialization序列化/De-serialization反序列化', 就是用来'网络传输/显示'的, 而忽略了序列化/反序列化的本质,
	序列化/反序列化的本质:
		保存应用数据的, 导出应用数据的, 传输应用数据的, 侧重点是应用数据;


	因此, 序列化/反序列化, 本质上就是数据库最基本的技能之一, 当然数据库在这个基础上, 还设计出更复杂的功能;
	实际上数据库对数据的存放格式, 是多种多样的, 具体: 
		连续数组/链表, 堆/二叉树/多路树, hash 等, 存储方式都不一样, 而且不是以分割符来划分界限的,
		还有数据库有大量的算法支持, 而序列化只是简单增删查改, 序列化与反序列化, 几个简单操作;
		数据库则有大量的查找算法, 聚合算法, 统计算法支撑;
		所以, 数据库与序列化, 也有很大区别;





#
# 4.是否有自己实现'序列化与反序列化'的必要? (绝对没有这个必要!! 请看: boost序列化,反序列化的弊端)
#
什么是'serialization序列化/De-serialization反序列化'? 应该怎样用序列化?
	外面的人的意思是: 
		根据一定的规则, 利用分割符号, 实现的序列化应用数据, 就叫序列化;
		根据一定的规则, 把已序列化的应用数据还原, 就叫反序列化;

	但其实都是废话, 完全没有自己实现'serialization序列化/De-serialization反序列化'的必要,
	因为你无论怎么样约定序列化, 都有一两个缺陷字符串不能用的;

	序列化都有关键词约束的(就是有些关键词不能用), 你只要明白:
		设计是否违反大小字节序列的问题, 影响准确复原,
		如果能正确复原数据, 根本不需要复杂的序列化手段, 呵呵;
		所以, 区分数字/字符/二进制数据的区别即可;

	所谓的序列化和反序列化, 实际上都是一种数据格式的约定;
	而且序列化有大量的现成项目, 如果没有特殊用途, 根本不需要自己实现序列化;

	json/xml 有大量的成功案例, 
	json 常用于传输应用数据, xml 通常用来实现可视化界面, 这已经是行业规定了, 
	虽然一定程度上, json, xml 都算是笨重的, 你可以设计更简便的序列化方案, 但根本没必要;

	如果想节约资源, 也行, 做一个对照表, 然后数据节命名, 都用a,b,c,d 等单个字符串命名, 
	收到数据之后, 再通过对照表复原数据即可, 
	还能压缩空格, 换行, 进一步压缩字符串, 
	但这些都是小招数, 实际上只是浪费时间在折腾而已, 没必要自己重写序列化的实现, 这是一个无耻的洗脑行为;





#
# 5.'serialization序列化/De-serialization反序列化'在不同行业上的应用
#
通信行业基本上, 都是: 
	应用, 协议, 数据, 序列化, 信号 -> 信号, 反序列化, 数据, 协议, 应用
	说白了就是将应用数据压缩成一维数组, 逐位发送出去(物理层是逐位发送的, 如果不懂, 看看数模转换)
	最终都是:
		应用数据 -> 压缩成一维数组(序列化) -> 逐位发送(数模转换) -> 逐位接收(数模转换) -> 反序列化(还原应用数据) -> 应用数据 -> 执行操作;

	所以, 专心做拓展技术的事情, 集中精力解决新技术的问题, 不要被人带节奏, 在泥潭里面打爬, 简直开玩笑, 无耻的洗脑行为;



应对二维矩阵, 三维立体, 四维=时间+三维的未来趋势, 如何传输这些数据?
	传统的json 处理应用数据, 的确很适合, 
	但面对目前市场需求, 2/3/4 维度的数据存储需求, 会对新的序列化方案, 提出新的需求;
	使用json + 2/3/4维度的数字简单序列化, 可以提高应用的解析效率, 提高网络程序的性能, 甚至是可靠性;

	json 记录:
		LWH+T = 4维数据记录, 每一个都是int, 声明: 图片的长宽, 立体空间的长宽高, 四维空间的长宽高+时间;

	但实际上, 跟连续内存数组的原理差不多, 
	你实际上可以直接将 2/3/4 维度的数据, 直接排列成一维数组, 只要使用',' 号分割符即可;
	(确保是宏定义分割符即可, 不满意还能换, 轻松)

	但这是你一厢情愿而已, 真的传输字符数据, 直接使用网络大小端转换函数, 消耗绝对比number to string的消耗要小;
	而且转换之后, 同样可以在网络上面传输, 
	而且大小规格更好控制, 是最优方案;
	(如果你打算在网络上传输2/3/4 维的number数组, 网络大小端转换函数是最适合)





