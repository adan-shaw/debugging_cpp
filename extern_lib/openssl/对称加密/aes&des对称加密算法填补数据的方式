注意:
	16 进制下, 0x00 两位数即为一个字节!!
	2 进制下, 8 位数为一个字节!!

	只有'对称加密'算法, 需要填补数据!!
	'hash校验和'算法, 并不需要填补数据;



*1.aes 填充方式
	openssl库默认的aes加密方式如下(即:'块的分组加密'模式为ecb模式) 
		AES_KEY aeskey;
		unsigned char userKey[16];
		AES_set_encrypt_key((uint8 *)userKey, bits=128, &aeskey);
		AES_encrypt(unsigned char * in, unsigned char *out, &aeskey);

		常见的分组模式为电子密码本模式(ECB)、加密分组链接模式(CBC)、加密反馈模式(CFB)和输出反馈模式(OFB). 
		实际上openssl封装了更高层的evp_*函数调用. 
		給一个函数名称EVP_EncryptInit, 便于查看man手册. 


		前面的userKey可以这样赋值:
			unsigned char userKey[16]={0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf};

		等效的openssl命令为: 
			$ echo -ne 'hello world\0\0\0\0\0' | openssl  enc  -aes-128-ecb  -nosalt -nopad  -K  '000102030405060708090A0B0C0D0E0F'  | xxd
			# 执行结果
			$ 0000000:  1281 34b4 5a7c 03ad 6dc6 5a47 97a0 77f2  ..4.Z|..m.ZG..w.



	AES 使用时的填充方法(AES 使用前, 需要明确规划出: 你加密的数据的具体长度, 否则填充不好搞):
	AES是分块计算的, 当数据内容不足, 不足部分就需要填充, 常见的aes 加密长度: 
		16字节(128 bit aes),
		24字节(192 bit aes),
		32字节(256 bit aes)
	ps:
		一个AES_BLOCK_SIZE = 16 bit = 2 字节. 
		那么最小加密长度为: AES_BLOCK_SIZE * 8, 最大加密长度 = AES_BLOCK_SIZE * 16 = 32 字节??
		(反正太长的text, 你也不需要加密吧, 如果长text 需要加密, 可能用DES 更简单快捷)

		如果超出32 字节的数据, 那就分块!!
		一块32 字节, 但密钥还是一样就行了. 
		一块32 字节, 所以如果数据太长, 建议还是用DES 加密, 虽然没有那么安全.



	AES 常见的有5 种填充方法: 
	1.ANSI X.923
		不足部分填充0, 最后一字节为填充字节数. 如下面8字节的块, 需要填充4字节时: 
			... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |
		ps: 04 即最后一个字节, 即16 进制的0x04.

	2.ISO 10126
		不足部分填充随机数字, 最后一字节为填充字节数. 如下面8字节的块, 需要填充4字节时: 
			... | DD DD DD DD DD DD DD DD | DD DD DD DD BC DA EF 04 |

	3.PKCS7与PKCS5(标准填充方式)
		不足部分填充为需要填充字节数. 若数据大小是分块大小N的倍数时, 则增加一个全为N的分块. 
		如下面8字节的块, 需要填充4字节时: 
			... | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 |

	4.ISO/IEC 7816-4
		不足的部分, 首先填充一个0x80, 剩余部分全为0. 如下面8字节的块, 需要填充4字节时: 
			... | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 |
			要求数据内容本身不包含0x80

	5.Zero padding(这种方式不安全)
		不足部分全部填充0. 如下面8字节的块, 需要填充4字节时: 
			... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 00 |
		这种方法不能区分数据内容本身末尾包含0的情况, 因而也不是标准的填充方式. 

	openssl aes加密时, 若指定nopad, 则要求数据本身是分块大小的整数倍. 
	否则根据openssl手册描述, 使用标准填充方式, 验证这种方式即为PKCS7. 





***
(经实践证明: des 基本不需要理会填补规则, 直接导入数据即可运行des 加密算法.)
***

*2.DES的几种填补方式
	DES是对64位数据的加密算法, 如数据位数不足64位的倍数, 需要填充, 补充到64位的倍数.
	ps: 
		AES 一般是填'0x04' 结束的, 是填一个字节!!
		但是, DES 是按位填充的, 只要填满每一节都是64 位即可, 其实更简单.
		也不需要分块, AES 超出32 字节的数据, 就需要分块!! 然后两块合并, 共用一个密钥.

	1.NoPadding:
		API或算法本身不对数据进行处理, 加密数据由加密双方约定填补算法. 
		例如:
			若对字符串数据进行加解密, 可以补充\0或者空格, 然后trim 

	2.PKCS5Padding 
		加密前:
			数据字节长度对8取余, 余数为m, 
			若m>0, 则补足8-m个字节, 字节数值为8-m, 即差几个字节就补几个字节, 字节数值即为补充的字节数, 
			若m=0则补充8个字节的8 
		解密后:
			取最后一个字节, 值为m, 则从数据尾部删除m个字节, 剩余数据即为加密前的原文 

		因为DES是一种block cipher, 一个block要8个字节, 所以要加密的东西要分成8字节的整数倍, 不足的就填充. 
		PKCS5Padding这种填充, 填的字节代表所填字节的总数:
			比如差三个字节的话, 填为 @@@@@333 
			差7个字节就填为 @7777777 
			没有差就填 88888888

	3.Zero padding
		不足8位补 0, 有可能会出问题, 因为不知道数据本身会不会以一个或多个 0 字节结尾. 



	关于DES/CBC模式的向量:
		在CBC(不光是DES算法)模式下, iv通过随机数(或伪随机)机制产生是一种比较常见的方法. 
		iv的作用主要是用于产生密文的第一个block, 以使最终生成的密文产生差异(明文相同的情况下), 
		使密码攻击变得更为困难, 除此之外iv并无其它用途. 
		最大的好处是, 即使相同的明文, 相同的密钥, 也能产生不同的密文. 

		使用 jdk 自带的类库, 同样的明文、密钥、向量, 产生的密文不一样, 应该是加入了随机机制.





