//什么是进程内存管理器? 存在系统级别的统一内存池么?
/*
	明确告诉你, 没有所谓的系统统一内存池!! unix/linux 没有这么糟糕的设计;
	这么庞大的内存池, 肯定是一个mess !!

	unix/linux 最常见的设计是:
		一个进程, 一个ptmalloc 内存管理器, 内存管理器属于进程所有,
		进程结束, init 进程会释放一切资源, 包括ptmalloc 内存管理器中的内存;
		(ps: init 进程也有自身的ptmalloc 内存管理器, 但这不是本节的重点)

	所以, 总结:
		unix/linux 是一个进程, 一个ptmalloc 内存管理器, 内存管理器属于进程所有, 这是一个关键概念;
		每个进程在运行前, 都会从init 进程中拷贝一个ptmalloc 内存管理器, 作为自己的内存管理器;
		(再一次验证: 所有进程都是init进程的子进程, 所有进程clone() 的时候, 都必须拷贝内存管理器, 这是一个必要拷贝选项)
*/



//jemalloc是什么?
/*
	jemalloc, tcmalloc, ptmalloc 是常见的c/c++ 进程内存管理器;
	每个进程都有一个自带的内存管理器, 管理进程内创建的堆内存: new/malloc'创建/释放'的内存;
	进程内存管理器的目的, 就是提高内存块的重用率, 减少内存碎片;
	这是目前unix/linux 系统最常见的内存管理做法;
*/



//进程结束后, 'ptmalloc 内存管理器-内存池'会被释放吗? 内存泄漏的时候, init 进程有办法清算干净吗?
/*
	进程结束之后, 'ptmalloc 内存管理器'一定会被init 进程释放!!
	'ptmalloc 内存管理器'中的内存块, 会被全部释放, 这也是必然的;

	即便你的进程内存泄漏了, 只要进程一结束, 泄漏的内存, 都难逃init 进程的清算;
	防止内存泄漏的意义是:
		保证进程的持久运行能力, 设计高度可靠的进程, 可持续长时间运行的进程, 一定不能内存泄漏;
		否则只能在进程结束的时候, 泄漏内存才被init 进程回收;
		这种进程, 就是儿戏, 可靠的工业程序是不允许这种情况出现的;

	所以, 发生内存泄漏, 只会导致进程崩溃, 一旦进程结束, 被泄漏的内存, 也难逃init 进程的清算;
	但容易导致的情况是:
		泄漏内存的进程一直不结束, 而且耗尽了系统内存(不舍进程内存增长上限的系统),
		这样会导致系统内存耗尽而卡死;
*/
