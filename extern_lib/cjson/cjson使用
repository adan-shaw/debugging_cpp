//cJSON Types数据类型宏:
#define cJSON_False 0
#define cJSON_True 1
#define cJSON_NULL 2
#define cJSON_Number 3
#define cJSON_String 4
#define cJSON_Array 5
#define cJSON_Object 6
#define cJSON_IsReference 256
#define cJSON_StringIsConst 512





//cJSON 节点结构体如下:
typedef struct cJSON{
	struct cJSON *next,*prev;	//'前向或后向'的链表指针
	struct cJSON *child;			//子节点
	char *string;							//'本节点'的名字
	int type;									//'本节点'的类型
	char *valuestring;				//值类型: 字符串
	int valueint;							//值类型: 整数
	double valuedouble;				//值类型: 浮点数
}cJSON;

//说明:
/*
	cJSON 实际上是一个链表结构, 每个节点的创建和删除, 都会使用malloc/free 申请堆内存;

	基于链表的cJSON, 虽然频繁创建/删除, 可能会导致内存泄漏的问题,
	但由于cJSON 都是定长struct 结构体, 且很小, 绝大部分会被ptmalloc 重用回收;
	反而是cJSON 结构体中的两个字符串, 反而是不定长字符串, 容易产生内存碎片的问题;

	所以, 网络程序, 一般更换更好的内存管理器: jemalloc/tcmalloc, 有一定优势;
	限制数据格式, 做一个替换表, 将数据名, 全部替换成26个单字母, 数字, 更能节省内存(但比较麻烦);

	最终, 其实不用太在意内存重用的问题, 
	因为应用数据的产生, 本来就是随机的, 没办法避免, 
	应用编码不是嵌入式编码, 数据比较复杂, 随机性很大, 
	所以根本没有可能限制数据格式, 只能依赖ptmalloc内存重用, 减少数据碎片了;

	服务器应用, 长时间运行, 不关机, 内存重用压力很大, 
	而且进程不能崩溃, 运行时间一久, 压力很大!! 虽然进程崩溃了, 内核会清算回收资源, 但这已是另外一个话题了;
	服务器程序, 就是集中注意力, 不让进程崩溃;
*/
