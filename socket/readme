由于本节的知识太庞大, 涉及工业通信协议/互联网通信协议, 
所以本节默认以最简单的互联网通信协议, 做最简单的说明, 
其它细节, 只能具体行业, 具体分析了, 每一类协议, 都是一个故事, 很难全部展开的;

喜欢互联网开发的, 请看: AF_INET互联网应用协议list
喜欢工业通信开发的, 请看: socket协议簇list

ps:
	互联网也是socket 协议簇中的一员, 主要是AF_INET协议簇;
	只不过AF_INET协议簇是socket 协议簇中规模最大, 最土豪的一员而已;
	其它socket 协议簇, 并没有AF_INET协议簇那么多次级协议;

	具体研究哪个方向, 看个人喜好;
	本节以最简单的AF_INET协议簇做说明, 默认看到的编码文件, 都是AF_INET协议簇的;



本节注重描述socket 应用层编码, 有可能涉及驱动编码的不分是:
	socket无线电协议簇
	socket实时工业总线
	socket其他协议簇
	socket协议簇list

	但实际上, 只要是已经封装成socket 的, 基本上都是应用层编码, 最多就是用到原始套接字;
	如果想根据网络协议, 封装出驱动, 请看linux 内核编码/Embedded嵌入式编码;
	通常的:
		通过linux 内核编码, 得出驱动, 一般是PC周边的设备;
			主要是用linux 内核syscall 封装出posix API/socket API;
		通过Embedded嵌入式编码, 得出驱动, 一般是嵌入式设备;
			主要根据详细的协议内容, 用小芯片进行最原始的协议封装, 得出一个完整的嵌入式设备;



综上所述, 本节侧重讲应用层编码, 就算是:
	AF_CAN       -- CAN总线socket API封装
	AF_BLUETOOTH -- 蓝牙socket API封装
	AF_ROUTE     -- 路由域套接字socket API封装(只支持raw模式[需要root权限])
	AF_PACKET    -- 链路层socketAPI封装(需要自己附上ARP 报文)
	AF_PPPOX     -- 电话线2跳线转RJ45网线socket API封装(model 光猫/电猫)的通信协议簇[很少用]
	AF_RDS       -- 英国广播电台标准socket API封装(广播电台专用)
	...
	等等
	都是描述linux 在装载了具体'对应的驱动.ko'之后, 调用的应用层socket API封装, 进行应用级编码;



如果需要根据详细协议进行最原始封装, 
则需要利用计算机芯片+系统, 再根据报文详细内容, 1bit, 1bit地描述;
例如:
	I2c详解(最简单的, 最容易理解)
	can总线(相对容易理解, 详细报文并不是AF_CAN socket, socket 是已封装好的应用层API接口)
	蓝牙(无线电方向, 比较简单的入门协议, 详细报文并不是AF_BLUETOOTH socket, socket 是已封装好的应用层API接口)
	...
ps:
	设备协议的最小数据粒度, 通常是1bit;
	互联网应用协议的最小数据粒度, 通常是1字节(8bit,一个字符);



目前大量的小型嵌入式系统, 如RT-Thread, vxworks等, 大部分都仿造了部分posix API;
主要用来做多线程/多进程的同步&通信, [内存级, 不可丢弃]
也集成了fs 文件系统, [可丢弃(裁剪), 可新增]
也集成了tcp/ip 协议栈, [可丢弃(裁剪), 可新增]
...

如果你要做存储设备, 则需要用到SPRAM(包括SPI&PCIE)/SDRAM, 编写存储设备主控驱动(对接PC,对接Linux内核);
虽然理论上, fs 文件系统与设备主控, 是隔层的, 互不影响, 
但实际上, 也可能会'重建/新建'fs 文件系统, 让存储设备实现存取更高效, 设备寿命更高等;
[不对接PC 的存储设备, 例如嵌入式设备自身新增一块存储芯片, 则直接用SPRAM(包括SPI&PCIE)/SDRAM协议即可, 不需要封装驱动]

如果你要做普通设备, 则需要根据详细的协议, 直接根据协议, 进行编程(嵌入式设备的子设备);
如果你要做对接PC的设备, 则还需要上一步的基础上, 对接Linux内核, 根据syscall封装出应用层API;



新增:
	由于工业总线也更新换代了, 所以, 目前工业总线主要也分: 旧时can 总线 & 新型的'以太网实时增强型工业总线',
	详情请看: ./socket实时工业总线简介
