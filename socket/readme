由于本节的知识太庞大, 涉及工业通信协议/互联网通信协议, 
所以本节默认以最简单的互联网通信协议, 做最简单的说明, 
其它细节, 只能具体行业, 具体分析了, 每一类协议, 都是一个故事, 很难全部展开的;

喜欢互联网开发的, 请看: AF_INET互联网应用协议list
喜欢工业通信开发的, 请看: socket实时工业总线简介 + realtime工业总线简介
喜欢无线电通信开发的, 请...(作者本人并没有接触过无线电类的开发, 十分可惜, 不然这里面应该有一个分支, 等价于: socket实时工业总线简介 + realtime工业总线简介)

ps:
	互联网也是socket 协议簇中的一员, 主要是AF_INET/AF_INET6 协议簇;
	只不过AF_INET协议簇是socket 协议簇中规模最大, 最土豪的一员而已;
	其它socket 协议簇, 并没有AF_INET协议簇那么多次级协议;

	具体研究哪个方向, 看个人喜好;
	本节以最简单的AF_INET协议簇做说明, 默认看到的编码文件, 都是AF_INET协议簇的;



本节注重描述socket 应用层编码, 有可能涉及驱动编码的部分是:
	socket无线电协议簇
	socket实时工业总线
	tcp/ip AF_PACKET 链路层协议簇(主要面向多媒体/防火墙设备)
	...
	(其他尽量不谈了, 应该比较少会涉及驱动编码了)

	目前的tcp/ip 协议簇, 一般都支持:
		* 内核态socket 编码
		* 用户态'AF_PACKET 链路层'封包拆包编码(部分操作系统不支持, 如: android, 需要操作系统内核提供支持)
		* 无系统, 裸奔封装tcp/ip 报文(嵌入式常用, 无系统/微系统设备常用)

	通常的:
		通过linux 内核编码, 得出驱动, 一般是PC周边的设备;
			主要是用linux 内核syscall 封装出posix API/socket API;
		通过Embedded嵌入式编码, 得出驱动, 一般是嵌入式设备;
			主要根据详细的协议内容, 用小芯片进行最原始的协议封装, 得出一个完整的嵌入式设备;

	注意:
		如果以linux 内核.ko模块的方式, 封装socket API, 调试时会比较艰巨(可能需要经常装载, 卸载.ko 模块, 甚至重启系统);
		如果是linux 内核驱动, 没办法避免, 则只能写成.ko模块(而且syscall API 功能比较简陋, gcc 功能比较简陋);
		如果是linux 应用, 尽量在用户层实现.so 封装, 这样调试方便些, 也可以比较容易实现知识产权保密, 还有功能较全的posix API 可用;



常见的其他协议簇(有些已经废弃了):
	AF_CAN       -- CAN总线socket API封装
	AF_BLUETOOTH -- 蓝牙socket API封装
	AF_ROUTE     -- 路由域套接字socket API封装(只支持raw模式[需要root权限])
	AF_PACKET    -- 链路层socketAPI封装(需要自己附上ARP 报文)
	AF_PPPOX     -- 电话线2跳线转RJ45网线socket API封装(model 光猫/电猫)的通信协议簇[很少用]
	AF_RDS       -- 英国广播电台标准socket API封装(广播电台专用)
	...
	等等

由于设备更新变动太快, 通用tcp/ip 协议栈, 链路层以下的支撑, 越来越不可能通用化!!
因此, 链路层以下的, 基本都是直接在<linux/***.h> 中包含, 通用的tcp/ip 协议栈头文件, 基本上都废弃了;

通用层的tcp/ip 头文件, 仅仅保留了对app 应用层的协议支持, 基本上是网络层/传输层以上的应用;
但高层ftp/http/sip 等协议解析, 通用tcp/ip 协议又基本扔掉了, 互联网同样也是因为更新太快, 不可能保留的,

因此, 操作系统仅仅保留了tcp/ip 网络层/传输层的协议定义, 链路层及一下的协议, 全部由linux 取代;
高层的应用协议解析, http/ftp/sip 等, 由网关proxy server 取代;

因此, 目前还在用的[网络相关头文件], 只有3个文件夹是常用的, 其他基本上可以忽略了:
	<netinet/*.h>
	<arpa/*.h>
	<net/*.h>



如果需要根据详细协议进行最原始封装, 
则需要利用计算机芯片+系统, 再根据报文详细内容, 1bit, 1bit地描述;
例如:
	I2c详解(最简单的, 最容易理解)
	can总线(相对容易理解, 详细报文并不是AF_CAN socket, socket 是已封装好的应用层API接口)
	蓝牙(无线电方向, 比较简单的入门协议, 详细报文并不是AF_BLUETOOTH socket, socket 是已封装好的应用层API接口)
	...
ps:
	设备协议的最小数据粒度, 通常是1bit;
	互联网应用协议的最小数据粒度, 通常是1字节(8bit,一个字符);



目前大量的小型嵌入式系统, 如RT-Thread, vxworks等, 大部分都仿造了部分posix API;
主要用来做多线程/多进程的同步&通信, [内存级, 不可丢弃]
也集成了fs 文件系统, [可丢弃(裁剪), 可新增]
也集成了tcp/ip 协议栈, [可丢弃(裁剪), 可新增]
...

如果你要做存储设备, 则需要用到SPRAM(包括SPI&PCIE)/SDRAM, 编写存储设备主控驱动(对接PC,对接Linux内核);
虽然理论上, fs 文件系统与设备主控, 是隔层的, 互不影响, 
但实际上, 也可能会'重建/新建'fs 文件系统, 让存储设备实现存取更高效, 设备寿命更高等;
[不对接PC 的存储设备, 例如嵌入式设备自身新增一块存储芯片, 则直接用SPRAM(包括SPI&PCIE)/SDRAM协议即可, 不需要封装驱动]

如果你要做普通设备, 则需要根据详细的协议, 直接根据协议, 进行编程(嵌入式设备的子设备);
如果你要做对接PC的设备, 则还需要上一步的基础上, 对接Linux内核, 根据syscall封装出应用层API;



新增:
	由于工业总线也更新换代了, 所以, 目前工业总线主要也分: 旧时can 总线 & 新型的'以太网实时增强型工业总线',
	详情请看: ./socket实时工业总线简介
