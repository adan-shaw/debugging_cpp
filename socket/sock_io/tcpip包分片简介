前言:
	请先阅读MTU分析test.c, 知道什么叫MTU!! 这里不详细展开;

MTU 长度参考:
	标准802.2 MTU:       1492字节;
	以太网802.3 MTU:     1500字节;
	internet MTU:       576字节;

这里不讨论最小MTU 是多少, 只谈论: 
	单次发送IP 协议数据, 长度超过MTU, 都需要进行切片, 
	这时候, 就有一个tcpip 数据切片成包(帧)的概念了





* ip 数据被切片, 这个切片 & 切片后重组的算法, 是集成在linux kernel 的, 自动触发的, 
	一般情况下:
		* 用户态程序员, 不需要重写, 只需要利用即可, 
			因为无论是ip 协议, 还是tcp/udp 协议, 都有描述数据长度, 都有计算校验和;
			只要校验和没错, 数据包就安全, 这时候, 你只要在乎自己选择的是udp 报式报文, 还是tcp 流式报文, 再做相应的操作即可;

			ip 报文长度:      ip + udp/tcp 的所有数据的总长(报头+数据)
			ip 校验和:       ip 报头的校验和计算
			udp/tcp 报文长度: udp/tcp 所有数据的总长(报头+数据)
			udp/tcp 校验和:  udp/tcp 所有数据的校验和

			这种情况下, 实际上数据完整性, 数据帧的顺序性, 数据的还原, 是可以得到保证的, 尤其是tcp 协议(udp 没办法保证先后顺序);
			这样一来, 数据的切片和重组, 你就不可能需要自己实现, 
			哪怕是自己写原始套接字, 做底层数据解析, 你都不需要自己实现数据的切片和重组(直接交给kernel 执行就行)

			只要校验和计算正确, 数据就是完整的!! (校验和是否计算正确, wireshark 会告诉你)
			当然tcp 粘包, udp 没办法保证数据顺序, 这些都是后话;

			最后, 你就只需要获取udp/tcp 的报文长度, 就可以校验本次数据io, 是否正确执行; (当然wireshark 校验和都计算失败, 那会是更严重的问题)


		* 内核态程序员:
			如果有需要, 可以调用linux kernel 的syscall, 实现对'数据切片&重组'(意义不大)
			一般情况下, 由于现在用户态也支持AF_PACKET, SOCKET_RAW, 
			因此tcpip 的用户态编码, 内核态编码, 区别不会很大吧;
			(usb, i^2c, can, lin 等, 可能区别就会很大, 但主要也是因为: 这部分芯片太小, 装不起glibc 导致的;
			 这些小芯片, 都是手工自己组装报文发送的, 这点需要注意!!)





总结:
	一般就算是做tcpip 协议的底层解析, 也很少需要自己实现'数据切片&重组', 
	更多的是直接读取协议报头的细节, 进行进一步的网络状态判断, 做进一步的操作;

	如果非要对'数据切片&重组', 内核态程序员, 可以直接调用linux kernel 的syscall, 按步骤实现'数据切片&重组'(意义不大);

	当然udp 协议, 你只需要在用户data 中加插一个变量unsigned short udp_count; 来保证udp 用户数据的顺序即可;
	(tcp 就不需要了)


	因此, tcpip 包切片&重组的问题, 其实可以不用过多关心, 知道有这么一回事即可, 实际应用较少;





