支持socketcan 库的编程:
	如果你可以使用socketcan 库编程, 那么是方便的, 这样意味着你不需要自己手动组装can 报文;
	socketcan 库已经帮你封装好大部分操作, 直接拿来就用的感觉, 是愉快的, 跟posix socket 一样轻松;
	ps:
		socketcan 库使用的是sock_raw 原始套接字编程, 并不需要使用SOCK_PACKET 链路层套接字!!
		一般情况下, MCU 则需要使用SOCK_PACKET 链路层套接字!!



不支持socketcan 库的MCU 编程:
	如果你不可以使用socketcan 库编程, 那么只能像ETH 链路层那样, 自己手动凭装每一帧数据, 比较麻烦, 但也不复杂, 自己看着办;
	(一般情况下, MCU 则需要使用SOCK_PACKET 链路层套接字, 
	 而且rtos 系统一般也会支持socket 套接字编程协议栈, 一般会有对应的实现, 否则更麻烦!! 操作更复杂)

	手摇的办法:
		如果mcu 不支持socket 套接字can 编程, 则需要手摇;
		假设p1, p2 io 口为can 总线所占用的端口, 则有:
			* 根据芯片指令周期, 来判定波特率(机器周期+晶振, 可以推算出指令周期), 根据指令周期, 可以推算出mcu 的波特率;
			* 把数据转换成信号, 一个一个bit 位手摇出去, 最终完成数据收发;

		ps:
			手摇不会自动解决线路冲突问题, 比较麻烦!!
			如果手摇时, 线路正在访问冲突, 则比较麻烦!! 因为这会导致信号混乱, 非常难以判断, 诊断出问题所在;
			当mcu 数量较多的时候, 手摇的压力会很大, 需要自己实现冲突检测(可能需要示波器协助调试);

	最终, 手摇也可以实现can/lin 通信;



无论哪种方式进行can 编程, 都需要经常参考can 协议报文的内容,
如果可以用socketcan 库, 则可以更多的focus 在业务编码上面, 便捷很多;
