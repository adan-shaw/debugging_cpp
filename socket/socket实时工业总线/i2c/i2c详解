i2c用途简介:
	i2c只能做主从模式的通信, i2c没有解决数据冲突的能力, 适合观察者模式, 广播模式;
	只有载波帧听, 没有冲突检测;

	i2c一般用作'realtime-片内'使用,
	i2c也可以用为'realtime-片外'使用, 但电压电流较弱, 如果线路距离过长, 则需要信号放大电路, 进行信号放大;
	(i2c'realtime-片外'使用, I2C总线的最大长度是: 小于200mm～300mm)

	i2c最大带宽: 100-400kbit/s, 最大400kbit/s, 具体看波特率, 看晶振;
	普通8051 单片机, 晶振12M, 机器周期1MHz, 也就是mov 指令周期1Mhz, 
	也就是线路max波特率是1Mbps, 大于400kbit/s, 因此, 基本达不到1Mbps的;





i2c总线的电器特性:
	快速模式I2C总线规范与标准模式相比有以下特征:
		1.最大位速率增加到400kbit/s;
		2.调整了串行数据(SDA)和串行时钟(SCL)信号的时序;
		3.快速模式器件的输入有抑制毛刺的功能, SDA和SCL输入有施密特触发器;
		4.快速模式器件的输出缓冲器对SDA和SCL信号的下降沿有斜率控制功能;
		5.如果快速模式器件的电源电压被关断, SDA和SCL的I/O管脚必须悬空, 不能阻塞总线;
		6.连接到总线的外部上拉器件必须调整以适应快速模式I2C总线更短的最大允许上升时间;
			对于负载最大是200pF的总线, 每条总线的上拉器件可以是一个电阻, 
			对于负载在200pF~400pF之间的总线, 上拉器件可以是一个电流源(最大值3mA)或者是一个开关电阻电路;

		SDA(串行数据线)和SCL(串行时钟线)都是双向I/O线, 接口电路为开漏输出, 需通过上拉电阻接电源VCC;
		当总线空闲时, 两根线都是高电平, 连接总线的外同器件都是CMOS器件, 输出级也是开漏电路, 在总线上消耗的电流很小;
		因此, 总线上扩展的器件数量主要由电容负载来决定, 因为每个器件的总线接口都有一定的等效电容;
		而线路中电容会影响总线传输速度;
		当电容过大时, 有可能造成传输错误;
		所以, 其负载能力为400pF, 因此可以估算出总线允许长度和所接器件数量;
		(简单来说就是: 从芯片太多, 需要用电容补电, 最大容量是400pF)

		电平: 0=[0,+1.5]V, 1=[3,5]V





i2c协议详解:
	#define SCL (P1.0) //时钟线
	#define SDA (P1.1) //数据线

	* 静止状态:
		SCL = 1; SDA = 1; //1 = 高电平

	* 启动信号:
		打破'静止状态', 先拉低SDA, 然后再拉低SCL, 再开始发数据;
		while(1)
			if(SDA == 1 && SCL == 1){
				SDA = 0;
				break;
			};
		SCL = 0;//保留一定的缓冲时间, 在跳出循环后, 才将SCL电平拉低;
		...

	* 结束信号:
		数据发送完毕后, 先拉高SCL, 然后再拉高SDA, 然后就会恢复到'静止状态';
		while(1)
			if(SDA == 0 && SCL == 0){
				SCL = 1;
				break;
			};
		SDA = 1;

	数据帧:
		首帧:
			第0-6 bit = 地址位(最多64个从芯片)
			第7 bit   = 读写模式标志位
			第8 bit   = ack 应答位(目标从机作应答)
		数据帧:
			第0-7 bit = 8bit 数据(发送主机, 发送数据)
			第8 bit   = ack 应答位(目标从机作应答)

	数据帧&应答机制:
		发送完一个数据帧后, 必须等待1bit 应答信号:
			此时SCL = 0; 时钟线依旧为0;
			发送主机将SDA = 1; 拉高SDA, 等待目标从机应答:
				SDA = 1;
				while(1)
					if(SDA == 0)//目标从机已应答
						break;

			目标从机, 应将SDA = 0; 拉低SDA, 回应发送主机;
			SDA = 0;

	最后所有数据发送完毕后, 启动结束信号, 恢复到'静止状态';





//
//c 语言嵌入汇编的demo:
//
//编译: 
//		gcc -c -fno-builtin x86汇编程序\:TinyHelloWorld.c -o x.o
//链接: 
//		ld -static -e nomain -o x.exe x.o
/*
	char * str = "Hello world!\n";

	// 使用x86汇编文打印字符串
	void print(){
		asm("movl $13,%%edx \n\t"
				"movl %0,%%ecx \n\t"
				"movl $0,%%ebx \n\t"
				"movl $4,%%eax \n\t"
				"int $0x80 \n\t"
				::"m"(str):"edx","ecx","ebx");
		return;
	}

	// 使用x86汇编文退出程序
	void exit(){
		asm("movl $42, %ebx \n\t"
				"movl $1, %eax \n\t"
				"int $0x80 \n\t");
		return;
	}

	// x86 程序入口
	void nomain(){
		print();
		exit();
		return;
	}
*/
