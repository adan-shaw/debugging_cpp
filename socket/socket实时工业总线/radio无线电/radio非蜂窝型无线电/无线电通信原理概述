#
# 1.无线电与tcp/ip 包网络传输协议
#
tcp/ip 同步就不说了, 实际上是tcp/ip没有同步通信可言的,
tcp/ip 同步实际通过频繁异步询问来实现, 消耗比较大, 无线电不适合.



tcp/ip 异步通信, 接受数据原则:
	<普通接收模式-前缀32bit校验码> ip + port(服务) + phonenumber(账户) + ... 数据 <普通接收完毕-前缀32bit校验码>
	<紧急接收模式-前缀32bit校验码> ip + port(服务) + phonenumber(账户) + ... 数据 <紧急接收完毕-前缀32bit校验码>

	<普通上传模式-前缀32bit校验码> ip + port(服务) + phonenumber(账户) + ... 数据 <普通上传完毕-前缀32bit校验码>
	<紧急上传模式-前缀32bit校验码> ip + port(服务) + phonenumber(账户) + ... 数据 <紧急上传完毕-前缀32bit校验码>



	ps:
		紧急上传可能只有你在打110 的时候才会有


	无线电server/client, 也有ip 地址, 用来寻址用的.

	无线电数据包, 如何判断是哪个应用的数据?
	无线电server/client 的应用, 根据port 来判断数据由哪一个应用收/发, 跟pc 应用一样.




#
# 2.杂乱描述
#
无线电设备的工作流程:
	收:
		天线->信号滤波,除杂->信号放大电路(如果有)->io芯片->tcp/ip数据报文->
		->sfd_io可读事件->app应用程序->socket读缓冲区(可丢弃,app直接丢包,不读,连缓冲区都不让写)
		->sfd_io读ready事件->app应用程序(可丢弃,读完后app不想要了,丢数据包)
	发:
		app应用程序->数据缓冲区->sfd_io可写事件->socket写缓冲区->
				->(sendfile可直写,不经过socket写缓冲区,但sendfile是一个阻塞操作)->
		->tcp/ip数据报文->io芯片->信号放大电路(如果有)->天线->
		->sfd_io写ready事件(发送完毕,回应一个io事件)

	信号放大电路, 主要是应付:
		当io 芯片的io 引脚只有5V 电压, 
		不足以驱动天线震荡, 产生无线电波的情况下, 就会设计信号放大电路(其实就是运放电路)
		例如:
			普通家用路由器, 手机蜂窝无线电(应该也有放大电路, 放大到12V)
			飞机雷达, 卫星雷达(肯定有放大电路, 电压放大到很高220V/330V)



信道问题:
	一个手机设备, 只接受一个信道; 
	一个塔台, 只选择一个信道进行广播
	塔台下面的手机, 都是跟TCP IP一样的, 不是你的包, 你就丢掉.
	信号必然有: 
		普通流量信号, 电话紧急信号, 两种不同的信号.

	而且手机可能处于待机状态, 因此, 塔台肯定有唤醒信号:
		谁是136*** 机主, 准备接收数据.
		136***收到简短的唤醒信号后, 回复塔台: 收到, 并提高功率, 开始接收数据.
		接受完毕之后, 手机就弹出信息提示/来电提示.

	塔台也可以通过唤醒信号, 知道哪些手机正在占用信道.
	哪些手机正在待机状态.
	那些手机已经脱离塔台信号范围(or 已经进入飞行模式, 关机模式)


异步包网络, 跟有时钟线的real time网络不一样, 侦听都有启动包, 结束包. 
Mac层的吧, 平时监听的待机功耗应付很低, 每一个信道, 一旦受到唤醒信号, 
那样才开始提高接收功率. 那唤醒信号应该也是很简单的 ​​​​ 



无线电产生:
	天线是如何产生无线电的?
	+正极, -负极, 产生振荡电波(消耗大量电能)
	一根天线收, 一根天线发.
	实现全双工, 至少需要2 条天线.



天线产生振荡电波, 如何表示正负?
	天线敲信号, 不是一位一位敲出去的, 
	而是天线+, -极位置交换, 易位, 产生振荡电波, 将数据易位易出去的.
	8051 12M 晶振, 可以有1M 个指令周期, 也就是1Mbps.
	天线敲信号, 性能主要看io 芯片的主频.
	8bit * 1024 = 8192 bit
	那么, 如果用8051 做io 芯片, 每秒可以敲1Mbps/8192bit=128个数据包(全速)



天线只是一个增益装置:
	天线只是一个增益装置, 天线越大, 发送的信号体积越大, 消耗的电能越多.
	但是天线不可能提高信号的接收/发送频率!!
	提高信号接收/发送频率的, 只有io 芯片.

	至于, 如果io 芯片的io 引脚5V 电压, 不足以驱动大型天线, 产生振荡电波, 
	则需要设计运放电路, 放大io 芯片引脚的信号.



波特率:
	波特率, 是指: 数字信号电波, 波峰与波谷变换的速度, 与传输介质无关.
	有线传输, 数字信号波形是锯齿状的, _-_-_-_-_---_
	无线电传输, 数字信号波形是三角函数波形的.
	都有波特率!!
	把波特率提高的话, 数字信号的传输速度可以拉上去.
	无线电也有类似的概念, 5G AC WIFI, 5G 蜂窝无线电, 都是提高信道频率实现的.



示波器的作用:
​	示波器其实就是检测数字信号的, 类似于抓包, 是嵌入式开发过程中的抓包器. 
	有线信号, 一般按位传输的real time信号都是锯齿状的. 
	无线电信号都是波形的.

	包网络TCP/IP, 直接用抓包软件分析即可



无线电常用的芯片:
	DSP, FPGA 做IO 芯片, 主要做信号过滤, IO 控制.
	FPGA 一般是高端无线电设备才会有, 性能好, 算法还能动态修改.

	由于无线电必须用tcp/ip 协议进行通信, 必然少不了linux 内核, 所以:
		arm/mips 做linux 系统主控;



无线电频射信号的识别:
	低频电波, 波长大, 传输距离长, 传输损耗少, 消耗电量相对少.
	高频电波, 波长小, 传输距离短, 传输损耗大, 消耗电量相对大.

	卫星/雷达传输, 也逃脱不了这个规律, 只是:
		卫星/雷达为了增加可靠性, 会最大限度, 最大功率去发送无线电波, 保证传输距离. 



要做无线电信号解析很难:
	做天线最难, 要分析无线电如何识别, 传播时损耗, 无线电波形, 频率, 电能强度等等,
	做天线, 相当于造火箭中的, 空气动力学, 最高级.
	还要根据国际电信联盟制定的通信标准, 来生产无线电设备.
	否则你生产出来的设备, 其它国家不能用.
	(理论类人才)

	做io 芯片, 次级, 即做无线电驱动的.(工程类人才)
	在无线电天线理论支撑下, 利用dsp, fpga 等io 芯片, 设计无线电linux 驱动.
	将收发到的数据, 按照linux 驱动 + tcp/ip syscall 层面进行封装,
	实际就是以无线电的形式, 对tcp/ip socket API 进行重建.
	重新实现一套无线电版本的tcp/ip socket API.

	做软件模块的, 次次级, 直接买无线电模块回来, 
	在linux 驱动上安装无线电驱动,
	做应用开发,
	写tcp/ip socket API 套接字开发, 
	只不过对socket 套接字数据包, 把控比较严格而已.



包网络tcp/ip 必然带数据缓冲区的说法, 一定成立:
	tcp/ip 无论是udp, 还是tcp, 都具有一个接收缓冲区, 发送缓冲区的概念.
	只要创建socket, 就有socket 发送/接收缓冲区!!
	还有socket API 去控制缓冲区的大小.
	其物理实现, 也是有道理的:
		由于包网络tcp/ip 并不是realtime 的, 
		所以可能出现数据丢失的情况,
		设置缓冲区也是为了保证, 在远距离传输时, 
		如果出现数据丢失, 也可以舍弃一帧数据, 进行重发.

	realtime 实时传输数据, 由于其物理结构是直接连线, 电流直达且不中断的.
	所以基本上不可能出现数据丢失的情况.



