#
# 1.checksum()函数简介:
#
在C语言中, 'csum()校验和'函数并不是标准库的一部分, 
因此没有特定的头文件包含'csum()校验和', 这个函数通常是由程序员根据需要自行实现或通过使用第三方库来实现的; 
要实现一个'csum()校验和'函数, 你需要根据自己的需求和数据格式编写相应的代码;

TCP/IP 的checksum()函数通常是由操作系统或网络库提供的, 而不是由应用程序开发者自己实现的(自己实现, 主要是cpu 架构和效率问题, 还是用公版的比较好); 
不同的操作系统和网络库可能有不同的实现方式;

但如果实在没办法, 你只能自己实现校验和的API 了;

ps:
	由于tcp/ip 协议栈填充时, checksum 一般需要先初始化为0, 再进行checksum() 计算,
	因此, tcp/ip 协议栈填充时, 一般都应该将checksum 放在最后进行填充;
	(这是一个技巧, 填充时, 需要看看wireshark 是否报错, 
	 如果wireshark 报错说checksum 校验错误, 也是有问题的报文, 需要一一校正的; 其实校验报文的工作, 比较麻烦复杂, 需要耐性)





常见的TCP/IP 的checksum()函数:
	* ip_fast_csum():
			Linux 内核网络栈中用于计算IP'csum()校验和'的一个快速函数;
		头文件:
			<linux/skbuff.h>
		注意:
			ip_fast_csum() 是内核态的, 用户空间的应用程序是不可见的;
			这个函数是在内核态下用于处理网络数据包等底层任务的; 

	* inet_cksum():
			用于计算 IP、TCP、UDP 等协议的'csum()校验和'; 这个函数是 BSD 系统中的一部分, 并且在许多 Unix-like 系统中都可用;
		头文件(debian linux 找不到这个函数):
			<netinet/in.h>
			<netinet/ip_icmp.h>
		注意:
			inet_cksum() 是用户空间的'csum()校验和'函数, 内核态程序不可用;

	* csum_tcpudp_magic() / csum_ipv6_magic():
			用于计算 IP、TCP、UDP 等协议的'csum()校验和';
		头文件(debian linux 找不到这个函数):
			<linux/in.h>
		注意:
			csum_tcpudp_magic() / csum_ipv6_magic() 是内核态API, 用户态不可用;

	ps:
		libpcap 是一个用于网络流量捕获的库, 它本身并不直接提供TCP/IP 'csum()校验和';

		//unsigned short csum(const unsigned short *ptr, int nbytes);//不知道为什么这个函数已被删除了, 这个函数也是内核态的?
		extern __wsum ip_fast_csum(const void *iph, unsigned int ihl);



'csum()校验和'函数的用法:
	这类函数的统一用法: 接受一个指向数据缓冲区的指针和数据长度, 并返回计算得到checksum 值(unsigned short); 

checksum()函数[16 位'csum()校验和'计算]:
	IP/ICMP/IGMP/TCP/UDP等协议的'csum()校验和'算法都是相同的, 
	采用的都是将数据流视为16位整数流进行重复叠加计算; 

	* 为了计算检验和, (必须)首先把检验和字段置为0;(因为计算字段, 也是数据的一部分, 所以必须先置0)
	* IP/ICMP/IGMP/TCP/UDP等协议, 都有一个unsigned short 数据位, 所以, 都需要算一次检验和;

	checksum 简单计算方法:
		ip checksum = csum(ip头) + csum(ip负载)
		icmp checksum = csum(icmp头) -- icmp 一般没有报body, 所以只算报头
		igmp checksum = csum(igmp头) -- igmp 一般没有报body, 所以只算报头
		tcp checksum = csum(tcp头) + csum(tcp负载)
		udp checksum = csum(udp头) + csum(udp负载)

	checksum 详细结算方法:
		然后, 对有效数据范围内中每个16位进行二进制反码求和, 结果存在检验和字段中, 如果数据长度为奇数则补一字节0; 
		当收到数据后, 同样对有效数据范围中每个16位数进行二进制反码的求和; 
		由于接收方在计算过程中包含了发送方存在首部中的检验和, 因此:
			如果首部在传输过程中没有发生任何差错, 那么接收方计算的结果应该为全0或全1(具体看实现了,本质一样); 
			如果结果不是全0或全1, 那么表示数据错误; 





#
# 2.checksum()函数的效率需求:
#
由于每一帧网络数据, 都会算'csum()校验和', 
因此'csum()校验和'算法效率, 服用率非常高, 是比较重要的, 
cpu 可能会对齐进行硬件加速优化, 因此普通c 语言算checksum()函数, 可能都不适用了, 得用汇编硬件加速;

当然, 如果用汇编语言实现计算速度会快得多, 对于不同的CPU体系, 需要各自对应编写不同的汇编, 在Linux内核源代码中有各种CPU体系的IP'csum()校验和'计算源代码; 

ps:
	计算checksum 是一个比较繁琐的工作: 
		发送端, 需要计算checksum, 来保证数据的完整性, 安全性;
		接收端, 需要重新计算checksum, 以防止数据被篡改/数据不完整/数据损坏;
	因此, 每一帧数据的收发双方, 都要至少算一次checksum, 或者更多: ip 算一次, tcp 算一次, 哈哈;
	因此checksum 的计算效率, 也蛮重要的, 对于网络程序来说;





#
# 3.checksum 计算方法总结
#
TCP/IP 协议族中的 TCP、UDP、ICMP、IGMP 和 IP 协议, 都使用了 checksum(校验和), 来检测数据包在传输过程中是否发生了错误;
Checksum 的计算是基于数据包中的每个字节, 并使用一种特定的算法来生成一个 16 位的值;

接收方会重新计算 checksum, 并与发送方提供的值进行比较, 以确定数据包是否在传输过程中被损坏;
(因此checksum 算法的使用量比较巨大, 每一帧数据都要算一次, 一般来说, 都有cpu 硬件加速来计算checksum)



以下是 TCP/IP 协议族中几个主要协议的 checksum 计算方法:

	IP Checksum:
		IP 头部包含一个 16 位的 checksum 字段;
		Checksum 是通过对 IP 头部中的每个 16 位字的二进制反码求和(不包括 checksum 字段本身)来计算的;
		如果求和的结果是一个奇数, 则将其转换为 16 位的二进制反码;
		最终得到的 16 位值就是 IP头部的 checksum;

	TCP Checksum:
		TCP checksum 的计算与 IP checksum 类似, 但范围包括 TCP 头部和数据部分;
		TCP checksum 也是通过对每个 16 位字的二进制反码求和来计算的, 但求和过程中包括 TCP 头部和数据部分;
		和 IP checksum 一样, 如果求和结果是一个奇数, 则将其转换为 16 位的二进制反码;

	UDP Checksum:
		UDP checksum 的计算与 TCP 和 IP checksum 类似, 但范围仅限于 UDP 头部和数据部分;
		UDP checksum 也是通过对每个 16 位字的二进制反码求和来计算的, 但求和过程中只包括 UDP 头部和数据部分;
		和 TCP/IP checksum 一样, 如果求和结果是一个奇数, 则将其转换为 16 位的二进制反码;

	ICMP Checksum:
		ICMP checksum 的计算与 IP checksum 类似, 但范围包括 ICMP 头部和数据部分;
		ICMP checksum 也是通过对每个 16 位字的二进制反码求和来计算的, 但求和过程中包括 ICMP 头部和数据部分;
		和 IP/TCP/UDP checksum 一样, 如果求和结果是一个奇数, 则将其转换为 16 位的二进制反码;

	IGMP Checksum:
		IGMP checksum 的计算与 ICMP checksum 类似, 因为 IGMP 是 ICMP 的一个子集;
		IGMP checksum 的计算方法同样是通过对每个 16 位字的二进制反码求和来完成的, 但范围包括 IGMP 头部和数据部分;



如果求和结果是一个奇数, 则将其转换为 16 位的二进制反码;
请注意, 这些 checksum 算法都是基于二进制反码的, 这意味着在计算过程中需要对每个 16 位字进行二进制反码操作, 并在最终求和结果为奇数时进行额外的二进制反码转换;
这种算法可以有效地检测出数据包在传输过程中发生的单个比特错误, 但可能无法检测到某些类型的错误, 如两个或更多比特同时发生错误的情况;


