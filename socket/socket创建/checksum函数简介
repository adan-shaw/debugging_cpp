#
# 1.checksum()函数简介:
#
在C语言中, 'csum()校验和'函数并不是标准库的一部分, 
因此没有特定的头文件包含'csum()校验和', 这个函数通常是由程序员根据需要自行实现或通过使用第三方库来实现的; 
要实现一个'csum()校验和'函数, 你需要根据自己的需求和数据格式编写相应的代码;

TCP/IP 的checksum()函数通常是由操作系统或网络库提供的, 而不是由应用程序开发者自己实现的(自己实现, 主要是cpu 架构和效率问题, 还是用公版的比较好); 
不同的操作系统和网络库可能有不同的实现方式;

但如果实在没办法, 你只能自己实现校验和的API 了;



常见的TCP/IP 的checksum()函数:
	* ip_fast_csum():
			Linux 内核网络栈中用于计算IP'csum()校验和'的一个快速函数;
		头文件:
			<linux/skbuff.h>
		注意:
			ip_fast_csum() 是内核态的, 用户空间的应用程序是不可见的;
			这个函数是在内核态下用于处理网络数据包等底层任务的; 

	* inet_cksum():
			用于计算 IP、TCP、UDP 等协议的'csum()校验和'; 这个函数是 BSD 系统中的一部分, 并且在许多 Unix-like 系统中都可用;
		头文件(debian linux 找不到这个函数):
			<netinet/in.h>
			<netinet/ip_icmp.h>
		注意:
			inet_cksum() 是用户空间的'csum()校验和'函数, 内核态程序不可用;

	* csum_tcpudp_magic() / csum_ipv6_magic():
			用于计算 IP、TCP、UDP 等协议的'csum()校验和';
		头文件(debian linux 找不到这个函数):
			<linux/in.h>
		注意:
			csum_tcpudp_magic() / csum_ipv6_magic() 是内核态API, 用户态不可用;

	ps:
		libpcap 是一个用于网络流量捕获的库, 它本身并不直接提供TCP/IP 'csum()校验和';

		//unsigned short csum(const unsigned short *ptr, int nbytes);//不知道为什么这个函数已被删除了, 这个函数也是内核态的?
		extern __wsum ip_fast_csum(const void *iph, unsigned int ihl);



'csum()校验和'函数的用法:
	这类函数的统一用法: 接受一个指向数据缓冲区的指针和数据长度, 并返回计算得到checksum 值(unsigned short); 

checksum()函数[16 位'csum()校验和'计算]:
	IP/ICMP/IGMP/TCP/UDP等协议的'csum()校验和'算法都是相同的, 
	采用的都是将数据流视为16位整数流进行重复叠加计算; 

	* 为了计算检验和, (必须)首先把检验和字段置为0;(因为计算字段, 也是数据的一部分, 所以必须先置0)
	* IP/ICMP/IGMP/TCP/UDP等协议, 都有一个unsigned short 数据位, 所以, 都需要算一次检验和;

	checksum 简单计算方法:
		ip checksum = csum(ip头) + csum(ip负载)
		icmp checksum = csum(icmp头) -- icmp 一般没有报body, 所以只算报头
		igmp checksum = csum(igmp头) -- igmp 一般没有报body, 所以只算报头
		tcp checksum = csum(tcp头) + csum(tcp负载)
		udp checksum = csum(udp头) + csum(udp负载)

	checksum 详细结算方法:
		然后, 对有效数据范围内中每个16位进行二进制反码求和, 结果存在检验和字段中, 如果数据长度为奇数则补一字节0; 
		当收到数据后, 同样对有效数据范围中每个16位数进行二进制反码的求和; 
		由于接收方在计算过程中包含了发送方存在首部中的检验和, 因此:
			如果首部在传输过程中没有发生任何差错, 那么接收方计算的结果应该为全0或全1(具体看实现了,本质一样); 
			如果结果不是全0或全1, 那么表示数据错误; 





#
# 2.checksum()函数的效率需求:
#
由于每一帧网络数据, 都会算'csum()校验和', 
因此'csum()校验和'算法效率, 服用率非常高, 是比较重要的, 
cpu 可能会对齐进行硬件加速优化, 因此普通c 语言算checksum()函数, 可能都不适用了, 得用汇编硬件加速;

当然, 如果用汇编语言实现计算速度会快得多, 对于不同的CPU体系, 需要各自对应编写不同的汇编, 在Linux内核源代码中有各种CPU体系的IP'csum()校验和'计算源代码; 





#
# 3.其他
#

发送校验 (这些宏的定义, 待定)
#define CHECKSUM_NONE 0               // 需要由传输层自己计算'csum()校验和'
#define CHECKSUM_HW 1                 // 由硬件计算报头和首部的'csum()校验和'
#define CHECKSUM_UNNECESSARY 2        // 表示不需要校验, 或者已经成功校验了
#define CHECKSUM_PARTIAL CHECKSUM_HW
#define CHECKSUM_COMPLETE CHECKSUM_HW

接收校验
// 检查'csum()校验和'
if (skb->ip_summed != CHECKSUM_UNNECESSARY && tcp_v4_checksum_init(skb))
	goto bad_packet;




