*1.sctp 简介:
	sctp 是新一代tcp 协议拓展, 有很多新特性: SCTP四路握手及抵抗SYN Flooding攻击的原理

		一个SCTP关联定义为: 
			[主机A的一组IP地址]+[主机A的端口]+ [主机B的一组IP地址]+[主机B的端口]. 
			因此, 每一端对应组中的任何一个IP地址都可作为相应的源/目的地址来标示本次关联, 通过四路握手, 两端SCTP主机交换通信状态. 

		SYN Flooding利用了TCP/IP的固有漏洞,面向连接的TCP三次握手是SYN Flooding存在的基础. 

		SYN Flooding攻击的原理是: 
			恶意的攻击者大量向服务器发送SYN报文, 
			服务器在发出SYN+ACK应答报文后无法收到客户端的ACK报文(第三次握手无法完成), 
			服务器端将为维护一个非常大的半连接列表而消耗非常多的CPU时间和内存资源, 
			还要不断对这个列表中的IP进行SYN+ACK的重试. 
			服务器端将忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求, 
			此时从正常客户的角度看来, 服务器失去响应. 

	而在一次SCTP四路握手中, INIT(Initiation, 开始)消息的接收端不必保存任何状态信息或者分配任何资源, 这样就可防范SYN Flooding等DoS攻击. 
	它在发送INIT-ACK消息时, 采用了一种机制"状态Cookie", 该Cookie具有发送端要建立自己状态所需的全部信息. 


	SCTP产生一个状态Cookie的过程如下: 
	1．使用收到的INIT和发出的INIT-ACK块中的信息创建一个关联的TCB(Transmission Control Block, 传输控制块).
	2．在TCB中, 将当前日期设为创建日期, 将协议参数"有效Cookie时间"设为生存期间. 
	3．根据TCB, 收集重建TCB所需的最小信息子集, 将该子集和密钥产生一个MAC(Message Authentication Code, 消息验证码).
	4．结合上述最小信息子集和MAC产生状态Cookie. 
	5．在发送完INIT ACK(包含状态Cookie参数)后, 发送方必须删除TCB以及任何与新关联有关的本地资源.

	INIT和INIT-ACK都必须包含建立初始状态所需的参数: 
		一组IP地址, 保证可靠传输的初始TSN, 每个被接收的SCTP包中必须含有的初始标签, 每一端请求发出的流数目和每一端能支持接收的流数目. 

	交换完这些消息之后, INIT的发送端以COOKIE-ECHO消息的方式发送回状态Cookie. 
	接收端根据所接收到的COOKIE-ECHO中的状态Cookie, 完整地重建自己的状态, 并回送COOKIE-ACK来确认关联已建立. 
	COOKIE-ECHO和COOKIE-ACK都可将用户数据消息绑定到各自的包中. 

	由此可见, 采用以上这种方式, 即使接收再多的INIT消息, 接收端也没有任何资源的消耗: 
		它既不分配任何系统资源, 也不保存此次新关联的状态, 
		它只是把相应重建状态所用的状态Cookie作为参数, 包含在每一个回送的INIT-ACK消息中, 
		最后该状态Cookie会被COOKIE-ECHO消息发送回来. 





*2.sctp 后发弱势:
	SCTP不太为人所知, 也没有大量使用/部署, 因为: 

	广泛存在: 未广泛集成到TCP/IP协议栈中(2013: 在最新的MacOSX和Windows中, 本机仍未实现)
			 库: 在易于使用的语言中很少有高级绑定(免责声明: SCTP对Python的简单堆栈支持)
			NAT: 不能很好地穿越NAT/一点也不(少于1%的互联网家庭&企业路由器在SCTP上做NAT).
		流行度: 没有普通的公共应用程序使用它.
	编程范式: 它改变了一点->它仍然是一个套接字, 
					 但是你可以将许多主机连接到许多主机(多主机), 数据报是有序和可靠的, ERC.
		复杂性: SCTP堆栈的实现非常复杂(由于以上原因)
		 竞争: 多路径tcp即将到来, 应该解决多归属需求/功能,
					 因此人们在可能的情况下不执行sctp, 等待mtcp.
		生态位: 需要SCTP填充是非常特殊的(有序可靠的数据报, 多流), 并且不需要很多应用程序.
		安全性: SCTP逃避安全控制(一些防火墙, 大多数IDSes, 所有DLP, 除了CentOS/Redhat/Fedora...)以外, 没有出现在netstat上.
	审计能力: 世界上有3家公司定期对SCTP安全性进行审计(免责声明: 我在其中一家公司工作)
	学习曲线: 没有多少工具链可以玩SCTP(检查优秀的), 用sctp: 它与Netcat或使用Socat很好地结合在一起)
		 下盖: 主要用于电信领域, 每次发送短信、在手机上上网或打电话时,
					 通常都会触发流经SCTP的消息(SIGTRAN/SS7与GSM/UMTS, Diverage与LTE/IMS/RCS, S1AP/X2AP与LTE).
					 所以你确实经常使用它, 但你永远不知道.


	例如:
		P1.
			直接映射在IPv 4上的SCTP需要在NAT网关中提供支持, 
			因为NAT网关从来没有被广泛部署过, 没有它, 典型的NAT网关一次只能允许每个公共地址中的一个私有主机使用SCTP. 

		P2.
			在UDP/IPv 4上映射的SCTP允许每个公共地址有更多的私有主机, 
			但众所周知, IPv 4/NAT网关中的UDP映射很难建立和维护, 
			因为UDP是一种无连接的传输, 没有任何NAT跟踪的显式状态. 

	直接映射到IPv6上的SCTP需要...
	嗯...
	IPv6. 您试过部署IPv6吗? (ipv6 也是很少人用的)
	如果是, 您是否尝试购买IPv6防火墙? 它支持SCTP吗? 负载平衡器怎么样? SSL加速器?

	最后, 很多互联网都被限制在通过tcp端口80和端口443可以适应的范围内, 
	因此任何类型的sctp都会在那里丢失. 
	因此, 您可以看到类似于MPTCPIETF工作组. 





3.SCTP 的优势:
	SCTP需要在应用程序中进行更多的设计才能得到最佳的利用. 
	有比TCP更多的选项, 类似套接字的API出现得很晚, 而且还很年轻. 
	然而, 我认为大多数花时间去理解它的人(并且知道TCP的缺点)都很欣赏它. 
	它是一个设计良好的协议, 它建立在我们对TCP和UDP的30年知识的基础上. 

	需要思考的方面之一是溪流. 
	流提供(通常, 我认为您可以关闭它)在它们内部的订单保证(很像TCP连接), 
	但每个SCTP连接可以有多个流. 
	如果您的应用程序的数据可以通过多个流发送, 
	那么您可以避免因一个错误的数据包而导致接收方饥饿的线路阻塞. 
	实际上, 不同的对话可以在相同的联系中进行, 而不会相互影响. 

	另一个有用的补充是多归属支持, 一个连接可以跨越两端的多个接口, 并处理故障. 
	您可以在TCP中模拟这一点, 但在应用层. 

	正确的链接心跳(这是任何应用程序使用TCP实现非瞬态连接的第一件事)是免费的. 

	我个人对SCTP的总结是, 如果有大量的应用程序支持, 
	它不会做任何您不能做的事情(在TCP或UDP中). 它提供的是不必自己实现代码的能力. 

	FYI, SCTP被规定为直径(cf半径Next gen)的支持. 见rfc 3588






*4.SCTP 的实际部署
	我们已经在几个应用程序中部署了SCTP, 
	并且在各种家庭路由器中遇到了SCTP支持方面的重大问题. 
	他们只是没有正确地处理SCTP. 
	我认为这主要是一个性能问题(SCTP协议规范要求重新计算整个数据包的校验和, 而不仅仅是头). 

	像许多其他有希望的协议一样, SCTP在D-link和NetGear修复他们破碎的NAT盒之前, 已经死在水里了. 





*5.SCTP 电信领域
	事实上, SCTP主要用于电信领域. 
	传统上, 电信交换机使用SS7(七号信令系统)将电信网络中的不同实体互连. 
	例如, 电信提供商的用户数据库(HLR), 通过交换机(MSC), 用户也被连接(MSC). 

	电信领域正朝着更高的速度和更可达的环境发展. 
	其中一个改变是用一些更优雅、快速和灵活的基于IP的协议来取代SS7协议. 

	电信领域非常保守. SS7网络已经在这里使用了几十年. 
	它是一个非常可靠和封闭的网络. 这意味着普通用户无法访问它. 

	相比之下, IP网络是开放的, 不可靠, 如果它不能处理SS7所处理的负载, 电信就不会转换到它. 
	这就是发展SCTP的原因. 它试图:

	模仿几十年来积累起来的SS7网络的所有优势. 
	要在速度、安全性和冗余性方面比tcp更好地创建面向连接的协议. 

	Linux的最新版本已经有SCTP支持. 




