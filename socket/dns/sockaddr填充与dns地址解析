//sockaddr地址填充与dns地址解析的区别:
/*
	* sockaddr 填充ip 地址信息

	* dns 地址解析, 需要dns server 对url 网站域名进行解析, 得到字符串ip 地址;
		(互联网的server, 端口一般是80/443, 这些网络服务器的端口, 是固定模式的);
		然后根据字符串ip 地址, 再一次填充sockaddr, 就可以使用c/c++ 链接互联网服务器了;
*/



//sockaddr地址填充与dns地址解析汇总
/*
	1.概述:
		本文讲述的就是socket 地址解析, socket 地址解析分为:
		*1.'unix地址'解析:
			依赖struct sockaddr_in通用地址描述体(unix socket 无需端口), 自己填充struct sockaddr_in

		*2.'inet地址+端口'解析
			依赖struct sockaddr_in通用地址描述体, 自己填充struct sockaddr_in

		*3.'服务端口'解析
			依赖'本地文件/etc/services'解析
			为了安全, '服务器名和端口号'由<客户端>主机自己持有并解析, 防止端口欺骗?
			况且一般<服务名-端口号-协议类型>是固定的,
			如果找不到<服务名-端口号-协议类型>关闭, 则向上级dns 服务器询问'dns server地址信息'

		*4.'dns server地址'解析
			依赖dns 服务器, 由服务器返回server[ip + port]



	2.unix 地址解析(太简单了, passed)
		因为unix socket 本身只在本机通信,
		所以unix socket 通信地址, 只是一个'共享的文件路径', 一切皆文件, 
		这个'共享的文件路径'会绑定一个ftok()[key_t], 内核通过找到这个key_t, 让unix socket 之间进行通信.

		由于socket本身也是文件, 所以两个文件之间通信, 只要有key_t做凭证, 内核很容易就可以实现数据转发.

		并且, unix socket 仍然支持'报式/流式'数据传输校验方式, 你可以创建'报式unix socket/流式unix socket'.

		一般用也是socketpair(), 直接创建一对已经绑定在一起的unix socket, 省得做bind()&&listen() and connect() 步骤.



	3.'服务端口'解析文件--> /etc/services 修改shell demo:
		格式:   服务名 端口 协议  # 说明文字
		echo   "adan  9213/tcp # adan service with tcp" >> /etc/services



	4.dns c 编码API简介:
		posix dns:(posix dns用来替代gethostbyname的新一代dns查询工具)
			getpeername+getsockname
			getaddrinfo() 根据输入字符串找到主机
			getnameinfo() 根据struct sockaddr * or socket fd 找到主机
			getpeername() 获取对端socket 的地址信息, 输入指针引用返回: 一个struct sockaddr *addr
			getsockname() 获取自身socket 的地址信息, 输入指针引用返回: 一个struct sockaddr *addr

		old dns(旧式dns 解析API):
			getnetbyname() 主要用来获取网络配置, 网卡信息
			getpostbyname() 主要用来读取<当前主机>目前已经记录<服务名>和<对应的端口号>
			getprotobyname() 主要用来读取主机支持的网络协议: ipv4,ipv6,路由协议, 等
*/


