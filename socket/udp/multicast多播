//1.多播的实现:
/*
	*1, 多播IP 地址到以太网地址的转换:
			多播的'以太网地址'首字节, 必须是01;
			多播的'以太网地址'高位, 一般为01:00:5e;(IANA 多播'以太网地址')
			多播的'以太网地址'低位, 由'多播IP 地址'的低23 bit 直接'复制粘帖'.
			'多播IP 地址'高5 bit 通常被忽略, 直接填0, 或者填随机值.

	*2. 局域网内多播:
			不需要路由支持, 性能最出色, 局域网内不需要跨网, 就不需要IGMP.

	*3. 多子网多播:
			需要路由器支持, 发送IGMP 查询报告, IGMP回复报告;
*/



//2.多播的优点:
/*
	* 单播发送'群组数据', 需要占用信道, 
		如果逐个逐个用户轮询单播, 逐份逐份数据发送, 缺点较多:
			* 占用带宽多
			* 占用带宽时间长
			* 流量大
			* 效率低

	* 广播发送'群组数据', 占用信道只需一次, 局域网内所有用户都可以收到, 每份数据也只发一次;
		但由于没有监管, 每个用户都能收到'广播数据', 都会对'广播数据'进行处理, 消耗'无所谓用户'的处理时间.
		而且广播数据不能在广域网中传输, 只能在单一局域网内传输(二层局域网可能都不行, 除非你改路由器的配置)

	* 多播发送'群组数据', 继承了广播, 节省带宽, 流量的优点,
		同时由于有监管, '无所谓用户'可以在MAC 地址层, 摆脱不属于自己的多播包, 节省时间.
		ps: 
			广播MAC 地址为: 全FF, 
			多播MAC 地址为: 首字节为01, 高位一般为01:00:5e, 低位根据组号来定;
		而且只要路由器支持, 多播一般可以跨网络(广播包则一般被路由器屏蔽, 实用性不高)
		多播对'收听用户'的控制更精准, 广播则需要用3 种广播地址来控制划分;
*/



//3.多播的缺点:
/*
	多播与单播相比, 没有纠错机制, 
	当发生错误的时候难以弥补, 但可以在应用层逻辑, 来实现此种纠错功能.
	(多播的网络支持存在缺陷, 需要路由器及网络协议栈的支持, 多播一般应用在网上视频、网上会议等)
*/



//4.TCP 轮询单播的作用(互联网应用, 也很适合):
/*
	由于多播始终是基于UDP 协议, 面对较为准确的数据传递是, 需要自己手动实现数据安全传输;
	(多播数据传输, 实际安全性不高)
	在数据量不大的情况下, 直接使用TCP 轮询单播, 也是一种不错的选择;

	一般互联网-异步服务器, 50ms-150ms延迟都是可以接受的, 200ms以上开始不行了;
	做工业偏实时服务器, 或者做多媒体重数据流服务器, 一般会用udp'组播/广播';
*/



//5.实践问题:
/*
	* 只要向224.0.0.x 这个多播地址发送数据, 那么多播组内的监听host 都能收到多播数据,
		多播发送者甚至不需要加入多播组?
		证明:
			多播组的目的, 只是为了接收数据时, 分发出多份数据.
			至于数据输入(谁发送多播数据), 不是多播组内的用户, 甚至是跨网络用户, 都可以向某个多播组发送多播数据(不需要预先加入多播组);
		因此, bind() 绑定 + 加入多播组, 只为了接收多播数据而已;
		(这样一来, 多播数据发送安全, 很难保证)

	* 一个多播ip, 只能有一个多播组(即一个D 类多播ip, 只能绑定一个多播组);
*/



//6.多播地址简介:
/*
	多播的地址是特定的, 一般是D类地址用于多播, 
	即224.0.0.0至239.255.255.255之间的IP地址, 被划分为局部连接多播地址、预留多播地址和管理权限多播地址, 一共分3类:

	* 局部多播地址:    224.0.0.0～224.0.0.255之间
		这是为路由协议和其他用途保留的地址, 路由器并不转发属于此范围的IP包.

	* 预留多播地址:    224.0.1.0～238.255.255.255之间
		可用于全球范围(如Internet)或网络协议.

	* 管理权限多播地址: 239.0.0.0～239.255.255.255之间
		可供组织内部使用, 类似于私有IP地址,不能用于Internet,可限制多播范围.

	ps:
		多播地址很重要, 不是多播域的IP地址不能用来做多播;
		 加入多播组时, 如果多播地址不是'多播地址段内的ip', setsocketopt()会出错(参数错误的类型, 说明内核会检索多播地址的正确性)
*/



//7.多播的编程
/*
	多播的程序设计使用setsockopt()/getsockopt()函数来实现, 多播的选项是IP层的, 其选项值和含义如下:
		IP_MULTICAST_TTL			设置多播组数据的TTL值
		IP_ADD_MEMBERSHIP			在指定接口上加入多播组
		IP_DROP_MEMBERSHIP		退出多播组
		IP_MULTICAST_IF				获取默认接口或设置接口
		IP_MULTICAST_LOOP			禁止多播数据回送


	IP_MULTICAST_TTL:				允许设置超时TTL, 范围为0～255之间的任何值;


	IP_MULTICAST_IF:				用于设置多播的默认网络接口ip, 会从给定的网络接口ip发送, 其他网络接口ip会忽略此多播数据. 例如:
		struct in_addr addr;
		//addr 是你指定的多播接收ip, 使用INADDR_ANY, 则使用网卡接口默认ip 接收多播数据
		setsockopt(sfd,IPPROTO_IP,IP_MULTICAST_IF,&addr,sizeof(struct in_addr));


	IP_ADD_MEMBERSHIP:			用于加入一个多播组. 例如:
		struct ip_mreq mreq;
		setsockopt(sfd,IPPROTO_IP,IP_ADD_MEMBERSHIP,&mreq,sizeof(struct ip_mreq));

		* 每一次IP_ADD_MEMBERSHIP, 只能加入一个ip 到多播组中;
			(不能批量添加ip 到多播组, 只能分次多次把所有ip 全部加入到指定的多播组);
		* 一个ip 可以加入多个多播组, 接收多个多播组的数据;

		struct ip_mreq{
			struct in_addr imn_multiaddr; //指定多播组的IP地址(必须是224.0.0.0 网域)
			struct in_addr imr_interface; //指定接收多播数据的host ip(值为INADDR_ANY时, 选择网卡的默认ip 加入该多播组, 做接收ip)
		}


	IP_DROP_MEMBERSHIP:			用于从一个多播组中退出. 例如:
		struct ip_mreq mreq;
		setsockopt(sfd,IPPROTP_IP,IP_DROP_MEMBERSHIP,&mreq,sizeof(struct ip_mreq));


	IP_MULTICAST_LOOP:			用于控制多播数据是否回送到本地的lo 回环接口.
		默认情况下, 当本机发送多播数据到某个网卡接口ip时, 在IP层, 数据会回送到本地的回环接口.
		int tmp = 0;//0禁止回送, 1允许回送(一般都禁止回送, 提高性能)
		setsockopt(sfd,IPPROTO_IP,IP_MULTICAST_IF,&tmp,sizeof(int));
*/



