NATS分布式MQ消息队列系统:
	这种系统, 其实就是MQ类的基础应用, message queue;
	跟IBM-MQ, ActiveMQ 类似, 只不过是Go 语言实现的而已;

message queue服务器产品简介:
	ActiveMQ   (Java编写, 支持订阅模式)
	Jafka/Kafka(Java编写, 同样是apache的项目, 没有大哥active MQ好, 支持订阅模式)
	KafKa      (Scala编写, 但Scala 类似于java, 支持订阅模式)
	RabbitMq   (Erlang编写, 支持订阅模式)
	Nats       (之前是Ruby编写, 现已修改为Go)
	Redis      (C语言编写)
	Kestrel    (Scala编写不常用, 但Scala 类似于java)
	NSQ        (Go语言编写)
	ZeroMQ     (c++语言编写)
	IBM MQ     (c++语言编写)

message queue的区别:
	redis     没有消息到达确认;
	ZeroMQ    没有持久化, 有潜质的'非持久性MQ队列', 断电数据会丢失, 但并发量大, 同样也没有消息到达确认;
	active MQ 综合性能的apache软件, 功能最强;
	IBM MQ    综合性能的IBM软件, 功能最强, 付费软件;

	ZeroMQ/Redis 都没有实现消息到达确认, 
	redis 比ZeroMQ 功能多一点, ZeroMQ比redis 性能好一点;
	(所以, 一般情况, 不会出现ZeroMQ/Redis 联合使用的情况, 只需要用一个即可)

	使用Redis 的好处:
		方便, 神奇的, 持久性MQ队列, 持久性功能, 利用的是redis 持久化功能, 
		有一定间隔, 可能丢失命中[缺陷: 没有消息到达确认]

	redis的性能:
		数据量-每条消息-不应超过4k, 否则可能会带来性能地狱.
		详细看测试报告, 10K 的时候, 速度简直就是龟速, 其它时候, 速度一流!



大型MQ 的开发优势:
	* 节省时间, 节省项目成本, 提高项目完成的可能性, 便捷性, 可维护性;
	* 可以轻松搭建大型app 应用群, 负载能力, 速度, 有序, 可靠性, 可拓展性都非常高;
		[active MQ 也是apache hadoop 框架的'基础组件'之一]
	* MQ 产品已经成形, 社区强大, 稳定安全;

	ps:
		MQ 一般只是用于app 应用server, 也可以用作web app;
		但对于web 网站, 资源型server, 不太适用;



message queue的功能:
	一般mq 都有4种模式, 订阅模式只是其中一种;
	功能弱的开源mq, 可能就没有那么多模式了, 毕竟很多模式需要付费;

	四种常见的MQ队列模式:
	1.direct模式(直接模式)
		生产者将消息发送到交换器; 
		MQ队列根据routing_key接收消息, 消费者消费queue接收到的消息.
		生产者也可以直接将消息发送给queue, 而不设定Exchange以及路由键; 

	2.fanout模式(广播/组播)
		生产者将消息发送到交换器; 
		MQ队列接收所有消息, 消费者消费指定queue接收到的消息; 
		(取代udp 组播)

	3.topic模式(匹配/订阅)
		生产者将消息发送到交换器; 
		MQ队列根据routing_key接收消息, 没有对应的routing_key则消息丢失; 
		消费者消费queue接收到的消息; 

	4.header模式(匹配)
		生产者将带有header消息发送到交换器; 
		MQ队列根据交换机接收消息, 并根据header消息与MQ队列匹配; 
		消费者消费queue接收到的消息;

	此外还有[消息到达确认, 消息完整性校验, 消息对称加密等功能];
	此外还有: MQ 客户端登录验证功能, 基本上就是: 一个MQ, 网络app 开发全无忧, 要学;



message queue的实用意义:
	由于目前的应用规模十分巨大, 已经不可能自己编写网络传输接口了, 
	所以直接使用MQ, 其实是更可靠的办法, 也兼容更大型的网络应用;

	传统网络编码, 正在被这种MQ消息队列产品取代, 
	实际上自己手写网络编码, 也不一定安全稳定;
	目前大量的网络应用, 都是基于MQ队列快速实现的, 可以节省开发时间, 最快的速度实现软件功能, 上线;

	就算你会网络编码, 也是套MQ消息队列比较安全, 
	现在解决问题, 都是在MQ 的基础上, 再做业务拓展的;
	所以, 学习如何使用MQ, 是一个比较重要的任务;

	一般app 服务器, 如微信, 支付宝之类的, 都会使用MQ 的;
	所以, MQ 技术可以说是网络app 应用的未来趋势, 做app 应用必学;





常用Message Queue对比:
	RabbitMQ
		RabbitMQ是使用Erlang编写的一个开源的消息队列, 本身支持很多的协议: AMQP, XMPP, SMTP, STOMP, 
		也正因如此, 它非常重量级, 更适合于企业级的开发; 
		同时实现了Broker构架, 这意味着消息在发送给客户端时先在中心队列排队; 
		对路由, 负载均衡或者数据持久化都有很好的支持; 
	Redis
		Redis是一个基于Key-Value对的NoSQL数据库, 开发维护很活跃; 
		虽然它是一个Key-Value数据库存储系统, 但它本身支持MQ功能, 
		所以完全可以当做一个轻量级的队列服务来使用; 
		对于RabbitMQ和Redis的入队和出队操作, 各执行100万次, 每10万次记录一次执行时间; 
		测试数据分为128Bytes、512Bytes、1K和10K四个不同大小的数据; 
		实验表明:
			入队时, 当数据比较小时Redis的性能要高于RabbitMQ,
			而如果数据大小超过了10K, Redis则慢的无法忍受;
			出队时, 无论数据大小, Redis都表现出非常好的性能, 而RabbitMQ的出队性能则远低于Redis; 
	ZeroMQ
		ZeroMQ号称最快的消息队列系统, 尤其针对大吞吐量的需求场景; 
		ZeroMQ能够实现RabbitMQ不擅长的高级/复杂的队列, 但开发人员需要自己组合多种技术框架, 技术上的复杂度是对这MQ能够应用成功的挑战; 
		ZeroMQ具有一个独特的非中间件的模式, 你不需要安装和运行一个消息服务器或中间件, 因为你的应用程序将扮演这个服务器角色;
		你只需要简单的引用ZeroMQ程序库, 可以使用NuGet安装, 然后你就可以愉快的在应用程序之间发送消息了; 
		但是ZeroMQ仅提供非持久性的队列, 也就是说如果宕机, 数据将会丢失; 
		其中, Twitter的Storm 0.9.0以前的版本中默认使用ZeroMQ作为数据流的传输(Storm从0.9版本开始同时支持ZeroMQ和Netty作为传输模块); 
	ActiveMQ
		ActiveMQ是Apache下的一个子项目, 类似于ZeroMQ, 它能够以代理人和点对点的技术实现队列; 
		同时类似于RabbitMQ, 它少量代码就可以高效地实现高级应用场景; 
	Kafka/Jafka
		Kafka是Apache下的一个子项目, 是一个高性能跨语言分布式发布/订阅消息队列系统, 
		而Jafka是在Kafka之上孵化而来的, 即Kafka的一个升级版; 
		Jafka具有以下特性:
			快速持久化, 可以在O(1)的系统开销下进行消息持久化;
			高吞吐, 在一台普通的服务器上既可以达到10W/s的吞吐速率;
			完全的分布式系统, Broker、Producer、Consumer都原生自动支持分布式, 自动实现负载均衡;
			支持Hadoop数据并行加载, 对于像Hadoop的一样的日志数据和离线分析系统, 但又要求实时处理的限制, 这是一个可行的解决方案; 
			Kafka通过Hadoop的并行加载机制统一了在线和离线的消息处理; 
			Apache Kafka相对于ActiveMQ是一个非常轻量级的消息系统, 除了性能非常好之外, 还是一个工作良好的分布式系统; 



