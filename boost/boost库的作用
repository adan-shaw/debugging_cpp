#
# 1.跨平台第三方编码库, 一套代码, 遍地编译的可行性讨论
#

同一个ffmpeg 编码库, 即使在不同平台下, 迁移时, API 和用法也都不需要改变, 
同一个opencv 编码库, 即使在不同平台下, 迁移时, API 和用法也都不需要改变, 
同一个openssl 编码库, 即使在不同平台下, 迁移时, API 和用法也都不需要改变, 
...

类似的第三方库, 支持跨平台编码的第三方库, 很多, 这里不一一列举了;

支持跨平台的第三方库, 一般情况下都是API, 参数, 用法, 都是一样的,
具体实现的差异, 由跨平台编码库自己实现平台差异屏蔽, 使用者只管用即可;

只需要解决不同平台的安装问题即可, 安装之后, 重新编译即得出正确结果, 问题不大;





#
# 2.没有跨平台的posix API, 是各个操作系统商的困局, 第三方库boost 是如何联合c++, 打破系统编码跨平台的困局的??
#
不同平台的线程库, 系统编码的差异性极大, 
而且没办法通过安装第三方拓展库的方式, 来屏蔽差异!!

因此, 才有了boost 库;
因此, boost 才有:
	线程库, 
	异步io 库,
	进程间通信库,
	...

通过安装boost, 然后用boost 来屏蔽各个平台之间的差异, 实现跨平台开发;

因此, 使用boost 编写的代码, 
只要在各个平台安装boost, 就可以轻松进行跨平台编译, 
也就是实现跨平台编码, 极大限度地拓展了c++, 让c++ 比肩java/python, 成为跨平台开发的语言;



新版本的c++11, 已经将多线程库, 纳入到c++ 11 中, boost 中的异步io 库, 进程间通信库还未纳入;

因此, boost 仍然有一定的生存空间:
	* 在跨平台多进程c++ 程序中, 有一定存在的价值;
	* 在跨平台异步io 程序中, 有一定存在的价值;

c++ 旧版本, 只做到了文件系统兼容(文件流), c++ 做到了多线程共享, 
c++ 跨平台开发的异步io, 多进程, 还是交给boost 来做;
因此, boost 有一定的生存价值;





#
# 3.拓展问题
#
使用新版c++ && boost && 智能指针, 实现跨平台c++ 编码的意义:
	* 省代码, 更敏捷的开发速度, 一套代码遍地编译, 实现跨平台, 把更多时间放在打磨产品上;
	* 代码复用率高, 更新换代容易, 摆脱依赖性地狱, 跨平台地狱的问题;
	* 提高代码精度, 更简洁的代码, 意味着更可靠的代码, 只要在性能允许的范围内, 只要性能允许, 一律以简洁, 一律以简单为最好;

使用新版c++ && boost && 智能指针, 实现跨平台c++ 编码的担忧:
	* 性能, 除了性能差一点这个毛病之外, 真的想不到其他毛病, 但这个毛病真的是不重要, 属于次要毛病,
		如果程序能正常工作, 根本不需要理会性能问题, 
		除非有新的竞争者出现, 
		这时候优化代码, 提高性能, 成为了打击对手的手段, 
		否则优化实际上, 不影响业务运行, 就不优化, 是真理;

	* 语法起点高, 会用的赞美, 不会用的蛋疼, 这实际算不上是一个问题, 忽略;



