c++ 跨平台开发的核心价值:
	软件开发应该更专注构建软件的核心价值, 而非维护API;
	这就是为什么c++ 需要牺牲少量的性能, 走上c++跨平台开发的道路;
	损耗一定会有, 但只要在合理的范围内, 不影响业务正常运行即可;

	过去的日子里面, 碍于芯片工业的限制, 芯片的性能妨碍了软件行业的爆发式发展, 应该说:
		每次芯片工业的爆发式增长, 必然伴随着软件行业正相关的爆发式增长, 两者关系是正相关的;
		今天的芯片工业, 较1998 年有巨大的飞跃, 芯片制程从90纳米飞跃到5纳米, 还是多核cpu,
		因此, c++ 也必然从c++ 1998, 迁移到c++11, 甚至是c++20;
		软件工程师们, 不再执着怎么算1+1会比较快一点的事情, 
		那是硬件工程师, 是数模转换, 是fpga, 是芯片指令集设计者需要考虑的事情, 不是软件工程师需要考虑的;
		那软件工程师需要考虑什么?
		还是那句话:
			软件开发应该更专注构建软件的核心价值, 而非维护API;



	分析目前跨平台c++ 开发的可行性:
		c++11 / c++20:
			支持多线程及多种线程同步方式(各种锁), 
			支持通用io流, file文件流(最早的跨平台手段, c++1998),
			支持内存分配管理(支持智能指针 + stl allocator空间配置器 + jemalloc, tcmalloc, ptmalloc 内存管理器)
			支持常用的数据结构容器+算法(c++ stl标准库)
			cygwin + mingw, 实现跨平台编译工具链(虽然mingw 精简, 但胜在跨平台能力强, 最新版本的mingw 编译器, 已经支持c++20 了)
			...
		boost: [这里只描述boost 中有的, 新版c++ 中没有的概念, 作为互补!!]
			支持信号槽(即boost事件处理; 类似qt信号槽, 预计qt, 包括其他c++ 可视化框架如:gtk3, wxWidgets等, 都是用信号槽实现GUI的)
			支持异步通用io流(c++ 标准库仍然是同步通用io流, 异步通用io流包括: io事件通知, 可取代select,poll,epoll等io事件通知API)
			支持进程间通信
			支持序列化&反序列化(反序列化!=反射, 这是两个概念, c++想要实现反射, 需要第三方库的支持)
			...
		qt:
			跨平台c++可视化GUI设计(主要是界面绘描+信号槽+显示特效,用qt主要是因为: 
														跨平台能力好, 性能强, 其他版本的c++ GUI库, 如:gtk3,wxWidgets)
			通用跨平台socket API库(qt 对socket 套接字, 进行二次封装, 实现跨平台网络库的开发)
			...

	由此可见:
		只要c++ 编译器支持c++11, c++20, 然后再安装一个boost 库, 就可以适度取代'c语言+posix API', 并且具备跨平台能力;
		再加一个跨平台qt gui库, 跨平台MQ/Qt-socket 库, boost 跨平台io 异步库,
		最终实现精简跨平台client 程序, 不是什么难事, 只是运行性能上, 可能没有那么好而已, 
		但软件开发速度, 软件代码复用率, 软件可靠性, 都比较好(简单, 可复用, 代码少, 就是最可靠的),

		综合下来, 只要性能允许, 直接一套c++ 代码, 跨平台编译, 是成本最低, 效率最好的client 方案;
		(这也没啥好奇怪的, 毕竟goland 都出来了, c++ 要是不进步, 被取代的可能性很高)



最后重申:
	软件开发应该更专注构建软件的核心价值, 而非维护API!!
