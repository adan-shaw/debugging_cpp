c++ 跨平台开发的核心价值:
	软件开发应该更专注构建软件的核心价值, 而非维护API;
	这就是为什么c++ 需要牺牲少量的性能, 走上c++跨平台开发的道路;
	损耗一定会有, 但只要在合理的范围内, 不影响业务正常运行即可;
	过去的日子里面, 碍于芯片工业的限制, 芯片的性能妨碍了软件行业的爆发式发展,
	应该说:
		每次芯片工业的爆发式增长, 必然伴随着软件行业正相关的爆发式增长, 两者关系是正相关的;
		今天的芯片工业, 较1998 年有巨大的飞跃, 芯片制程从90纳米飞跃到5纳米, 还是多核cpu,
		因此, c++ 也必然从c++ 1998, 迁移到c++11, 甚至是c++20;
		软件工程师们, 不再执着怎么算1+1会比较快一点的事情, 
		那是硬件工程师, 是数模转换, 是fpga, 是芯片指令集设计者需要考虑的事情, 不是软件工程师需要考虑的;
		那软件工程师需要考虑什么?
		还是那句话:
			软件开发应该更专注构建软件的核心价值, 而非维护API;

	分析目前跨平台c++ 开发的可行性:
		c++11 / c++20:
			支持简单的多线程及多线程同步, 
			支持通用io流, file文件流(最早的跨平台手段, c++1998),
			支持内存分配管理(支持智能指针 + stl allocator空间配置器 + jemalloc, tcmalloc, ptmalloc 内存管理器)
			支持常用的数据结构容器+算法(c++ stl标准库)
			...
		boost: [这里只描述boost 中有的, 新版c++ 中没有的概念, 作为互补!!]
			支持信号槽(即boost事件处理; 类似qt信号槽, 预计qt, 包括其他c++ 可视化框架如:gtk3, wxWidgets等, 都是用信号槽实现GUI的)
			支持异步通用io流(c++ 标准库仍然是同步通用io流, 异步通用io流包括: io事件通知, 可取代select,poll,epoll等io事件通知API)
			支持进程间通信
			支持序列化&反序列化(反序列化!=反射, 这是两个概念, c++想要实现反射, 需要第三方库的支持)
			...
		qt:
			跨平台c++可视化GUI设计(主要是界面绘描+信号槽+显示特效,用qt主要是因为跨平台能力好,其他版本的c++ GUI库,跨平台能力一般不强,如:gtk3,wxWidgets)
			...

	由此可见:
		c++11(c++20) + boost, 已经可以完全取代'c语言+posix API'了, 并且具备跨平台能力;
		那就是:
			只要c++ 编译器支持c++11, c++20, 然后再安装一个boost 库, 就可以适度取代'c语言+posix API', 
			只是运行性能上可能没有那么好, 
			但是软件开发速度, 软件代码复用率, 软件可靠性, 都比较好(简单, 可复用, 代码少, 就是最可靠的),

		综合下来, c++新版 + boost 取代'c语言+posix API', 完全有可能, 只要性能允许;
		(这也没啥好奇怪的, 毕竟goland 都出来了, c++ 要是不进步, 被取代的可能性很高)

		再加上一个跨平台c++可视化框架: qt
		实现跨平台c++ 软件开发, 是可行的;



	软件开发应该更专注构建软件的核心价值, 而非维护API!!
