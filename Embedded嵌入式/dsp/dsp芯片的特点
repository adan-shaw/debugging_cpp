DSP处理器(Digital Signal Processor):
	DSP运算能力强, 擅长很多的重复数据运算, 
	而MCU则适合不同信息源的多种数据的处理诊断和运算, 侧重于控制, 速度并不如DSP.





DSP特点总结:
		* 对密集的乘法运算的支持:
				其它芯片需要多个指令周期来做一次乘法, DSP处理器使用专门的硬件来实现单周期乘法;

				DSP处理器还增加了累加器寄存器来处理多个乘积的和, 
				累加器寄存器通常比其他寄存器宽, 增加称为结果bits的额外bits来避免溢出;

				同时, 为了充分体现专门的乘法-累加硬件的好处, 几乎所有的DSP的指令集都包含有显式的MAC指令.



		* 哈佛存储器结构, 支持单周期的MAC指令:
				传统MCU 使用冯·诺依曼存储器结构, 
				这种结构中只有一个存储器空间, 通过一组总线(一个地址总线和一个数据总线)连接到处理器核, 有总线占用冲突问题;
				intel CPU也有总线访问冲突问题, 所以极限就最多4个CPU集成在一块主板上;

				大多数DSP采用了哈佛结构, 将存储器空间划分成两个, 分别存储程序和数据, 
				它们有两组总线连接到处理器核, 允许同时对它们进行访问;
				这种安排将处理器存储器的带宽加倍, 更重要的是同时为处理器核提供数据与指令,
				在这种布局下, DSP得以实现单周期的MAC指令;



		* 零开销循环:
				大多数的DSP都有专门的硬件, 用于零开销循环;
				所谓零开销循环是指处理器在执行循环时, 不用花时间去检查循环计数器的值、条件转移到循环的顶部、将循环计数器减1;
				与此相反, GPP的循环使用软件来实现:
					某些高性能的GPP使用转移预报硬件, 几乎达到与硬件支持的零开销循环同样的效果;



		* 定点计算持:
				大多数DSP使用定点计算, 而不是使用浮点;
				虽然DSP的应用必须十分注意数字的精确, 用浮点来做应该容易的多, 但是对DSP来说, 廉价也是非常重要的;
				定点机器比起相应的浮点机器来要便宜(而且更快),
				为了不使用浮点机器而又保证数字的准确, DSP处理器在指令集和硬件方面都支持饱和计算、舍入和移位;



		* 专门的寻址方式:
				DSP处理器往往都支持专门的寻址模式, 它们对通常的信号处理操作和算法是很有用的;
				例如, 模块(循环)寻址(对实现数字滤波器延时线很有用)、位倒序寻址(对FFT很有用);
				这些非常专门的寻址模式在GPP中是不常使用的, 只有用软件来实现;



		* 执行时间的预测:
				大多数的DSP应用(如蜂窝电话和调制解调器)都是严格的实时应用, 所有的处理必须在指定的时间内完成;
				这就要求程序员准确地确定每个样本需要多少处理时间, 或者至少要知道, 在最坏的情况下需要多少时间;

				如果打算用低成本的GPP去完成实时信号处理的任务, 执行时间的预测大概不会成为什么问题, 应为低成本GPP具有相对直接的结构, 比较容易预测执行时间;
				然而, 大多数实时DSP应用所要求的处理能力是低成本GPP所不能提供的;
				这时候, DSP对高性能GPP的优势在于, 即便是使用了高速缓存的DSP, 哪些指令会放进去也是由程序员(而不是处理器)来决定的, 
				因此很容易判断指令是从高速缓存还是从存储器中读取;

				DSP一般不使用动态特性, 如转移预测和推理执行等,
				因此, 由一段给定的代码来预测所要求的执行时间是完全直截了当的.从而使程序员得以确定芯片的性能限制.



		* 定点DSP指令集:
				定点DSP指令集是按两个目标来设计的:
					1.使处理器能够在每个指令周期内完成多个操作, 从而提高每个指令周期的计算效率;
					2.将存贮DSP程序的存储器空间减到最小(由于存储器对整个系统的成本影响甚大, 该问题在对成本敏感的DSP应用中尤为重要);

				为了实现这些目标, DSP处理器的指令集通常都允许程序员在一个指令内说明若干个并行的操作.
				例如, 在一条指令包含了MAC操作, 即同时的一个或两个数据移动.
				在典型的例子里, 一条指令就包含了计算FIR滤波器的一节所需要的所有操作.
				这种高效率付出的代价是, 其指令集既不直观, 也不容易使用(与GPP的指令集相比);

				GPP的程序通常并不在意处理器的指令集是否容易使用, 因为他们一般使用象C或C++等高级语言.
				而对于DSP的程序员来说, 不幸的是主要的DSP应用程序都是用汇编语言写的(至少部分是汇编语言优化的).

				这里有两个理由:首先, 大多数广泛使用的高级语言, 
				例如C, 并不适合于描述典型的DSP算法.
				其次,  DSP结构的复杂性, 如多存储器空间、多总线、不规则的指令集、高度专门化的硬件等, 使得难于为其编写高效率的编译器.

				即便用编译器将C源代码编译成为DSP的汇编代码, 优化的任务仍然很重.
				典型的DSP应用都具有大量计算的要求, 并有严格的开销限制, 使得程序的优化必不可少(至少是对程序的最关键部分).
				因此, 考虑选用DSP的一个关键因素是, 是否存在足够的能够较好地适应DSP处理器指令集的程序员.




