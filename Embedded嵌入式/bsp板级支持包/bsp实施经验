#
# 0.前言
#
目前bsp 开发, 基本上都是conf 配置好之后, 直接一个project, 编译即出img 镜像, 非常方便, 支持直接编译出img 的project 有:
	* aosp
	* yocto(linux)
	* openwrt
	* buildroot(linux)
	* rt-thread/luatos
	* freertos/nuttx (貌似没有引导系统, 需要自己重建引导系统)
	...
	这几个常见的os 都已经囊括了, 包括了大中小操作系统, 包括了实时/分时操作系统;
	(由于buildroot/yocto 的出现, linux-bsp 开发的历史遗留问题被解决, 老式lfs 已经被抛弃;
	 在bsp 过程中, 还需要自己手动修改patch 的情况基本不多了;)

'还需要patch 修改源码, 或者增加源码'的bsp 场景, 例如: 
	我想给Linux os 打入RT实时补丁, 用作车载SoC-OS 的主控OS, 这时候就很有可能会打入RT 实时内核补丁;
	你需要做的是: 
		在yocto 编译之前, 进行conf 配置, 直接配置yocto-linux-kernel 内核相关的参数, 
		最终得出一个具有RT 实时性能的linux OS





#
# 1.bsp 实施策略:
#
大型分时系统(按照纯手工lfs 路线定制):
	* 根据芯片, 搭建原始gcc
	* 使用原始gcc 编译os kernel
	* 根据原始gcc + os kernel, 编译出c/c++ 运行时库glibc;
	* 编译出全功能gcc/g++;
	...
	(以下的工作可以用buildroot/yocto 替代, 概括说就是: 生成roosfs 根文件系统)
	...
	* 根据全功能gcc 编译工具链 + os kernel, 编译出os 的disk文件系统, 网络协议栈, 关键驱动的重建;
	* 根据全功能gcc 编译工具链 + os kernel, 编译出os 的关键底软的重建(一般是busybox, 编译出: bash shell, find, ip 等关键exe 软件工具)
	* initrd/initramfs 镜像的布局(rootfs 根文件系统)
	* dtb 设备树镜像(驱动管理)
	* uboot/grub/syslinux 引导系统(网络引导/安全引导/自检工作)
	* 重新烧制img 镜像;
	...
	* 二次自检: 设备自检, os 镜像引导, 驱动启动&自检, 底软服务启动&自检等等的测试任务;
	* 整个os 启动, 运行, 服务管理的优化(提升);
	* 信息安全优化(img 镜像安全启动, img 镜像数据安全, 引导锁, 等等);
	- 补全业务应用(略)
	...



小型实时系统:
	* 根据芯片, 搭建与芯片匹配的编译工具链;
		(ubuntu apt 里面有现成的编译工具链, 平台匹配的话, 可以直接安装, 省事, 省得自己定制, 贼麻烦)
	* 直接编译整个project, 即可得出:
			+ 编程sdk 库 
			+ os 系统的'img,iso镜像(有引导系统) / bin,elf 可执行文件(无引导系统)';
	* 使用qemu-x/qemu-system-x 虚拟机, 进行模拟运行(可以加入gdb 进行调试);
	* img 镜像稳定后, 烧制到disk 存储设备;



大型系统一般都有自动化工具帮你生成维护bsp, 你只需要熟练这些工具的使用, 也可以轻松维护os img镜像, 但需要补全很多驱动程序倒是真的;
小型系统, 有没有自动化工具帮你生成维护bsp, 得看该小型os 的上有厂商, 是否有提供这样的维护工具, 有当然是最好了, 没有就需要自己手动维护, 麻烦!!





#
# 2.应用程序员how 如何快速搭建交叉编译工具链
#
快速搭建交叉编译工具链:
	普通应用程序员, 不需要知道如何搭建快速交叉编译工具链, 
	直接在编译好的环境中, 把交叉编译工具链拷贝出来, 直接复制粘帖, 安装到指定位置即可(省事);

但bsp 级别的交叉编译工具链, 实际上就是你之前做的lfs, 如果需要自己重建, 十分麻烦;
就是从gcc 中选择适合的arch, 编译出原始gcc, 然后编译glibc, 然后编译全功能的gcc/g++, 
这种编译工具链制作, 时间成本很高, 而且还要考虑准确率, 可用性;
(gcc/clang 支持的芯片, 编译器可靠, gcc/clang 不支持的编译器, 制作交叉编译工具链就不那么轻松了)





