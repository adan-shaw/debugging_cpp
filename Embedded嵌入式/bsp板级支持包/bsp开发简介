#
# 1.bsp 开发过程中常见的一些概念(抛书包的概念)
#
bsp 的主要功能:
	bsp 的主要功能是屏蔽硬件, 提供操作系统及硬件驱动, 具体功能包括:
		1.单板硬件初始化, 主要是CPU的初始化, 为整个软件系统提供底层硬件支持
		2.为操作系统提供设备驱动程序和系统中断服务程序
		3.定制操作系统的功能, 为软件系统提供一个实时多任务的运行环境
		4.初始化操作系统, 为操作系统的正常运行做好准备



bsp的作用:
	建立让操作系统运行的基本环境:
		1、初始化CPU内部寄存器
		2、设定RAM工作时序
		3、时钟驱动及中断控制器驱动
		4、串口驱动

	完善操作系统运行的环境:
		1、完善高速缓存和内存管理单元的驱动
		2、指定程序起始运行位置
		3、完善中断管理
		4、完善系统总线驱动



HAL 硬件抽象层简介:
	硬件层与软件层之间为中间层, 也称为:
		硬件抽象层(Hardware Abstract Layer, HAL):
			该层一般包含相关底层硬件的初始化、数据的输入/输出操作和硬件设备的配置功能;

bsp 板级支持包简介:
	板级支持包(Board Support Package, bsp):
		'BSP板级支持包'将系统上层软件与底层硬件分离开来, 
		使系统的底层驱动程序与硬件无关, 上层软件开发人员无需关心底层硬件的具体情况, 只需根据bsp层提供的接口进行开发即可.

ps:
	bsp 就是操作系统移植, 适配的工作, 驱动开发的任务较多;



bsp具有以下两个特点:
	硬件相关性:
		因为嵌入式实时系统的硬件环境具有应用相关性, 
		而作为上层软件与硬件平台之间的接口, bsp需要为操作系统提供操作和控制具体硬件的方法.

	操作系统相关性:
		不同的操作系统具有各自的软件层次结构, 
		因此, 不同的操作系统具有特定的硬件接口形式.
		实际上, bsp是一个介于操作系统和底层硬件之间的软件层次, 包括了系统中大部分与硬件联系紧密的软件模块.





#
# 2.bsp 的开发实践
#
不同的os系统的bsp 工具链, 是完全不一样的, 用到的:
	编译工具链, 
	系统内核,
	系统底软, 
	...
等等, 都是不一样的;

但配套的技术, 大部分是相通的, 例如: 交叉编译工具链, uboot, qemu, gdb 等等;
目前的新一代操作系统, 都会配备完整的工具链(如: android/yocto/buildroot/openwrt/RT-Thread...), 
只有老式的linux lfs, 才会是十分零散的源码+patch更新组建的操作系统工具链(这种做法基本被抛弃);



(一阶)
bsp 开发, 主要包含下面的任务量:
	* 设备自检系统 + os镜像引导系统(bios/syslinux/grub/uboot);
	* os 编译工具链组建, 调试(gcc+glibc+kernel+make工具);
	* os 内核芯片适配, 内核模块剪裁, 内核实体编译(内核移植);
	...
	* os 的关键协议栈重建: 
		disk文件系统(rootfs), 
		网络协议栈(如: lwip), 
		信息安全库(os 内核的信息安全库差异很大, 不展开), 
		[进程管理器/内存管理器, 一般属于os 内核的模块, 再小的os 也不会把这部分功能独立出来的]
		...
	* os 驱动进一步适配, 匹配更多设备类型, 更复杂的驱动(驱动层进一步功能拓展移植, 完善驱动层);
	* os 基础底软层的进一步完善;
	...
	* os 镜像引导(网络引导/安全启动), 驱动+基础底软自检;
	* img/iso 镜像封装, 烧制;
	...
	(大部分bsp 工作, 在这一层已经完成了, 已经可以制作出一个img/iso 系统镜像了, 下一步都是'底软中间件/应用层'的移植工作了)



(二阶)
bsp 开发涉及的'底软中间件/应用层'移植任务:
	(这部分严格来说, 不算是bsp 的任务范围;
	 对于小型系统来说, 没有那么多划分, 例如: freertos, rt-thread ...
	 对于大型系统来说, '底软中间件/应用层'的移植, 也很重要, 如: android, openwrt, autosar ...)

	* os 关键底层的bin/lib/sdk 编程库的移植, 优化, 如: 
			面向多媒体开发中, 向目标平台中移植: ffmpeg bin+lib+sdk;
	* 重建os 系统编程语言sdk + runtime 库, 如: android-java / openwrt-lua;
	* 新的os 系统编程语言sdk + runtime 库下, 基于新的系统编程语言java/lua, 编辑的新'底软中间件/应用层';
	* 二级底软性能优化
	...
	- 移植后, 底软的二次开发(严格来说, 这是app 应用程序员的任务了)


	一般来说, 越是大型的操作系统, bsp 和底软的分割线, 会越明显!!
	(甚至会有java/lua 脚本机来彻底隔绝kernel 内核态和app 用户态的SDK, 实现计算机职能分层)

	越是小型的系统, bsp 和底软的分割线, 会越模糊!!
	例如:
		qnx, 这个中型系统, 就基本上没有应用/驱动的划分的, 应用和驱动同权, 同等对待;
		比qnx 小的rtos 就更是如此了, rtos 的软件开发, 应用开发, 实际上就是嵌入式驱动开发(有区别?)
		因此, 中小型系统, 基本上没有应用/驱动的划分的, RT 实时系统, 更是如此;

		大型分时系统, 就有应用/驱动的划分, 因为分时系统一般较为庞大, 例如: linux, android, openwrt;
		在分时系统中, 最小的openwrt, 也会用lua 脚本机, 来彻底隔绝应用/驱动;
		android 则是用java 脚本机来彻底隔绝应用/驱动;
		linux 则是用: 用户态sdk(posix API)/内核态sdk(syscall) 不能互相调用为由, 彻底隔绝应用/驱动;

	总的来说, bsp 开发基本上也看不同系统来区分, 
	实时系统中, 大部分都是底软+驱动开发; 
	分时系统中, 一般就是指驱动开发;



bsp 简化:
	通俗地理解就是: 给你一块电板, 把android/linux/openwrt/qnx/VxWorks/RT-Thread 所需的一切, 都搭建上去; 包括:
		* c/c++编译工具链
		* kernel 系统内核适配[进程管理器(包括内存管理器), 一般属于os 内核的模块]
		* rootfs 根文件系统(disk文件系统, 网络协议栈, 信息安全库, 等等的重建)
		* driver 设备驱动适配 && 编写
		* os 基础底软适配 && 编写(一阶)
		- os 高级底软适配 && 编写(二阶)[如果有]
		* bios 系统(设备自检)
		* grub/uboot 引导系统(网络引导/安全启动/驱动+基础底软自检)
		* img/iso 镜像封装;
		...
		qemu + gdb 调试



