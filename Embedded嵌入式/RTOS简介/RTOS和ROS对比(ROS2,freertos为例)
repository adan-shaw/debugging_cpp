RTOS和ROS对比(ROS2,freertos为例):
共同点:
	* 都是实时系统, 为实时系统而设计的(linux 其实是以分时系统为基准而设计的, linux 主要是为互联网服务的)
	* 内核基本上都比linux 精简, 都不存在用户态/内核态分级, 都只有一个程序运行态;

	- 都支持多线程, 网络编程, 驱动编程, 应用编程等基础编程组件(待定)



不同点:
	ROS:
		- 规模比普通的RTOS 大
		- 更好地支持大型c/c++ 编译器
		- 更好地支持posix 通用操作系统编程标准, 更容易地移植'posix 标准'编写的应用程序;
			(ps: 更要命的是大部分'posix 标准'程序, 基本上都是为分时系统设计的程序, 在实时应用场合根本不适用, 乱移植也没用, 参考一下可以)
		- 软件社区更强大, 但设备驱动社区, 较为薄弱(只是相对来说比较薄弱而已)
		- 支持更多编程模式, 方式, 方法;
		- ROS 比较大型, 类似的操作系统不多(ROS 与 QNX 比较类似, 维度比较类似, 但QNX 是闭源操作系统);

	RTOS:
		- 规模比普通的ROS 小
		- 绝大部分支持标准c 语言编码(部分支持c++ 语言编码)
		- RTOS 的SDK 系统编码接口API, 不一定都会向posix 通用操作系统编程标准看齐!! 
			只有少部分会向'posix 标准'看齐, 但即便跟'posix 标准'类似, 但也不可能移植'posix 标准'编写的软件!!
			(ps: 更要命的是大部分'posix 标准'程序, 基本上都是为分时系统设计的程序, 在实时应用场合根本不适用, 乱移植也没用, 参考一下可以)
		- 软件社区一般强大(看社区规模), 但设备驱动社区强大, 一般来说配套的设备方案, 设备驱动方案都很多, 甚至可以拿来即用, 改动的话, 也可以参考式改动;
		- 支持的编程模式, 方式, 方法, 比较少;

