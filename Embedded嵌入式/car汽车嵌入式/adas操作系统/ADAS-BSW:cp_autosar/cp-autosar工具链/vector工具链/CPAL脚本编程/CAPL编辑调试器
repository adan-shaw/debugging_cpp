声明:
	一般情况下, 你都不需要重头搭建整个仿真网络, 而是需要适当添加node 仿真节点即可;
	那么实际上, 你可以通过:
		在仿真网络的画布图标右键, 新增node 节点元件, 一般有:
			ECU 元件(编写node 节点逻辑)
			Test 元件(编写test 逻辑)

	然后在新增node 节点元件上面, 实现各种逻辑;





debug CAPL仿真器节点元件的方法:
	需要重启整个仿真画布, 因此最好确保:
		调试机器windows 有充足的内存, 16GB 左右;
		尽量缩减node 节点元件的数量, 否则频繁重启, debug, 性能消耗比较客观;
		尽量缩减arxml 信号仲裁记录文件的大小, 信号数量越少, 性能越好;

	重启整个仿真画布后, 看汇总打印输出, 查看各个元件的log 打印日志;
	ps: write("") 函数常用作打印输出log





CAPL 仿真器脚本:
	CAPL 仿真器, 编写语法十分类似c 语言, 需要先编译, 然后会自动装载到仿真器中, 
	最后, 启动整个CAPL 仿真器时会自动执行node 节点元件中的逻辑, 就这样;

	ECU 元件编码细节:
		ECU 元件逻辑执行顺序:
			Include:				包含资源头文件, 可以是.cin / .can文件
			Variables:			定义全局变量、以及一些需要定义的结构体等相关的内容
			System:					包含启动函数, 退出函数, 预启动函数, 预退出函数, 定时器函数, 按键函数等
			Value Object:		收到具体信号的值后, 本模块作出的响应手段(信号/变量的值的复制与监测)
			Service Signal:	信号处理函数(一般不怎么用, 默认处理方式)
			Ethiernet:			链路层数据包处理函数, 可以进行拆包
			TCP/IP:					网络层数据包处理函数, 可以进行拆包(TCP/IP协议拆包)
			Autosar PDU:				unknow, 少用
			Map Window:					unknow, 少用
			App Layer Objects:	unknow, 少用
			Functions:			用户自定义的函数(可多层嵌套)
		统一的打印函数:
			write("")
		字符串处理函数list: 略
		数学处理函数list: 略

	ECU 元件编码思路:
		有收就有发, 一般编写ECU 元件的代码, 至少是2 个ECU 元件起步, 一般不会自收自发(没意义);
		刚开始ECU 元件编码, 可以新建两个ECU 元件, 进行互相收发处理;
		收到信号统一打印输出write("");

	善用定时器和死循环, 做信号循环发送, 避免频繁重复启动CAPL 整个仿真器进行debug;


	ps:
		CAPL 仿真器简单使用不难, 但底层还要解析协议, 做协议对接;
		如果要造工具, 则可以需要根据芯片, 硬件, 底层协议逻辑, 来编写仿真工具, 
		还要做自动化, 可视化, 这会十分艰难;


	最终保存整个*.can 文件, 存放路径最好为:
		<install_path>/CANoe/RadarNCD2217/Nodes/*
	如果路径不对, 容易导致包含头文件资源失败;
	常见的资源头文件路径:
		<install_path>/CANoe/RadarNCD2217/Nodes/*
			../CAPL/*
			../GlobalTimeObserver/*
			./Nodes/*
	可以包含引用.cin / .can文件





编码小技巧:
	CANoe 仿真器里面的CAPL 编辑器, 性能超级烂, 复制粘贴, 语法依赖太多;
	可以直接使用geany 编辑器在外面编辑;
	文件格式随意, utf-8 即可, 
	换行符号随意, 不一定需要windows 的换行符号, unix 换行符也可以;
	但需要声明头: /*@!Encoding:1252*/
	这种做法比较类似于python 脚本;

	但最终, CAPL 编辑器, 会编译出二进制文件cbf, 
	然后编译出cbf 之后, 把cbf 文件装载进整个CAPL 仿真器里面, 通过重启整个CAPL 仿真器运行cbf 文件;











