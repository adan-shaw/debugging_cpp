目前的汽车系统, 只有特斯拉属于自研系统, 其他汽车厂商都是多系统合并的混合系统;

又由于linux 的实时性不足, qnx 支持虚拟化技术, 

因此, 目前大部分汽车厂商, 都是使用基于qnx 母系统, 虚拟出来的子系统, 一般有linux/android;



因此, 一般地:
	qnx     = 母系统 = 工控qnx 子系统
						(不需要再虚拟化一个qnx 子系统了, 有qnx 程序, 直接跑在qnx 母系统上面即可, 反正实时性更高)

	linux   = 人工智能系统(qnx 虚拟机), 用来跑:
						人工智能算法(linux 也方便集成各种人工智能算法框架, 全是机器学习);

	android = 坐舱系统(qnx 虚拟机), 用来跑:
						触屏, 多媒体播放器, 语音/视频通话, 地图软件, 车门车窗控制app, 远程监控app, 行车记录仪等应用;



驱动层:
	根据已有的信息显示, 所有虚拟机都没有独立驱动, 都是qnx 驱动, 然后以qnx 虚拟驱动的方式, 装载进qnx 虚拟机;
	因此, 5G 无线电模块, 传感器模块, 摄像头驱动等等, 都是qnx 驱动;
	比较庆幸的是: qnx 和linux 系统其实相似度很大, 比较类似, 只是有一些区别而已;

	因此, 未来qnx 主宰了汽车行业, 就跟qt 后期主宰了可视化客户端程序一样, 是一个趋势;





以上都是Soc 芯片的片上系统, 汽车还有一个autosar-MCU 小型实时系统, 这个系统基本上是独立运行的;

小型系统主要负责的是:
	三电:                  电池, 电机, 电源;
	CAN 实时realtime 工控:  脚刹, 油门, 引擎等, 这部分只保留紧急接管权给用户;
												(因为需要自动驾驶, 所以必然会被soc 系统远程遥控, 而不只是实时信息转发)
	LIN 实时realtime 工控:  车门, 车窗, 车灯, 空调;

	由于要配合自动驾驶, MCU os不会再独立, 而是会与soc 系统进行通信, 
	系统安全由soc 去做保证, MCU os会搭建与soc 系统的双端通信, 彻底变成一个从属系统(但安全监管级别是最高的);





通信系统搭建:
	QNX/Android/linux 内部通信:
		* 非多媒体数据的通信渠道:
				基于qnx 搭建vsomeip/fastDDS 消息中间件, 进行soc 层的内部通信;
		* 多媒体数据的通信渠道:
				基于udp 协议, 单纯的tcp/ip 局域网转发, 力求最高性能, 最高效率转发多媒体重数据流;

	vsomeip/fastDDS 都支持: 
		根据数据帧结构, 自动得出信号收发的中间件代码, 
		后续app 直接调用这个信号的'收/发'api, 就可以的到数据了, 
		这样就不需要处理信号收发的过程, app 收到数据之后, 直接进行解析操作即可, 实现app to app 的MQ;


	Soc <-> MCU:
		* uart 串行: 已淘汰
		* SPI 实时:  廉价高效的方案, 但数据量不大(MCU 工控也不需要太大的数据流, 所以ok)
		* ETH以太网: 成本较高(要求必须MCU支持ETH的mac), 好处是不需要SPI 转换为ETH以太网信号, 总体到soc 层, 性能更好, 未来的趋势;

	目前vector 工具链, 通过达芬奇工具, 可以实现:
		根据数据帧结构, 自动生成autosar 信号收发代码, 
		通过配置, 生成soc <-> MCU 的消息收发代码, 
		这样就不需要处理信号收发的过程, MCU 收到数据之后, 直接进行解析操作即可, 实现soc to MCU 的MQ;


	MCU 内部通信:
		* CAN 高速实时工控
		* LIN 低速实时工控





