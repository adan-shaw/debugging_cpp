1.qnx 的内核架构设计:
	qnx 的内核架构设计, 和linux 有很大差异;
	linux 的SDK, 有内核态(驱动)/用户态(应用), 分级比较复杂;

	linux:
		内核态:
			文件系统, 网络协议栈, 设备驱动, 进程内存管理, 进程管理&通信的底层实现
		用户态:
			posix API

	qnx:
		内核态:
			进程内存管理, 进程管理&通信的底层实现
		用户态:
			文件系统, 网络协议栈, 设备驱动, posix API



	linux 的文件系统, 网络协议栈, 设备驱动, 是以.ko 内核子模块的方式, 加载进linux 系统的;
	qnx 的文件系统, 网络协议栈, 设备驱动, 是以普通daemon 进程的方式, 加载进qnx 系统的;

	所以其实, qnx 的内核更小, 因为只有核心的进程内存管理, 进程管理&通信的底层实现,
	所以qnx 的内核更轻盈, 实时性更高, 更适合嵌入式系统(相当专业的嵌入式实时系统);


	重新设计一个qnx, 并不是不可能, 实际上目前的RT-Thread 之类的小型嵌入式系统,
	其实现原理, 和qnx 都是差不多的, 只是具体的稳定性, 拓展性, 可靠性等问题, 可能不如qnx 的优秀;





2.qnx 的授权
	qnx 是商业操作系统, 没有授权是不能使用的, 只能写email 申请一个月的试用权, 这点和vector 也是一样的;
	qnx 采用vector 模式, 保护自己的知识产权, 这也是一种套路;
	qnx 购买商业授权, 是需要钱的, 这方面其实挺难(不好用, 不好学);





3.qnx 镜像站
	qnx 没有提供公开镜像站, 但qnx 提供VMWare 虚拟机镜像,
	qnx 没有庞大的开源应用群, 有的只有qnx 系统核心, 
	当然也有很多app 应用, 但都是'设备驱动/协议驱动/文件系统驱动'居多, 这些应用基本上都有知识产权, 不开源的,
	所以最终, qnx 镜像实际上和RT-Thread 一样, 都是卖内核, 和公版设备驱动支持的;
	(qnx 官方有一个软硬件主板供应商: Toradex.cn)

	你也可以在qnx 操作系统上面, 开发自己的设备驱动程序/应用, 是不需要付费的;
	(但qnx 系统需要授权, qnx 系统收费)





4.杂谈
	qnx 也要自己编译内核:
		类似linux 的defconfig 内核编译配置文件, qnx 也有类似的config 可供编译;

	qnx 内核非常小, 非常方便剪裁, 因为连设备驱动都是进程制的
	这样的好处是:
		彻底避开linux 宏内核模式(不断插入子模块, 实现功能拓展, 避开这种模式)
	所有的设备驱动都是进程, 更小更便捷的功能;

	qnx 内核是不可修改的(闭源软件)

	qnx 也可以编写自启动脚本

	qnx 没有用户态, 内核态的区分, 编写程序时, 需要注意进程数量和竞争性(可能也没有太复杂的进程调度模式)

	qnx 应该支持posix API

	qnx 支持哪个版本的gcc + glibc, 会在qnx 系统info 中说明, 不用担心

	qnx 支持qt? (但没意义, 一个实时工控系统, 你跑qt 干嘛? 作死?)

	qnx 需要传输到主板上面进行调试, 由于虚拟机也是x86 的, 而且实时性也跟不上qnx, 芯片架构也不一样, 
			因此qnx 一般是物理板调试的, 开发时, 比较考验程序员的编码能力;








