#
# amd和intel的架构有什么不同
#
其实intel, amd 为什么都是x86 架构, 却有不一样的指令集?
你想像中应该是:
	二进制程序编译之后, 可以运行在intel, amd 平台上, 
	那么指令集应该是一样, 
	只是cpu 架构设计不一样而已.
	为什么指令集也会不一样?



要回答这个问题, 你就要明白什么是intel 偷步算法.
x86 架构下, 即IBM PC 小型机'指令标准', 
这个'指令标准'原本就不是intel 专属的, 而是IBM 当年搞出来的x86'指令标准'.
然后制造商有: intel, amd, via
这些生产厂商, 都是根据x86 架构'指令标准', 自己设计cpu 进行生产的.
这点类似于arm 今天的地位一样, arm 发布cpu 架构设计,
arm 负责编译器, linux 内核对齐, 打造BSP, SDK的统一, 
维持软硬件在统一个'指令标准'下运行,
这样才有多姿多彩的arm 软件世界.



intel 其实在基础x86 指令集方面, 是与amd, via 保持一致的.
但是intel 会偷步, 会集成各色各样的, 其它功能, 集成到intel cpu 中:
	MMX
	SSE2,3,4
	AVX,AVX2,AVX512
	这些都是浮点运算指令集, 用来增强多媒体数据处理能力.

amd 也有类似的指令集, 如: 3D Now!

ps:
	浮点计算, 类似于一个附属运算.
	浮点计算可以通过整形模拟, 算出来的.
	因此浮点计算, 并没有形成行业'指令标准', 而是任由芯片公司自己发挥.
	反正整形转换成浮点的方法, 是一个数学公式.
	因此, 这也不需要什么'指令标准', '整形转换成浮点'的数学公式就是'指令标准'



总的来说, x86计算机, 是指整形运算部分(也是计算机最常用到的部分), 是x86指令集'指令标准'的芯片.
这方面, intel, amd, via 都是一致的.

还有:
	虚拟化基础VM, AMD intel 都是根据VM虚拟化'指令标准'来编写指令集的,
	所以, 即便实现出来的指令集不一致, 
	但是VM 虚拟机还是可以在intel, amd cpu 之间迁移.




这也有点类似于今天的arm,
arm 芯片主要就是arm 整形, arm 是没有浮点的.
如果你要在arm 上面运行浮点运算, 你只能通过模拟的方式来实现.
如果想造arm 浮点硬件加速, 目前的方案是:
	增加ai 核心.

所以, 目前的arm 芯片, 有整形核心, AI 核心, io 低频整形核心.
因为计算机指令集不同, 指令流水线不同.
要么你就像intel 这样, 做出'混合指令流水线'.
要么直接造一个新的指令流水线+芯片



另外一方面, 除了浮点指令集不一样, intel 的偷步运算方式, 也跟amd 不一样.
这种偷步方式, 主要体现在cpu 指令集, cpu 架构, gcc 编译器三者的综合设计的不同:
	intel 可以通过在指令集中, 添加一个特殊加速指令, 实现加速(需要gcc 软件作者的配合)
	intel 也可以通过多级cache 机制和cpu 内部cache 算法, 来提高运算效率, 甩开amd
	intel 超线程技术
	...等等





综上所述:
	intel vs amd的共同点是:
		整形计算指令集, 统一是根据x86 IBM 小型机'指令标准'编写的
		VM 虚拟化技术, 也是统一根据VM 虚拟化'指令标准'编写出来的指令集.

	intel vs amd的不同点是:
		芯片架构不一样
		浮点计算的指令集实现不一样
		虚拟化计算的指令集实现不一样
		intel 的偷步算法, 和amd 的不一样(偷步 = 加速运算算法)





新一代amd 锐龙架构, 不展开叙述;
这里只描述为什么x86 架构后期会有这么大的差异, 但后续的细化设计, 不再描述, 这些细化设计会年年更新的;
