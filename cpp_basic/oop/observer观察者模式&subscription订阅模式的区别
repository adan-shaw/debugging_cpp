//observer观察者模式 & subscription订阅模式:
/*
1.这两个设计模式, 都是比较主从明显的设计模式, 主要区别:

	observer观察者:
		适合一对一, 一对多的情况(单向推送);
		无订阅过程, 强制推送, 接收者必须接收, 不能拒绝;
		(相当于一个全员订阅, 唯一channel 的订阅模式)

	subscription订阅模式:
		适合一对一, 一对多, 多对多的情况(单向推送);
		有订阅过程, 自选推送, 接收者可以接收数据, 可以拒绝数据(订阅即推送, 不能拒绝推送消息, 要么就别订阅);
		(多个channel, 自选订阅, 订阅即推送的订阅模式)

	总结:
		'observer观察者模式', 由于被观察的对象只有一个(即channel), 所以不适合多对多的情况, 
		但相对'subscription订阅模式', 'observer观察者模式'比较简单, 
		因为'observer观察者模式'并没有订阅机制, 不用检查访问者是否已经订阅了内容;

		但实际上, 实现'subscription订阅模式'的时候, 也没有太复杂的订阅, 推送过程, 
		也是通过最简单的方式, 实现订阅, 推送功能, 也就是: 加入channel 就默认参与订阅, 订阅后就强制推送消息, 不能拒绝!! 相当于channel 消息广播;

	ps:
		订阅, 推送实际上, 也是根据socket fd来决定的, 只要某个socket fd 加入了channel, 那就相当于这个socket fd 订阅了该channel, 就会被推送消息!!
		'subscription订阅模式'的实现方式, 没有那么复杂!!





2.'subscription订阅模式'在SOA 面向服务设计中的应用:
	目前的SOA 面向服务设计模式, 大部分都采用'subscription订阅模式', 订阅了某个service, 就能接收到推送内容, 在MQ 消息队列框架中经常用;

	而且由于MQ 消息队列框架, 无论是互联网APP 还是汽车行业的autosar 中间件, 都会用到MQ,
	因此, SOA 面向服务设计模式, 'subscription订阅模式', 现在比较火红;
	只要是MQ, 无论是异步MQ, 还是实时MQ, 都是'subscription订阅模式'模式的(比较偏向面向服务设计模式);

	observer观察者模式:
		一对多的强制推送关系, 应用场景还挺多的, 比如:
			主服务器与从服务器的更新同步-> 主服务器更新, 从服务器直接强制跟着更新, 这种场景简单, 一般使用观察模式;

	subscription订阅模式:
		多对多的自选推送关系, 应用场景还挺多的, 比如:
			客户端有多个, 服务器也有多个, 客户端选择自己需要的service 进行订阅, 接受选定的服务器数据, 这种场景简单, 一般使用订阅模式;





3.observer观察者模式 & subscription订阅模式, 是OOP 还是SOA ?
	observer观察者模式 & subscription订阅模式, 一般是属于SOA;
	observer观察者模式 & subscription订阅模式, 一般适合描述多个应用, 不同设备之间的联动模式, 并不是一个单应用的程序设计, 
	OOP 面向对象设计, 一般用来描述单个程序的设计, 所以observer观察者模式 & subscription订阅模式, 一般不属于OOP;

	OOP 面向对象, 一般的最小粒度, 是类, 类封装, 适用于单程序设计;
	SOA 面向服务, 一般的最小粒度, 是service, 是app 应用群, 适用于程序群设计(可本机多程序, 局域网多程序, 广域网srv&cli);

	因此, observer观察者模式 & subscription订阅模式, 常见在SOA 设计中;





4.其他问题:
	* 推送丢失 & 接收签名问题
	* cache data缓存 & 高速响应设计
	* 推送格式问题(文本=json/xml, 数值=定制数据格式)
	...
	以上具体的问题, 交给MQ 框架解决, 这里不做过多叙述, 有兴趣可以查看具体每款MQ 的详细实现, 每种MQ 的解决方法都不一样, 这里不做细节描述,
	本节只谈设计模式;
*/
