

#获得所在文件夹的名字
GET_FILENAME_COMPONENT(FLODER_NAME ${CMAKE_CURRENT_SOURCE_DIR} NAME)

SET(PROJECT_NAME "${FLODER_NAME}")

#文件夹名作为工程名
PROJECT(${PROJECT_NAME} LANGUAGES CXX)

# 默认设置为debug 版本
IF(NOT CMAKE_BUILD_TYPE)
	#SET(CMAKE_BUILD_TYPE Release)
	SET(CMAKE_BUILD_TYPE Debug)
ENDIF()


#
# part2: cmake指导如何生成makefile
#
# 	声明编译过程所需的变量
# 	添加编译宏
# 	添加编译选项
# 	添加第三方源码库
# 	添加第三方头文件库
# 	添加第三方头链接库(.so / .a)
# 	第三方路径汇总
# 	添加链接选项
# 	添加编译target
#
# passed:
# 	至于编译过程: 
# 		预编译, 编译, 汇编, 链接; 这种过程控制, cmake就忽略不搞了.
# 		cmake本来就是自动生成makefile的. 不需要搞编译过程控制.











# 设置C++ 编译的参数(根据需要自己设置)
set(CMAKE_CXX_FLAGS "-o -Wall -g -lm -ldl  -DLINUX_OS  -fpermissive -pipe -fPIC -ffunction-sections ${CMAKE_CXX_FLAGS}")
# 使用一对双引号包裹的被认为是一个参数
# -Wall       :  编译时显示警告信息
# -O          : 选择编译器优化的级别, -O0 不优化  -O1 -O2 -O3 不同程度的优化
# -g          :  生成调试信息,debug会用到;调试信息的级别;-g3 
# 			    尽可能的生成gdb的可以使用的调试信息;默认为-g2;信息越多, 编译出的程序越大;
# -std=c++11  : 编译所按照C++的标准
# -fmessage-length=0 :输出信息会根据控制台的宽度自动换行, 这样就能看全输出信息了
# -fPIC       : 作用于编译阶段, 告诉编译器产生与位置无关代码
# 			    (Position-Independent Code);加载到任意位置都能执行
# -DTEST	 : 设置TEST的宏定义, 另外一种设置宏定义的方式可以直接使用 add_definitions(-D TEST) 添加
# -fpermissive  : 该选项会将不一致代码的诊断从错误降级为警告;








# cmake 包含检查Flag





# 显示'系统环境'变量
# 使用 $ENV{NAME} 指令就可以显示'系统的环境变量'的字符串了
MESSAGE(STATUS "PATH 路径: $ENV{PATH}")



#
# 查找宏(<VAR>条件变量 文件/库/文件夹/依赖程序)
# 找不到会自动中断'cmake 程序'.
# 解析:
# 	建立一个'条件变量<VAR>', 作为'FIND_*'系列查找宏的结果载体.
# 	将查找结果, 放到'条件变量<VAR>'中, 
# 	然后你需要IF(NOT <VAR>) or IF(<VAR>) 来判断下一步操作.
#
# *1.查找'文件'是否存在('path路径'必须指定具体文件名)
# FIND_FILE(<VAR> name1 path1 path2 ...)

# *2.查找'.a/.so 库文件'是否存在('path路径'必须指定具体文件名)
# FIND_LIBRARY(<VAR> name1 path1 path2 ...)

# *3.查找'文件夹'是否存在
# FIND_PATH(<VAR> name1 path1 path2 ...)

# *4.查找'程序bin'是否存在(证明该程序安装了,并且在/bin or /usr/bin 这种,可全局执行)
# FIND_PROGRAM(<VAR> name1 path1 path2 ...)

# *5.查找'模块'是否存在
# 用来调用预定义在CMAKE_MODULE_PATH下的Find<name>.cmake模块, 
# 你也可以自己定义Find<name>模块, 
# 通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中, 供工程使用.
#FIND_PACKAGE(<name> [major.minor] [QUIET][NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]])

# 示例：
# 查找./dynamic_lib/lib_dynamic.so 文件是否存在
FIND_FILE(isExist_lib_dynamic lib_dynamic.so ./dynamic_lib/)
IF(NOT isExist_lib_dynamic)
	MESSAGE(FATAL_ERROR "./dynamic_lib/lib_dynamic.so not found")
ENDIF()

FIND_FILE(isExist_static_lib static_lib.a ./static_lib/)
IF(NOT isExist_static_lib)
	MESSAGE(FATAL_ERROR "./static_lib/static_lib.a not found")
	#
	# 在CMakeLists.txt 中, ADD_EXECUTABLE() 不能用来执行一些未知的shell命令!
	# 这样是不被允许的, 这样容易产生恶意程序, 系统也不会允许的.
	# CMakeLists.txt,cmake中的ADD_EXECUTABLE()一般只有查询权限,可能没有'执行权限x'
	#
	#MESSAGE(STATUS "EXECUTABLE: g++ -c static_lib.cpp")
	#MESSAGE(STATUS "EXECUTABLE: mv ./static_lib.o ./static_lib")
	#MESSAGE(STATUS "EXECUTABLE: ar cr static_lib.a static_lib.o")
	#ADD_EXECUTABLE("g++ -c ./static_lib/static_lib.cpp")
	#ADD_EXECUTABLE("mv ./static_lib.o ./static_lib")
	#ADD_EXECUTABLE("ar cr ./static_lib/static_lib.a ./static_lib/static_lib.o")
ENDIF()

FIND_FILE(isExist_static_lib2 static_lib2.a ./static_lib/)
IF(NOT isExist_static_lib2)
	MESSAGE(FATAL_ERROR "./static_lib/static_lib2.a not found")
ENDIF()


# 查找/lib/x86_64-linux-gnu/libc.so.6 库是否存在(一般肯定存在,除非系统崩溃了)
FIND_LIBRARY(glibc_runtime libc.so.6 /lib/x86_64-linux-gnu)
IF(NOT glibc_runtime)
	MESSAGE(FATAL_ERROR "glibc_runtime not found")
ENDIF()



#
# cmake 文件读写操作指令:
#
# 写操作: 如果文件已经存在,则覆盖;如果不存在,则创建;
FILE(WRITE readme "All rights (are) reserved.\n")

# 追加操作: 在已经存在的文件最后, 追加字符串.
FILE(APPEND readme "adan_shaw@qq.com")

# 读操作: 以'文本格式'读取数据, 读取10个字符串, 从0位置开始
FILE(READ readme text10 10 0)
# 显示读取结果
MESSAGE(STATUS text10)
# 读操作: 以行读取的方式, 存储到变量list中. 一个list元素 = 一行字符
FILE(STRINGS readme line1)
# 显示读取结果
MESSAGE(STATUS line1)








# 定义一个变量(名为: target_name, 内容值为: "obj_out")
SET(target_name "obj_out")
# 设置生成目标<可执行文件>的'文件名'
PROJECT(${target_name})

# 显示项目主路径(即主CMakeLists.txt 所在地)
MESSAGE(STATUS ${PROJECT_SOURCE_DIR})


# 等待查找条件都安全通过后, 才指定编译安装make install路径为: ./build
# 这样做可以防止不必要的缓存生成.
SET(CMAKE_INSTALL_PREFIX "./build") 


# 包含-文件目录
#	 这个命令,可以将project的目录树关系描述清楚,
#	 但与ADD_SUBDIRECTORY()命令混用时, 需要注意几点:
#		 *1.如果你只使用INCLUDE_DIRECTORIES()命令, 那么被包含的文件中, 
#				不能存在'子CMakeLists.txt', 而是直接'裸奔文件夹+源文件'即可
#		 *2.如果你使用ADD_SUBDIRECTORY()命令,一个ADD_SUBDIRECTORY()命令包含一个文件夹,
#				一个文件夹必须有一个'子CMakeLists.txt'文件,描述子文件夹内部的情况.
#				而且,'子CMakeLists.txt'文件中,必须使用'二级INCLUDE_DIRECTORIES()'命令,
#				描述自身内部的情况.

# 路径指认错误的危害:
# INCLUDE()命令, 会因为INCLUDE_DIRECTORIES() 指认错误, 而无法工作.
# ADD_EXECUTABLE()命令同理!!


# 本层CMakeLists.txt 文件结构描述体
# (描述目录, 但目录中不能包含'二级CMakeLists.txt',只能有源文件+头文件)
INCLUDE_DIRECTORIES(
${PROJECT_SOURCE_DIR}/no_CMakeLists.txt_test/
${PROJECT_SOURCE_DIR}/static_lib/no_CMakeLists.txt_test/
.
)

# 添加包含'二级CMakeLists.txt'的dynamic_lib子目录
ADD_SUBDIRECTORY(dynamic_lib)
# 添加'二级CMakeLists.txt'static_lib子目录
ADD_SUBDIRECTORY(static_lib)


# 当前目录下所有源文件赋给DIR_SRCS
AUX_SOURCE_DIRECTORY(. DIR_SRCS)

# ****************
# 另外一种方法, 略
# ****************
# 变量指明, 所有的头文件
SET(SRC "../*.cpp")

# 变量指明, 所有的源文件
SET(HEAD "../*.h")

# 变量指明,所有的.o文件(如果你需要链接第三方的动态库,或者静态库,就需要对.o文件进行每个编译？)
# 你需要控制编译过程, 令每个过程编译, 都添加第三方编译库.
SET(TMP_O "../*.o")


# ***************************************************
# 暂时不用
# ***************************************************
# 包含其他CMakeLists.txt 文件 
# (无论那一种包含方式, 包含进行都是直接执行的, 这意味着: 
#	你不能重新定义一些全局宏, 如CMAKE_BUILD_TYPE 之类的, 
#	你只能在'子CMakeLists.txt' 中包含一些文件关联,
#	理清.cpp, .h 之间的关系而已, 意义不大. 
#	你可以通过下面的语句一次性解决. 
#	除非你的项目很大规模.)

# 以文件的方式包含'子CMakeLists.txt'
#INCLUDE(file ./dynamic_lib/CMakeLists.txt)

# 以模块的方式包含'子CMakeLists.txt',
# 这样你就可以在CMAKE_MODULE_PATH中搜索这个模块并载入
#INCLUDE(module ./static_lib/CMakeLists.txt)
# ps: 
#	 以上的'子CMakeLists.txt'实际上这个文件是空的, 
#	 只是展示如何进行'子CMakeLists.txt'包含操作而已.
# ***************************************************





# 设置可以生成的编译目标: release all install clean
SET(CMAKE_BUILD_TYPE "release")
SET(CMAKE_BUILD_TYPE "all")
SET(CMAKE_BUILD_TYPE "install")

# 不需要make clean, cmake 会自动生成 ??
# SET(CMAKE_BUILD_TYPE "clean")



# 生成Makefile后, 运行make test 来执行测试
ADD_TEST(test1 ${target_name} "fuck you 参数")
ADD_TEST(test2 ${target_name} "fuck you 参数2")
# 如果没有在'同一个'CMakeLists.txt中, 打开ENABLE_TESTING()指令,
# 任何ADD_TEST()都是无效的.

# 打开make test 开关
ENABLE_TESTING()



# 指定'编译选项'
#CMAKE_C_FLAGS					= CFLAGS
#CMAKE_CXX_FLAGS				= CXXFLAGS
#CMAKE_EXE_LINKER_FLAGS = LDFLAGS
SET(CMAKE_C_FLAGS "-O2 -std=c11")
SET(CMAKE_CXX_FLAGS "-O2 -std=c++0x")
SET(CMAKE_EXE_LINKER_FLAGS "-lpthread")

# 为目标Release 添加编译选项
SET(CMAKE_CXX_FLAGS_RELEASE "-Wall")
# 为目标All 添加编译选项
SET(CMAKE_CXX_FLAGS_All "-Wall -g3")
# 为目标Install 添加编译选项
SET(CMAKE_CXX_FLAGS_INSTALL "-Wall")



# 添加编译宏
# 指定使用gnu 编译
ADD_DEFINITIONS(-D_GNU_SOURCE)
# 指定禁用assert()
ADD_DEFINITIONS(-DNDEBUG)



########################################################
# 指定库文件路径
LINK_DIRECTORIES("./static_lib/" "./dynamic_lib/")

# 默认为生成静态库
# SET(BUILD_SHARED_LIBS ON)


# 添加'生成的链接库'的路径: #语法：ADD_LIBRARY(libname [SHARED|STATIC]
# 静态
#ADD_LIBRARY("./static_lib/static_lib.a" STATIC)
SET_TARGET_PROPERTIES(PROPERTIES OUTPUT_NAME "static_lib")
SET_TARGET_PROPERTIES(PROPERTIES VERSION 1.2 SOVERSION 1)

#ADD_LIBRARY("./static_lib/static_lib2.a" STATIC)
SET_TARGET_PROPERTIES(PROPERTIES OUTPUT_NAME "static_lib2")
SET_TARGET_PROPERTIES(PROPERTIES VERSION 1.2 SOVERSION 1)
# 动态
#ADD_LIBRARY("./dynamic_lib/libdynamic.so" SHARED)
SET_TARGET_PROPERTIES(PROPERTIES OUTPUT_NAME "libdynamic")
SET_TARGET_PROPERTIES(PROPERTIES VERSION 1.2 SOVERSION 1)

# 设置'生成的链接库'的信息
# VERSION：动态库版本
# SOVERSION：API版本
#SET_TARGET_PROPERTIES("./static_lib/static_lib.a" PROPERTIES OUTPUT_NAME "static_lib")
#SET_TARGET_PROPERTIES("./static_lib/static_lib.a" PROPERTIES VERSION 1.2 SOVERSION 1)


# 指认生成的target .exe 文件所需的.a/.so 链接库.
#TARGET_LINK_LIBRARIES(${target_name} static_lib.a)
#TARGET_LINK_LIBRARIES(${target_name} static_lib2.a)
#TARGET_LINK_LIBRARIES(${target_name} libdynamic.so)

#TARGET_LINK_LIBRARIES(main static_lib.a)
#TARGET_LINK_LIBRARIES(main static_lib2.a)
#TARGET_LINK_LIBRARIES(main libdynamic.so)

########################################################





# 10.执行CMakeLists.txt 自身编译
ADD_EXECUTABLE(${target_name} ${DIR_SRCS})
# 不能在CMakeLists.txt 中, 用ADD_EXECUTABLE() 执行一些未知的shell命令!
# 这样是不被允许的, 这样容易产生恶意程序, 系统也不会允许的.
# CMakeLists.txt,cmake中的ADD_EXECUTABLE()一般只有查询权限,可能没有'执行权限x'





