//fork_pool应用2:lua服务器设计思路:
/*
	小型游戏服务器, 可以这样做, 但需要做成异步模式;
	由于游戏服务器, 必然跑在公网上面, fork() 之后, 也需要做数据切片(同步模式, 容易数据传输终端);
	因此, fork()子线程发送socket 数据, 也必须是异步的;

	在这种模式下, fork() + select() + 全异步socket, 是最好的方案, 还支持跨平台;
	缓存使用redis, 做lua 机之间的数据互交渠道; [tcp 局域网]
	资料使用mysql, 跟lua 机进行数据互交;      [tcp 局域网]
	这样也可以组建一个小型业务系统, 而且可以用lua 来写业务, 安全性, 稳定性很高(崩溃互不影响);



	父进程:
		异步accept(), 使用select()+while()循环检查io 状态, 
		发现io 读事件, 马上fork(), 然后去执行其它任务, 消磨时间, 
		目的是让fork() 子进程取走accept() 客户端sfd, 再返回到select()+while()循环检查io 状态;
		* 消磨时间1: 打印日志, 每次接待client, 都打印日志;
		* 消磨时间2: 将进程pid添加到set<int> accept_check; 集合中, 然后返回到select()+while()循环了;

		实时消息64函数(父进程only):
			根据发来的子进程pid消息, 直接当成key索引删除accept_check中的元素;
			然后返回, 高速不停留;

		定时器消息[每5秒check一次](父进程only):
			* 任务1: 清空accept_check;



	fork()子进程:
		创建fork()子进程后, 第一时间异步accept()一次!!(如果客户端马上断开, 那这个fork()子进程马上结束);
		ps:
			做好任务划分, 父进程只做异步通知, 来了io事件, 说明client 已经在listen() 等待queue中了,
			此时fork()子进程只需进行一次accept(), 一定会命中的;
			如果fork()子进程没有命中, 那肯定是client 主动断开, 那此时, 你只需终结fork() 子进程即可;

		把自己的pid当成消息, 马上发送实时消息64给父进程;

		获取对方的ip+port, 打印日志;

		异步接收/发送网络数据(根据业务设计), 询问登录者验证信息等;

		验证通过后, 打印日志, 并开始装载lua 机;

		lua 机装载完毕后, 继续使用异步io 接收数据(业务数据用json包装),
		(接收数据时, 使用异步切片接收数据),
		收到数据后, 直接推入lua 机, do_string(), 调用唯一的解析json 业务数据函数;
		do_string() 会返回执行结果(也是json字符串数据), 
		将结果string, 直接切片发送给client;
		...

		如果客户端关闭, 释放lua机, 结束子进程, 打印日志;



	优缺点:
		这种服务器特点是简单, 安全, 崩溃互不影响;
		缺点, 不扛冲击, 面对而已洪水冲击, 资源创建释放量比较大(其实不大, 只要验证通过之后, 再创建lua机, 会好很多);
		但不失为一个优秀简易的游戏服务器架构;
*/
