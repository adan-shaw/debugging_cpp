//fork_pool应用1:简单的小型文件服务器设计思路:
/*
	简单的小型文件服务器, 根本不需要做成异步的, 同步即可, 局域网中使用;
	一旦做成异步的, 还要解决切片问题, 比较复杂, 难做;



	父进程:
		简单accept() 阻塞等待tcp 链接, 来任务了, 就将sfd fork() 出去, 
		然后由fork() 子进程检查路径的有效性, 
		然后sendfile();
		注意: fork() 的时候, 已经accept() 拷贝出sfd了, sfd 特性跟listen() sfd一致, 都是同步通信;



	fork()子进程:
		首先校验客户端请求的路径是否有效, 禁止'/' 字符, 防止恶意入侵, 
		如: ./../../* 这样攻击者就可以跳转到任意位置, 下载任意文件;
		仅让客户端访问'文件服务器.exe'所在的文件夹;

		禁止'.'字符, 防止对方摧毁了当前路径, 摧毁了父进程

		做一个简单的账户密码系统, 新建一个../config/account 的文件;
		不允许创建新用户, 统一由管理员自己手动修改account 文件, 一行账户, 一行密码;

		账户密码, 上传时, 使用aes 对称加密进行加密, 防止局域网监听, 截获账户密码;
		(下载文件时, 不能防止监听和截获)

		客户端请求文件名, 加aes 对称加密, 防止别人通过监听名字, 进行截获, 知道文件名, 就知道截获的内容了;

		响应请求, 如果文件存在, 先发md5 校验码; 如果文件不存在, 回复简易的报文;



	md5更新程序:
		新建一个小程序, 负责计算md5 校验码, 每次更新文件资源, 都执行一次md5 校验码更新;
		新建一个../config/md5 的SQlite3文件, 预先计算所有文件的md5校验码,
		开机就预装到map<string,string> 中, 直接省略md5计算过程, 节省时间;



	缺点:
		这种废物程序, 其实nginx/openresty, 直接就是文件服务器了, 性能还很强大, 直接用就行了;
		openresty 要实现上述功能, 简直易如反掌;
		所以, 这种工具毫无存在的必要, 初学者可以用来玩玩;

		单纯文件服务器, 直接使用nginx/openresty就是文件服务器, 根本不需要自己做;
*/
