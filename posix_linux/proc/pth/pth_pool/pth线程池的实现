//关于实现线程池pool
//(本文只讨论基于共享CLONE_VM 属性的线程/进程池的实现)
/*
	实际上, 实现怎么样的线程池, 具体要看业务需求;
	实时业务线程池, 分时业务线程池, 差异性很大;
	甚至, 单拿分时业务也说: 重数据流和轻数据流的线程池设计, 也有很大区别;

	因此, 没有那一种线程池, 是可以通用的, 具体不同业务, 就需要不一样的线程池, 这里只做个简单demo和分析;


	设计线程池的重点, 是根据:
		* 单次任务的计算时长(或者说操作时长), 
		* 是否允许抢占(优先权值), 
		* 是否有优先队列, 
		...
		等因素来决定的, 具体常见的问题有:
			* 群惊问题:		无论分时业务/实时业务, 都有群惊问题的困扰, 需要做到每次任务, 尽量少的唤醒worker线程;
			* 批量操作:		主要用在分时系统中, 在分时允许的情况下, 让单个线程一次处理几个任务, 提高线程利用率, 减少线程切换&&启动唤醒的消耗;
									(不过这样做需要业务支持, 数据io切片量大的业务可以考虑);
			* 线程检活:		分时业务/实时业务中都经常使用, 但实时业务检活汇报不会准时, 所以检活汇报如果要拿来作为重启线程的判断, 需谨慎;
			* 操作量统计:	统计线程接待任务的次数, 数据io总量, 存活时间, 起始时间, 休眠次数, 休眠时长等信息, 有助于后期维护, 调整业务;
			* io非阻塞:	线程池基本上都要使用io非阻塞, 因为一旦阻塞, 就会切换线程, 陷入休眠; 实时系统不允许切换线程, 分时系统切换线程也需要谨慎;
			* 抢占:			一般存在于实时系统中, 需要设置实时抢占权值, 才能实现抢占功能;
			* 优先队列:		任务队列中, 提供优先插入的操作, 实现优先队列(并不是通过构建两种不同优先级的线程实现优先队列);
			* 运行优先级:	worker线程的运行优先级, 绑定cpu 子内核等操作, 需要处理好, 提高线程池的效率;
			* 内核进程:		实时系统需要使用内核进程, 绑定轻进程, 提高优先级, 提高实时性;
*/
