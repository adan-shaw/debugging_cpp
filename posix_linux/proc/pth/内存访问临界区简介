//什么时候需要构建'内存访问临界区':
/*
	当多线程访问同一个变量, 而这个变量是非只读属性时, 就必须构建'内存访问临界区';

	无论是多线程只写, 还是多线程读写混合, 只要有写操作, 都必须构建'内存访问临界区';

	至于加mutex互斥锁, rwlock读写锁, spin自旋锁, 具体看需求;
*/



//构建临界区常见的锁的特性:
/*
	不同线程可以加锁, 抢锁;
	同一线程, 加锁一次, 就要解锁一次, 否则会陷入死锁, 永远不解开, 其他进程也没办法拿到资源, 一直阻塞;

	mutex互斥锁:
		加锁即互斥, 抢到锁就独占, 适合任意场合, 性能中肯, 但性能肯定比信号灯要优秀;
		一旦陷入阻塞, 线程挂起;

	rwlock读写锁:
		适合'读多写少的场合', 虽然提高了程序的复杂性, 但在'读多写少的场合', 可以提高程序的性能;
		当一个线程加了写锁时, 其他线程对该锁加'读锁/写锁'都会阻塞, 直到资源释放;
		当一个线程加了读锁时, 其他线程对该锁加写锁会阻塞, 加读锁则会成功(读锁可重复累加);
		一旦陷入阻塞, 线程挂起;

	spin自旋锁:
		实际上和mutex互斥锁一样的用法, 都是加锁即互斥, 抢到锁就独占;
		一旦陷入阻塞, 线程不会挂起, 死等(cpu 消耗巨大);
*/



//加锁的性能消耗分析:
/*
	加锁的API调用消耗:
		最慢的mutex互斥锁, 加锁操作实际耗时: 0.00005ms一次, 解锁0.00005ms一次, 一共0.0001ms;

	加锁阻塞等待, 造成线程切换消耗:
		一般在分时系统中, 这种消耗无法避免, 信号灯同样会面临这种问题,
		如果是超高性能的分时服务器程序, 可以考虑多用rwlock读写锁减轻负担;

		一般在实时系统中, 是需要用spin自旋锁的, 因为实时系统是不允许切换线程的;
		等待线程切换的时间成本较多, 切换线程, 重新抢占, 会消耗很多时间, 不符合'实时'原则;
		因此, 实时系统中, 实时调度策略, spin自旋锁, 用得很频繁;
		(交通系统, 实时的can, lin系统, 经常用)
*/



//无锁队列, 批量加锁, 频繁加锁的区别
/*
	无锁队列:
		当业务数据存在固定的一个生产者, 固定的一个消费者的时候, 
		使用无锁队列, 是性能最好的, 这样可以减少阻塞带来的线程切换, 无成本开销完成线程同步;(最优方案)
		缺点:
			应用场景有限;

	批量加锁:
		当有业务数据存在多个生产者, 多个消费者的时候, 这时候没办法避免加锁访问的时候,
		能用rwlock读写锁, 就用rwlock读写锁;		[从锁的性质上, 减少冲突阻塞的可能性, 减少线程切换的可能性]
		能批量操作, 就能批量操作;							(减少加锁次数, 减少冲突阻塞的可能性, 减少线程切换的可能性)
		批量操作, 是一种没办法中的办法, 也有一定用处;

	频繁加锁:
		最好想办法避免这种情况, 否则程序的性能不高;
*/



//double check if 在临界区中的妙用
/*
	G_test* pG_test = NULL;	//全局变量指针

	G_test* init(void){			//初始化全局变量的函数
		if(pG_test == NULL){
			lock();							//加锁
			if(pG_test == NULL)	//确认初始化之前, double check, 确保不会因为多线程竞争, 而导致创建多份资源
				pG_test = new G_test;
			unlock();
		}
		return pG_test;
	}
*/



//尽量使用原子操作, 减少编码语句, 减少加锁次数(c++ 编码优化原则)



