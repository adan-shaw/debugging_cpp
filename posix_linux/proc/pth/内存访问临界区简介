//什么时候需要构建'内存访问临界区':
/*
	当多线程访问同一个变量, 而这个变量是非只读属性时, 就必须构建'内存访问临界区';

	无论是多线程只写, 还是多线程读写混合, 只要有写操作, 都必须构建'内存访问临界区';

	至于加mutex互斥锁, rwlock读写锁, spin自旋锁, 具体看需求;
*/



//构建临界区常见的锁的特性:
/*
	不同线程可以加锁, 抢锁;
	同一线程, 加锁一次, 就要解锁一次, 否则会陷入死锁, 永远不解开, 其他进程也没办法拿到资源, 一直阻塞;

	mutex互斥锁:
		加锁即互斥, 抢到锁就独占, 适合任意场合, 性能中肯, 但性能肯定比信号灯要优秀;
		一旦陷入阻塞, 线程挂起;

	rwlock读写锁:
		适合'读多写少的场合', 虽然提高了程序的复杂性, 但在'读多写少的场合', 可以提高程序的性能;
		当一个线程加了写锁时, 其他线程对该锁加'读锁/写锁'都会阻塞, 直到资源释放;
		当一个线程加了读锁时, 其他线程对该锁加写锁会阻塞, 加读锁则会成功(读锁可重复累加);
		一旦陷入阻塞, 线程挂起;

	spin自旋锁:
		实际上和mutex互斥锁一样的用法, 都是加锁即互斥, 抢到锁就独占;
		一旦陷入阻塞, 线程不会挂起, 死等(cpu 消耗巨大);
*/



//加锁的性能消耗分析:
/*
	加锁的API调用消耗:
		最慢的mutex互斥锁, 加锁操作实际耗时: 0.00005ms一次, 解锁0.00005ms一次, 一共0.0001ms;

	加锁阻塞等待, 造成线程切换消耗:
		一般在分时系统中, 这种消耗无法避免, 信号灯同样会面临这种问题,
		如果是超高性能的分时服务器程序, 可以考虑多用rwlock读写锁减轻负担;

		一般在实时系统中, 是需要用spin自旋锁的, 因为实时系统是不允许切换线程的;
		等待线程切换的时间成本较多, 切换线程, 重新抢占, 会消耗很多时间, 不符合'实时'原则;
		因此, 实时系统中, 实时调度策略, spin自旋锁, 用得很频繁;
		(交通系统, 实时的can, lin系统, 经常用)
*/



//无锁队列, 批量加锁, 频繁加锁的区别
/*
	无锁队列:
		当业务数据存在固定的一个生产者, 固定的一个消费者的时候, 
		使用无锁队列, 是性能最好的, 这样可以减少阻塞带来的线程切换, 无成本开销完成线程同步;(最优方案)
		缺点:
			应用场景有限;

	批量加锁:
		当有业务数据存在多个生产者, 多个消费者的时候, 这时候没办法避免加锁访问的时候,
		能用rwlock读写锁, 就用rwlock读写锁;		[从锁的性质上, 减少冲突阻塞的可能性, 减少线程切换的可能性]
		能批量操作, 就能批量操作;							(减少加锁次数, 减少冲突阻塞的可能性, 减少线程切换的可能性)
		批量操作, 是一种没办法中的办法, 也有一定用处;

	频繁加锁:
		最好想办法避免这种情况, 否则程序的性能不高;
*/



//double check if 在临界区中的妙用
/*
	G_test* pG_test = NULL;	//全局变量指针

	G_test* init(void){			//初始化全局变量的函数
		if(pG_test == NULL){
			lock();							//加锁
			if(pG_test == NULL)	//确认初始化之前, double check, 确保不会因为多线程竞争, 而导致创建多份资源
				pG_test = new G_test;
			unlock();
		}
		return pG_test;
	}
*/



//尽量使用原子操作, 减少编码语句, 减少加锁次数(c++ 编码优化原则)



//CAS乐观锁 & lock()传统悲观锁 & 自旋锁 & 原子操作
/*
	CAS乐观锁:
		CAS 其实类似于自旋锁, 其实现的原理, 是程序逻辑上死等, 乐观地认为: 
			资源很快可以占用了, 所以死等一会, 消耗一点cpu死等, 功能与自旋锁差别不大;

	lock()传统悲观锁:
		互斥锁, 读写锁, 就是悲观锁, 一旦阻塞, 必然切换线程;
		切换线程也是一种消耗, 但cpu 功耗很低, 主要是线程切换后, cpu可以处理其他任务, 
		只要不是频繁切换, 在分时系统中, 这种切换是值得肯定的(实时系统肯定不允许切换的);

	自旋锁:
		自旋锁与CAS乐观锁, 都是死等锁, 不会切换线程的;
		性能, 自旋锁优于乐观锁; 跨平台性, 乐观锁优于自旋锁;

	原子操作:
		C11 C++11 新版本语言, 通过CAS乐观锁 + posix API, 实现逻辑上的原子操作;
		posix API的原子操作的实现, 已经不是什么新闻了, 早就有了, 例如: open(fd,"O_RDWR | O_CREAT")
		这种就是典型的posix API的原子操作;
		C11 C++11 实现了对变量类型的原子操作, 例如定义一个int 原子变量和定义一个CAS乐观锁:
			std::atomic_long tmp;	//int 原子变量
			std::atomic_flag lock;//CAS乐观锁
		这样多线程访问这个int 原子变量, 会自动通过CAS乐观锁进行逻辑加锁, 跨平台性能还很强;
		你也可以自己创建CAS乐观锁, 自己进行加锁(跨平台通用锁), C11 C++11允许你这样做;
*/



//乐观锁 vs 悲观锁, 谁更优?
/*
	在实时系统中, 因为业务需求, 悲观锁的使用比较少, 很多实时场景不允许使用悲观锁的, 
	因此, 这里只讨论分时系统中, 乐观锁 vs 悲观锁, 谁更优:
		如果乐观锁死等消耗的时间, 小于悲观锁切换线程所消耗的时间, 这时候乐观锁优(切换线程有一定消耗);
		如果等待的资源是一个int 变量, 毫无疑问, 乐观锁更优, 
			因为这是一个简单的内存变量, 陷入阻塞的时间基本上可以忽略不计, 这种情况下, 乐观锁更优, 毫无悬念;
		如果等待的资源是一个io 操作, 或者大型共有内存资源, 如等待某个类实体初始化完成, 
			这种情况下, 悲观锁反而可以提高系统整体性能, 并降低系统电能消耗, 悲观锁更优, 毫无悬念;
*/



//乐观锁 vs 自旋锁, 谁更优?
/*
	乐观锁与自旋锁, 实际用途都差不多, 都是通过死等来获取资源, 不同的是:
	乐观锁通过逻辑实现死等, 扩平台扩芯片性能强;
	自旋锁必须要有linux 内核支持, 或者unix 内核支持, 可能在跨平台方面, 自旋锁较差;

	性能上, 毫无疑问, 自旋锁占据优势, 因为自旋锁会减少很多预测分支的产生, 
	而乐观锁的实现, 有大量的if()和while(), 死等的实现, 产生了大量预测分支, 对cpu 造成极度不好的影响;

	相信编译器内部的实现, 提供乐观锁快捷接口, 也是为了解决预测分支的问题, 
	如果由编译器内部现实死等, 减少预测分支的产生, 乐观锁的性能也可以做到无限接近自旋锁;

	总结:
		一般情况下, 毫无疑问: 性能, 自旋锁优于乐观锁; 跨平台性, 乐观锁优于自旋锁;
*/
