//如何构建线程安全函数:
/*
	* 线程安全函数一般由local局部变量实现, 保证被访问的变量资源, 都是线程独占的;
		(线程从.exe程序段中, 读取逻辑代码, 局部变量都是copy 推入线程栈的,
		 所以线程安全函数, 逻辑区, 数据区, 都是只读的, 
		 数据区推入栈后, 就支持读写操作)

	* 线程安全函数的实现过程中, 一般不能使用全局变量, 静态变量, 非线程安全函数等非线程安全操作;

	* 如果一定要访问全局变量, 静态变量, 则需要加锁, 构建访问临界区;

	* glibc + posix 中的'非线程安全函数', 如rand(), gethostbyaddr() 等;
		在多线程的场合, 不能用这些'非线程安全函数', 而需要换成'xxx_r()'系列线程安全版;
		(一般这类'非线程安全函数', 都是使用了static 静态变量实现, 才会导致不安全的)

	* 'xxx_s()'系列线程安全函数, 是windows 特有的, 抛弃;
*/



//关于glibc + posix 中的'非线程安全函数'的实现差异:
/*
	SUSv3 并没有规定限制所有系统都需要将rand() 做成线程安全的, 因此rand_r()才是线程安全版本;
	事实上, unix/linux 对SUSv3 标准的实现, 都有差异;
	例如:
		在debian 系统里面, time(), asctime() 默认也是线程安全的.

	具体, 编码时, 你可以通过每个系统的man 手册, 查看详细差异;
	不过一般情况, 'xxx_r()'系列线程安全版, 是通用的;
*/



//当不存在_r() 版本函数的时候, 需要进行线程安全改造的时候, 需要怎样做? [这种情况其实很少的]
/*
	一般情况下, 你需要换一种思路, 尽量避免这种尴尬的情况;

	如果实在没办法, 一定要重新实现类似函数的时候, 优先考虑cas 锁(因为悲观锁会造成线程切换)
*/
