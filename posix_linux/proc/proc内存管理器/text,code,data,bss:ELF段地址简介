>>1. 何为全局变量? 
	在文件内, 函数外or 类外or 结构体, 枚举体等结构体外的"单量", 都是全局变量.

	访问其它.cpp 文件中的全局变量的方法:
		A.cpp 中的全局变量int ax;
		B.cpp 需要访问A.cpp 中的int ax,
		需要加extern int ax;声明, 表明:int ax; 是全局变量, 并且在其它.cpp 源文件中.

	全局变量存在<本文件内的>上下文关系, 同一个文件or 不同文件访问的时候,
	如果上文未定义就访问, 就会出现找不到全局变量.
	使用static 关键字可以无视<本文件内的>上下文关系.





>>2. 全局变量, 静态变量, 常量的区别.
	全局变量, 静态变量存放在同一区, 都是数据区, 数据区分为: .data or .bss
	'有初始化非0值'的全局变量/静态变量, 存放在 .data 数据区,
	'没有初始化, 或初始化为0'的全局变量/静态变量, 存放在 .bss 数据区,

	.bss 区并不会实际分配二进制空间到.exe程序的ELF封装中, 
	而是程序运行的时候, 由操作系统, 动态分配RAM内存, 并初始化为0.
	所以, 未初始化的全局变量/静态变量, 可以一定程度上节约.exe程序, 内存空间.

	常量存放在only read 只读代码区.





>>3. <应用程序>二进制.exe可执行代码的ELF布局结构:
	头:
		(正文区)only read 只读代码区, 常量区.
		< code segment/text segment >
		一般计算机程序会有一个代码区为只读, 防止程序逻辑被恶意篡改.
		常量区也是只读的, 你可以通过const 关键字来设置只读变量.
		(正文区)会被装载到运行内存中, 你运行二进制程序,
		必须要装载(正文区)到内存中, 知道程序结束都不会被释放.


	数据区:(.data/.bss 都是属于数据区)
		.data 是已经初始化非0 的全局变量/静态变量,
		会被封装进.exe二进制程序中, 连同.exe一起装载进内存, 然后开始执行程序.
		.data 同样可读可写--(data segment)

		.bss 是程序运行之后, 由操作系统分配, 并初始化为0 的全局变量/静态变量数据区,
		并不会写入.exe二进制程序里面, 
		.bss 同样可读可写--(bss segment)


	进程堆:
		所有new or malloc 的指针内存, 都是堆上面动态分配的, 
		只在进程内部保留一个堆表二叉树

		堆内存实际是自动增长的, 一般有进程堆内存限制(软限制),
		最大可达到系统最大内存(硬限制)

		堆内存的申请, 释放, 接受ptmalloc 管理.

		一个进程只有一个堆


	线程栈:
		所有局部变量,{} 函数内的变量, 
		在函数调用的时候, 都会被压入线程栈.
		所以, 当执行<大量递归操作>调用的时候, 会导致线程栈内存被挤爆而溢出.
		同样的, 在一个函数里面放一个巨大的局部变量数组, 也会挤爆线程栈.

		线程栈默认8MB(linux为例), 初次递交8KB.

		线程栈的存放位置, 之所以放在内存片区的后面(高位片区,不能向后增长), 主要是因为:
			第一: 因为线程是一种后发明的产品, 90年代以前都没有多线程的CPU,
					 进程先入为主, 占据了优先位置.
			第二: 因为一个进程只有一个堆, 而线程可以有很多个, 
					 而且线程栈的大小固定, 不会动态增长, 分配内存区域容易,
					 所以, 放在后面(高位片区)方便系统管理内存, 把拓展空间留给进程.





>>4. static 衍生出来的变量定义用法:
	静态局部变量(静止变量):
		一般是指函数内的静态局部变量, 用来节约内存, 减少推栈, 增强程序性能的骚操作.
		(注意: 一旦函数内部定义了'静态局部变量', 这个函数就不再是线程安全函数了)
		因为'静态局部变量'的存放位置'.data/.bss', 是线程共享的.

	静态全局变量/静态函数:
		不可以用extern 引用, 单个.cpp 文件内有效;
		不同.cpp 文件之间, 允许出现同名同类型的'静态全局变量/静态函数',
		(也就是'静态全局变量/静态函数'想对于每个.cpp文件之间, 是相对私有的)

	类容器中的static:
		本质上还是一样的, 在类中也改变不了static 关键字的本质




>>5. const常量, 数字-char,数值-int,double... 常量: 
	* 可以用来防止数据被篡改
	* 可以节省内存, 对于只读数据设置为常量, 只需要一份存储空间即可.(常量只读,不可写)

	# 非频繁使用的常量数据, 用完可以释放的, 还是定义为变量比较好,
		因为用完就释放, 可以节省内存.





>>6. 局部变量: 
	{} 函数内的变量, 都是局部变量, 运行的时候会被压栈,
	函数返回时会被清栈返回,
	函数返回的指针, 不可以指向局部变量, 否则会内存越界崩溃的.





>>7. 函数: 
	函数本身就是一个全局变量指针, 本身就支持extern 引用, 
	关键是<本文件内的>上下文问题.

	如果有需要隐藏某个函数, 
	可以加一个static 解决其他.cpp冲突问题, 只允许<本.cpp文件内>上下文引用





>>8. 存储说明符auto, register, extern, static:
	auto: 默认-存储说明符号, 自动分配默认存储空间.

	register: 寄存器-存储说明符号, 命令将变量存储到cpu寄存器.

	extern: 外部-存储说明符号, 说明该变量在其他.cpp文件中有声明, 
					一般是指示gcc 编译器找到变量, 并不会实际分配内存空间

	static: 静态存储-存储说明符号, 将变量存储到'.data/.bss'区,
					并且指示gcc 编译器, 该变量只在当前.cpp文件中可用





