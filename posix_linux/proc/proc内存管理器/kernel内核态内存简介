//
//什么是内核态内存, 为什么要用内核态内存?
//
/*
	要弄清楚内核态内存的用途, 你就要明白内核态的程序,
	内核态内存, 就是供给Linux 内核子模块用的.

	linux内核子模块(驱动程序)一般是单进程的, 也类似于守护进程, 驱动程序就是守护程序.
		1.内核态程序有两种:
			linux 内核子模块虽然是.ko 封装, 即动态共享链接库的形式.
			但是实际上, 这内核子模块程序, 也分两种:
				* 第一种是, 只提供runtime 库API 支撑的, API 库型内核子模块
				* 第二种是, daemon 程序式的内核守护进程, 
									 这种内核态daemon程序,一般有守护程序,也有runtime库API支撑层.

		2.内核态内存, 主要就是给'daemon 程序式的内核守护进程'用的.
			虽然内核态'runtime库API支撑层', 也会用到内存.
			但是跟普通的.so 库一样, 动态链接库一般不会创建动态内存, 
			而基本都是可以保证线程安全的常量内存,
			如果一定要申请动态内存, 那必须要求程序员自己将动态内存指针, 传入该API,
			这也是.so 库的设计原则.
*/





//
//内核态内存的特点(kmalloc & vmalloc)
//
/*
	1, 内核态内存, 不受ptmalloc 约束, 没有内存重用.

	2, vmalloc分配的一般为高端内存, 只有当内存不够的时候才分配低端内存; kmallco从低端内存分配.
	3, vmalloc分配的物理地址一般不连续, 而kmalloc分配的地址连续, 两者分配的虚拟地址都是连续的;
	4, vmalloc可以分配大块内存, 而kmaooc一般分配的为小块内存, (一般不超过128k);

	5, kmalloc和vmalloc是分配的是内核的内存, malloc分配的是用户的内存
	6, kmalloc保证分配的内存在物理上是连续的,
		 内存只有在要被DMA访问的时候才需要物理上连续, 
		 malloc和vmalloc保证的是在虚拟地址空间上的连续

	7, vmalloc比kmalloc要慢. 
		 尽管在某些情况下才需要物理上连续的内存块, 
		 但是很多内核代码都用kmalloc来获得内存, 而不是vmalloc. 
		 这主要是出于性能的考虑. 
		 vmalloc函数为了把物理内存上不连续的页转换为虚拟地址空间上连续的页, 必须专门建立页表项. 
		 糟糕的是, 通过vmalloc获得的页必须一个个地进行映射, 
		 因为它们物理上是不连续的, 这就会导致比直接内存映射大得多的TLB抖动, 
		 vmalloc仅在不得已时才会用(典型的就是:为了获得大块内存时才用)
*/





//
//DMA与内核程序的作用
//
/*
	1.简单介绍DMA与内核内存的关系:
		在设备驱动程序或者内核模块中动态开辟内存, 不是用malloc, 
		而是kmalloc ,vmalloc, 释放内存用的是kfree,vfree, 
		kmalloc函数返回的是虚拟地址(线性地址). 
		kmalloc特殊之处在于它分配的内存是物理上连续的, 这对于要进行DMA的设备十分重要. 
		而用vmalloc分配的内存只是线性地址连续,物理地址不一定连续,不能直接用于DMA. 

	2.DMA工作:
		为了减少CPU对快速设备入出的操作, 
		可以通过把这批数据的传输过程交由一块专用的接口卡(DMA接口）来控制, 
		让DMA卡代替CPU控制在快速设备与主存储器之间直接传输数据, 
		其大概工作的机制是在DMA模式下, CPU只须向DMA控制器下达指令, 
		让DMA控制器来处理数据的传送, 数据传送完毕再把信息反馈给CPU, 
		这样就很大程度上减轻了CPU资源占有率. 
*/





//
//API list(参数详情, 请看: ./web网文/用户态和内核态的内存分配.html)
//
void *kmalloc(size_t size, gfp_t flags)
void *vmalloc(unsigned long size)

void *kzalloc(size_t size, gfp_t flags)
void *vzalloc(unsigned long size)

void kfree(void* p)
void vfree(void* p)
