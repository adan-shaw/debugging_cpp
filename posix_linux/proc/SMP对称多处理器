SMP对称多处理器简介:
	SMP对称多处理器结构, 英文名称为"Symmetrical Multi-Processing", 简称SMP;
	SMP又称为UMA, 全称"Uniform Memory Access", 中文名称"统一内存访问架构";

	在"对称多处理器结构"的系统中, 所有的CPU处理器的地位都是平等的, 
	一般指的是服务器设备上, 运行的多个CPU, 没有主次/从属关系, 都是平等的;

	所有的资源对处理器具有相同的可访问性:
		这些CPU处理器共享同一系统中的所有设备资源, 如: 磁盘, 内存条, 主板总线, 网卡等;
		多个CPU处理器共享相同的物理内存, 每个CPU访问相同的物理地址, 所消耗的时间是相同的;





SMP对称多处理器优缺点:
	SMP服务器的主要特征是:
		系统中所有资源(CPU 、内存、 I/O设备等)都是共享的

	也正是由于这种特征, 导致了SMP服务器的主要问题, 那就是它的扩展能力非常有限; 
	对于SMP服务器而言, 每一个共享的环节都可能造成SMP服务器扩展时的瓶颈, 而最受限制的则是内存; 

	由于每个CPU必须通过相同的内存总线访问相同的内存资源, 
	因此随着CPU数量的增加, 内存访问冲突将迅速增加, 
	最终会造成CPU资源的浪费, 使CPU性能的有效性大大降低; 
	实验证明, SMP服务器CPU利用率最好的情况是2-4个CPU; 
	否则会因为内存访问冲突, 造成性能内耗过大, 导致系统整体性能暴跌;

	SMP 频率越高, 访问内存冲突的机率越大;
	SMP 核心越多, 访问内存冲突的机率越大;
	低频CPU, 使用SMP 共享资源的容纳量更大;
	高频intel cpu, 使用smp 共享资源的可能性更低;





'SMP对称多处理器&&linux系统'联合屏蔽底层差异, 对应用层友好:
	linux 系统会自动屏蔽SMP 系统的硬件, 实现一视同仁;
	所以实际上, 单个物理主机上, 有多少个intel 处理器, 实际上都不影响其性能(只是内存冲突会增加);
	SMP 多处理器, 跟SMP 单处理器多内核, 并没有任何差异;
	直接通过setaffinity线程绑定cpu内核, 控制进程任务跑在指定内核上即可,
	这种智能化控制, 是linux 内核的优势所在;
	(其他系统可能没有这种控制方案)





'SMP对称多处理器'其他小问题:
	smp 抢占, 一定要使用自旋锁??
	smp 共享资源, 一定要使用自旋锁??
	答:
		废话, 但凡是抢占, 都使用死等CAS 锁和自旋锁, 跟SMP无关;
		单CPU 怎样运行程序, SMP 就怎么样运行程序, 无差异, 无须怀疑;
		唯一需要注意的是:
			linux 管理线程资源, 是以进程为单位的;
			但由于linux 并没有真正意义上的线程, 
			所以其实在linux上, pthread 线程也是进程, 也可以通过setaffinity线程绑定cpu内核,
			所以, 实际上, 毫无差异, 不用担心;
			有差异也是内核层的事情, 应用层不用担心的, 只有编写内核子模块程序, syscall 的时候, 才能看到差异;


	SMP的缺点是内存访问冲突, 导致系统性能暴跌, 那么在线程同步时, CAS锁, 是总线锁, 是否有影响?
		答:
			CAS锁就是逻辑循环锁, 阻塞循环, 只是不切换线程而已;
			CAS无权锁住系统总线, 更不可能锁住主板通信总线(否则就不是线程卡死, 整个系统都卡死, 有可能么?)

			所以,CAS锁最大限度, 就让一个CPU罢工而已;(自旋锁也一样)


	SMP 共享内存, 但也有区别:
		同一个cpu内核之间, 共享3 级缓存; 单个cpu内核, 享有2级缓存; 每次线程切换, 冲刷一级缓存;(以intel为例)
		多个cpu的情况下, cpu 内部的缓存不共享, 只共享系统内存(即内存条上的内存);


	arm-cpu 里面的大核,小核,AI核, 是SMP 结构的?
		绝对是异构的:
			AI核负责浮点计算, 浮点运算增强架构;
			小核和大核也是异构的, 没准小核有DSP 指令集, 专门解析波形数据, 如声音, 无线电;
			大核一般就是arm 普通逻辑, 跑程序的, 高性能内核;

		还有显卡呢, 显卡GPU, 虽然所有ARM 芯片都是共享显存的,
		但这其实也是异构cpu, 又一个异构cpu;

	最终, 手机芯片公司, 将这些模块全部打包一起, 组成一个模组进行出售;


	有任何调度的问题, 看看: SMP CPU调度,用于多道程序.html


	只有主从cpu 编号之分, 没有其它特点, 不要傻逼怀疑;


	io 操作只折腾0号cpu ??(这个有待确定):
		小型芯片如arm, 可能内核层的实现, 是这样;
		大型芯片如intel, 不可能'只折腾0号cpu'?? 否则这么繁忙的io 操作, 肯定会有问题的;
		如果不放心的话, 绑定cpu 的时候, 不要绑定到0 号cpu上面就行, 尽量避开0号cpu;





