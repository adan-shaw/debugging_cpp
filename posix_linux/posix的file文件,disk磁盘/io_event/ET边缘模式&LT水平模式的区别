//ET 边缘模式
/*
	当'io事件通知'到来时, select/poll/epoll 调用'io事件查询操作'时, 
	只通知一次, 无论你取不取走'io事件通知', 一律都将该'io事件通知'从'io事件集合'中删除;
	这种一次性通知的'io事件'模式, 就叫'ET 边缘模式';
	('ET 边缘模式'一般都用在异步fd 中)

	如果你忽略了一次'io事件通知', 
	那么下一次'io事件通知'到来的时候, 你可能读取的是上一次'io事件通知'发来的数据;
	这里面会有'io事件通知'顺序错乱, 粘包, 数据取到手后, 如何连续处理两次'io事件通知'的各种问题;

	好处:
		性能好, 程序逻辑消耗小, io吞吐量大, 并发量大;

	缺点:
		容易发生io 顺序错乱, 粘包, 甚至是socket 缓冲区溢出, 数据被覆盖;
		(tcp 会自动保证socket 缓冲区不会溢出, 
		 当socket 缓冲区满了的时候, 还会通过协商, 让客户端停止再发数据, 防止socket 缓冲区被覆盖,
		 但仍然会有io 顺序错乱, 粘包等问题)

		必须一次读取所有数据, 读到没有'io事件通知'为止;('接收缓冲区'需要动态长度,未知长度的)

	注意:
		'ET 边缘模式', 应该要保证fd 是非阻塞操作的,
		否则, 一旦你用write()/read()/recv()/send() 等函数, 循环接受数据, 会陷入长时间的阻塞,
		直到下一次'io事件通知'的到来, 程序都陷入阻塞, 这是不允许的;
*/



//LT 水平模式
/*
	当'io事件'到来时, select/poll/epoll 调用'io事件查询操作'时, 
	'io事件通知'会一直存放到你执行了'io操作', 
	kernel 内核层消灭了这个'io事件通知', 那select/poll/epoll 才不会再通知该'io事件通知';

	如果你忽略了一次'io事件通知',
	那么下一次'io事件通知'到来的时候, 
	仍然是上一次'io事件通知', 操作的仍然是上一次'io事件产生的数据';

	好处:
		io 有序, 数据有序, 数据丢失的可能性低一点(但udp 模式下, 仍然有可能会被冲掉socket接收缓冲区)

	缺点:
		性能开销大;
*/



//select/poll/epoll 都使用了什么模式
/*
	select/poll 都是'LT 水平模式'的, 
	只要'io事件'没有被操作消除, 就会一直通知, 直到进行io操作, 'io事件通知'才会被消除;
	('LT 水平模式'下, 也可以用在fd 异步模式/同步阻塞模式下)

	epoll 可以做'LT 水平模式', 也是唯一可以执行'ET 边缘模式'的'io事件通知'模型;
	('ET 边缘模式'一般只用在fd 异步模式下)
*/



