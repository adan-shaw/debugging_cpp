文件锁的用途:
	对运行的.exe 文件进行加锁, 可以防止.exe 运行过程中, 被人篡改数据;
	这个办法可以防止:
		dll 注入, 恶意代码注入, 修改.exe 程序破解, 等手段;
		运行前对.exe 进行md5 完整性校验;
		运行过程中, 对.exe 文件进行上锁, 独占, 防止被篡改;

	该方法, 也可以用在dll/.so 等运行时库中(动静链接库);

	该方法, 也可以用来防止.exe 打开了两个程序, 也可以用来保证.exe 的唯一性;

	一般使用flock() 强制锁, 比较有效;





文件锁的类型, 大概有两种:
	*1.劝戒锁(进程内可以多次加锁, 多次释放锁, 但多进程间不能仍然共享, 线程可共享)
		fcntl()			行-劝戒锁
		flockfile()	整个文件-劝戒锁
		什么是劝戒锁?(也叫建议锁)
			劝戒锁就是, 你询问可不可以加锁, 内核会给你一个建议.
			你可以遵守这个建议, 选择操作, 或者不操作.
			你也可以不遵守这个建议, 不管冲突, 直接操作, 直接写盘.
			但是冲突产生的数据误差, 你自己负责.

	*2.强制锁(线程也不能共享, 一次加锁, 一次释放, 十分严格)
		flock()			整个文件-强制锁
		什么是强制锁?
			强制锁就是独占锁;在释放锁之前,其它进程/线程都不能使用,与互斥锁类似



文件锁api:
	1.用fcntl()对文件加锁,可以对文件的部分内容行加锁,这里称之为'行锁';
		fcntl() 加锁时, 需要输入起始位置, 终止位置.
		如果对整个文件进行加锁, 你还要获取整个文件的长度;
		起始位置=0, 终止位置=文件结尾处.

	2.用flock()对文件加锁,无论文件实体对应有多少个fs 文件描述符派生,
		统一锁死整个文件使用权, 给当前调用者fs, 是一种独占锁.

	3.用flockfile()对文件加锁,实际只能锁住该'fs 文件描述符'的使用权,
		如果该文件有其他'fs 文件描述符', 就不适合使用flockfile(),
		否则会有竞争冲突!!(race condition).
		但真实应用场景中, 一个文件也不应该有2个fs 文件描述,
		尤其是同一个进程内, 更不应该有2个fs 文件描述,
		有2个fs 文件描述, 一般是多进程共享一个文件的情况, 应该上强制互斥锁.
		注意:
		3.1:
			flockfile()加锁, 只是会在使用者lockcount中增加1;
			funlockfile()释放锁, 只是会在使用者lockcount中减少1;
			ftrylockfile()则是nonblocking版的flockfile(),
				询问内核加锁建议.
		3.2:
			内核会为每个flockfile()锁维护一些支撑数据,
			就算funlockfile() 看上去没啥作用, 但是用完锁一定要释放!!
			否则内存可能会出现膨胀不止!!内核维护flockfile()锁的内存不断膨胀
		3.3:
			flockfile()锁, 是锁'整个文件'的.
			如果单次读写的数据长度不大, 那么可共享性就很强了,
			如果单次读写的时间过长, flockfile()锁也会阻塞很久.
			flockfile()锁的数据安全, 由程序员保证.
			不遵守加锁建议, 强行写盘/读盘, 导致的后果由程序员自己承担.(未知风险)
			所以,既然有必要'要加flockfile()锁'的话, 就要遵守建议规则.
		3.4:
			flockfile() 锁的用途:
			flockfile() 锁实际适合'多线程'共享"读和写"的场合.
			共同写, 共同读, 在单一进程内, 多线程的情况, 都不需要加锁.

			共同写有顺序差别, 不知道哪个线程先, 哪个线程后,
			但是加锁也不能解决这个问题, 如果是'多线程共写', 不会读写冲突就行了.

			共读, 更简单, 没有写操作的话, 怎样读都行.





你要明白, 为什么要加锁?
并发读, 随意, 乱来都行.
并发写, 也随意, 乱来都行, 控制好文件流就可以了.

多进程读, 多进程写, 就是问题了, 因为不能共享FILE流.

读写冲突时, 数据的准确性有很大的问题, 
就算是多线程, 也需要上强制锁,
多进程则直接锁住FILE流比较好.


FILE流有读写缓冲区buf,
flockfile 是锁住一个FILE* io 流, 也就是锁住io缓冲区;
flock 却是锁住文件实体;
fcntl 应该也是锁住io 流, 因为fcntl 本身就是对FILE* 负责的;
(fcntl 可以做到行锁, 更精确一些)



文件描述符fd:
	控制访问, 权限, 存放位置等信息, ioctl(), 实写同步io
	无缓冲区可言, 直接冲写到磁盘, 加锁必须是整个文件加锁, 强制锁.

流描述符FILE*:
	IO 缓冲控制, 缓冲池定位, 缓冲区大小等, 也可以加缓冲锁, 即IO 流锁.
	其'实现方式', 是锁住FILE流结构体



