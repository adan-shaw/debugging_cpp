//1.Atomic operation原子操作的需求示例(试图以独占方式打开文件):
/*
	注意:
		原子操作, 绝对不能分开两次打开文件,这个案例只是用来说明'原子操作'需求案例.

	//第一次以独占的方式'打开文件', 假设文件已存在
	fd = open("", O_WRONLY);
	if(fd != -1){
		//文件已存在, 直接打开使用.
		;
	}
	else{
		if(errno != ENOENT){
			//open() api意外失败, 失败原因是:
			;
		}
		else{
			//如果不是open() 函数api 的问题,
			//则第二次尝试以创建式独占的方式, 打开文件, 不存在则创建新文件.
			fd = open("", O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);
			if(fd == -1){
				//open() 创建式独占打开文件意外失败, 失败原因:
				//很多情况是进程没有'创建文件的权限'.
			}
		}
	}

	上面的程序的意图是:
	第一次先检索文件是否存在, 不存在则创建, 再打开.
	但open()1 和open()2 之间, 有那么一瞬间,
	'文件的操作权'有可能被抢占, 导致open()2 仍然会失败.

	但原因却是: 文件被占用.opem()1 就是为了防止文件被抢占而写的,
	那么, 实际上open()1 语句的存在意义, 就没有实用意义了.

	所有拆分语句, 如果拆分的时候, 不是原子性的话, 就会出现上述的问题.
	原子操作, 就是用来解决分拆操作时, 可能出现的资源被抢占的问题.
	所以原子操作, 一定不能拆分来写.
*/





//2.简述原子操作
/*
	open("",O_WRONLY | O_CREAT | O_EXCL)
	O_WRONLY | O_CREAT | O_EXCL 就是一种<原子操作>,
	意思就是: 独占|不存在自动创建|存在马上打开

	提供类似: O_WRONLY | O_CREAT | O_EXCL 的操作, 就叫<原子操作>


	但其实你不用担心太多, 例如lseek() and read() 先移动再读,
	只要你是以O_WRONLY 独占方式打开的话, 问题都不大.

	但fd 文件描述符, 在进程内是共享的,
	多线程肯定要对fd 文件描述符<加互斥锁>, 其它问题都不大.

	但总的来说:
		pread()这个原子操作api的就比分拆的lseek() and read()好
*/


