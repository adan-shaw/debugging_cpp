#
# 1.栈分配 vs 堆分配简介
#
栈分配的软件优势: 
	栈分配算法简单, 所以高效;
	栈分配的硬件优势, 主要两点: cache and 内存映射.

	堆分配算法相对比较复杂. 


如果在栈上分配小块内存, 因为cache和内存映射已经建立, 则效率会非常高, 远远优于堆分配. 
如果在栈上分配大块内存, 在不考虑爆栈的情况下, 其实两者效率差不到哪去. 
	因为cache命中和内存映射总是在'有限的大小'进行的, 
	其在栈中分配的大块内存照样cache不命中, 
	而且映射未建立, 所以这样的时间相差其实并不太多.



堆分配的弱点:
	1.分配和释放, 堆在分配和释放时都要调用函数(MALLOC,FREE), 
		比如:
			分配时会到堆空间去寻找足够大小的空间(因为多次分配释放后会造成空洞), 
			这些都会花费一定的时间, 
			具体可以看看MALLOC和FREE的源代码, 他们做了很多额外的工作, 而栈却不需要这些.

	2.访问时间, 访问堆的一个具体单元, 需要两次访问内存, 
		第一次得取得指针, 第二次才是真正得数据, 而栈只需访问一次. 
		另外, 堆的内容被操作系统交换到外存的概率比栈大, 栈一般是不会被交换出去的. 

综上所述, 站在操作系统以上的层面来看, 栈的效率比堆高. 





#
# 2.栈快, 以下原因: 
#
1.栈有专门的寄存器, 压栈和出栈的指令效率很高.

	堆需要由OS动态调度, 堆内存可能被OS调度在非物理内存中, 
	或是申请内存不连续, 造成碎片过多等问题. 

	另外, 分配方式上, 堆都是动态分配的, 栈是编译器完成的. 
	栈的分配和堆是不同的, 他的动态分配是由编译器进行释放, 无需我们手工实现


2.由于栈和堆使用的都是用户空间的虚拟内存, 而且你说那个用法是作为函数参数, 通过指针引用. 
	非要说有区别, 可能是第一次访问该内存的时候有可能更快些, 
	理由是:
		当你调用函数是, 只想的栈内存一定已经加载到物理内存里面了, 
		页表也已经建好了(在该页没有被置换出去的情况下);
		指向堆的内存不一定已经映射到物理内存, 因此需要处理缺页, 建立页表. 
	至于指向的内存都已经加载到物理内存的情况, 应该没有区别. 


3.栈内存更快, 栈是和代码段一同被载入到CPU内存中的, 
	用C写得程序在被编译成机器指令之后, 同一个函数栈上的变量会被保存在寄存器中的, 
	并且栈上的内存基本上都是在编译的时候就确定了得, 
	由于CPU的运算原理明显依赖寄存器的, 
	所以栈上的内存访问速度明显比堆上快, 
	现在CPU的设计一、二级缓存的大小已经最后栈内存的使用, 所以效率明显要高很多, 
	而堆上的内存由于和函数栈不在同一个地址段, 
	所以堆上的内存很有可能不在寄存器或者CUP缓存中, 访问命中率就低, 
	同时效率也就会低很多, 因为要出发好多系统内核调用, 内存需要从硬盘到内存到CUP缓存再到寄存器. 


4.栈效率更高, 因为堆分配分配了之后还要与存储器之间建立映射, 而栈分配则是之前就建立好了. 





