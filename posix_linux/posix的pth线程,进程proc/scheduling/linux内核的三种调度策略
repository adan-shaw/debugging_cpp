//linux内核的三种调度策略:
/*
	SCHED_OTHER		分时调度策略(默认的)
	SCHED_FIFO		实时调度策略,先到先服务
	SCHED_RR			实时调度策略,时间片轮转

	等待io 资源(io 阻塞), 一定会被扔进等待队列, 释放使用权;
	sleep() 系列函数, 同样会自动释放使用权, 等同挂起;

	实时进程vs分时进程:
		实时进程将得到优先调用(比分时进程有更高级的优先权)

	实时进程:
		根据实时调度权值, 决定运行优先级(需要设置的)

	分时进程:
		通过nice和counter值决定权值, 权值计算公式:(counter+20-nice)
		nice越小(负值), counter越大, 被调度的概率越大;
		nice越小(负值), 时间片越长, cpu占用时间越长;
		nice 值:
			每个进程手动设置;
		counter 值:
			每次'就绪队列'中选择一个任务执行, 被选中的任务, 执行完之后, counter就会被重置为0;
			没有被选中的任务, counter += 1;
			使用了cpu最少的进程, counter值会越来越大, 强得cpu使用权的权值, 也会越来越大;
			一旦抢到使用权, 使用结束后, counter=0;
			counter 值越大, 被执行的概率越大, 但不影响进程本身拥有的时间片大小;



	SCHED_RR 实时分片模式, 现在禁止修改分片细节了;
	struct sched_param{} 结构体, 只剩下一个int 实时权值了, 细节全部不让改了;

	SCHED_RR 相当于高级一点的SCHED_FIFO 模式,
	即同级权值, 可以均衡分配时间片;
	SCHED_FIFO 是先到先得, 同级继续抢占, 直到自己主动挂起/陷入io阻塞/高级权值抢占;
*/



//实时调度SHCED_RR和SCHED_FIFO的不同: 
/*
	SHCED_RR策略:
		进程的时间片用完, 系统将重新分配时间片, 并置于'就绪队列'尾;
		把进程放在'就绪队列'尾, 是为了保证所有具有'相同优先级的SHCED_RR任务'都得到公平的调度;
		'不同优先级的SHCED_RR任务', 哪怕优先级只高了1, 都会永远优先执行;

	SCHED_FIFO策略:
		一旦占用cpu则一直占用, 直到有更高优先级任务到达, 或自己挂起进程(放弃使用权)


	如果有相同优先级的实时进程争夺cpu使用权:
		SHCED_FIFO:
			先占用者继续占用, 直到该进程主动放弃后, 才能抢占(原来的先到先得, 除非优先级更高);
		SHCED_RR:
			可以让同等级, 甚至不同等级的任务都执行一段时间;


	SHCED_RR/SHCED_FIFO的相同点:
		RR和FIFO都只用于实时任务;
		创建时优先级大于0(1-99): Linux allows the static priority range 1 to 99 for the SCHED_FIFO and SCHED_RR policies
		都按照可抢占优先级调度算法进行;
		就绪态的实时任务, 会立即抢占非实时任务;(实时优先)
*/



//当所有任务都采用分时调度策略时(SCHED_OTHER)
/*
	1.每个任务根据nice值(-20~19)计算出在cpu上的执行时间(counter);

	2.如果没有可用资源, 则将该任务加入到'就绪队列'中;

	3.调度程序遍历'就绪队列'中的任务, 
		通过对每个任务动态优先级的计算(counter+20-nice)结果, 选择计算结果最大的一个去运行;
		当这个时间片用完后(counter减至0), 或主动放弃cpu时,
		该任务将被放在'就绪队列'末尾(时间片用完), 或等待队列(因等待资源而放弃cpu)中;
*/



//当所有任务都采用FIFO调度策略时(SCHED_FIFO)
/*
	1.创建进程时指定采用FIFO,并设置实时优先级rt_priority(1-99).

	2.如果没有等待资源,则将该任务加入到'就绪队列'中.

	3.调度程序遍历'就绪队列',根据实时优先级计算调度权值,选择权值最高的任务使用cpu,
		该FIFO任务将一直占有cpu, 直到有优先级更高的任务就绪(即使优先级相同也不行),
		或该FIFO任务主动放弃(等待资源, 释放使用权);

	4.调度程序发现有优先级更高的任务到达'就绪队列',
		则调度程序立即在当前任务堆栈中保存当前cpu寄存器的所有数据,
		重新从高优先级任务的堆栈中加载寄存器数据到cpu, 此时高优先级的任务开始占用cpu;

	5.如果当前任务因等待资源而主动放弃cpu使用权, 则该任务将从'就绪队列'中删除, 加入等待队列;
*/



//当所有任务都采用RR调度策略(SCHED_RR)时
/*
	1.创建任务时指定调度参数为RR,并设置任务的实时优先级和nice值(nice值将会转换为该任务的时间片的长度).

	2.如果没有等待资源,则将该任务加入到'就绪队列'中.

	3.调度程序遍历'就绪队列',根据实时优先级计算调度权值,选择权值最高的任务使用cpu.

	4.如果'就绪队列'中的RR任务时间片为0,则会根据nice值设置该任务的时间片,同时将该任务放入'就绪队列'的末尾.重复步骤3.

	5.当前任务由于等待资源而主动退出cpu,则其加入等待队列中.重复步骤3.
*/



//系统中既有分时调度,又有时间片轮转调度和先进先出调度:
/*
	1.RR调度和FIFO调度的进程属于实时进程,以分时调度的进程是非实时进程;

	2.当实时进程准备就绪后,如果当前cpu正在运行非实时进程,则实时进程立即抢占非实时进程;

	3.RR进程和FIFO进程都采用实时优先级做为调度的权值标准,RR是FIFO的一个延伸;
		FIFO时,如果两个进程的优先级一样,
		则这两个优先级一样的进程具体执行哪一个是由其在队列中的未知决定的;
		这样导致一些不公正性(优先级是一样的,为什么要让你一直运行?),
		如果将两个优先级一样的任务的调度策略都设为RR,则保证了这两个任务可以循环执行,保证了公平;
*/
