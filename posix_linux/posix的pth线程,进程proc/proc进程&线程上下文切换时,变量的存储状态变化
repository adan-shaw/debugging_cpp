//
//上下文切换
//
/*
	根据任务的不同, 上下文切换可以分为以下三种:
		进程上下文切换
		线程上下文切换
		中断上下文切换

	题外话:
		cpu 指令预取中断


		进程上下文切换:
			系统内核自动调度, 没办法控制, 
			但可以做cpu 内核绑定, 可以提高nice 值, 增大时间片, 减少被切换的可能性.
			但进程不可以永远霸占cpu 的运行的,
			终究会被cpu 定期切换出去的.

			那为什么, 有时候cpu 切换的时候, 会很卡?
			因为:
				上一个进程的上下文太多, cpu 为了保存这些变量内容, 做了大量工作, 才保存完毕, 完成切换.
				这时候, 你就会感觉切换进程会变得很卡了.


		线程上下文切换:
			线程上下文切换, 主要是cpu 在执行多线程任务的时候, 
			频繁启动, 停止线程, 导致线程切换太快, cpu空转(cpu 都忙着切换线程, 没太多时间花在计算上面)
			这种情况, 是程序设计者可以控制的, 主要控制手段有:
				减少线程的'创建&销毁'
				减少线程的'启动&挂起'
				减少线程资源访问冲突(ipc 多线程同步)


		中断上下文切换:
			每个函数调用时, 参数入栈, 函数返回时出栈, 
			每一个函数的调用, 都伴随着中断上下文切换,
			减少入栈, 出栈变量的数量,
			减少局部函数的调用(多用inline 内联函数/宏函数, 可以减少中断上下文切换)


	题外话:
		cpu 指令预取中断:
			每一个if, switch(), for(), while() 都是cpu 指令预取中断, 都会产生执行分支,
			减少这些函数的使用, 可以提高cpu 的执行效率, 让intel 的偷步运算能力更强.



	上下文切换的最低成本:
		无论你做什么操作, 上下文切换的最低成本是: 
			旧的运行环境, 被cpu 寄存器中的变量, 被压栈, 执行中断;
			新的运行环境, 被cpu 寄存器中的变量, 被入栈, 开始执行;
			新的运行环境, 运行结束/中断, 被压栈, 执行中断;
			旧的运行环境/新新的运行环境, 被cpu 寄存器中的变量, 被入栈, 开始执行;

		这样一来, 操作成本其实, 即便是尽量压缩, 也保证不了太多, 
		只能说减少'上下文切换'的消耗(损失)而已
*/





//
//多使用全局变量, static 静态变量, 来减少切换成本
//
/*
	global全局变量, static静态变量, 可以一定程度上减少上下文切换的需求;

	多线程的线程安全函数, 实际上是有性能消耗的(至少入栈, 出栈消耗, 会增加)
	不过相对于'入栈, 出栈的消耗', 其它多线程操作消耗更大: 信号量, 互斥锁等, 
	'入栈, 出栈这种消耗'几乎可以忽略不计.


	这就是为什么很多glibc 默认函数, 都是使用'静态变量'实现的, 如: time(), rand()
	因为这样做单线程, 单进程性能更好.

	并不是每一个程序, 都需要多线程的; 你需要多线程, 你就自己套用'高级的线程安全版本_r()函数'
*/

