//linux fd 概念大全:
/*
	sfd 只是fd 的一个裁剪型设备而已, 很多功能削减了, 比如说pos 索引等;
	当然, socket 具有自己的子类特性, 但也保留了很多fd 特性;

	linux 存储设备文件系统结构分析如下:
		1.索引节点inode: 用来存储数据信息, 文件唯一码, 文件大小, 属主, 读写权限, 修改日期等属性
		2.块 block:     索引节点inode 所指向的数据存储块. 索引节点inode 相当于一个指针

	(这样以来, 整个文件系统就是一棵树, 当然不是二叉树, 是多节点树, 但linux 的树阶结构很清晰, /->/root)
*/





/*
	本文件主要讲述unix 系统通用fd 的实验原理
	这里我们约定: 只关注数据存储的流程, 忽略其它操作过程的实现. 
	我们不谈API 是如何中断, 如何调用, 只谈API 调用的时候数据存储的变化过程, 因为这样对软件编程很有帮助


	引言: 
		系统内部实现需要并发异步设计的, 单一个进程是不能独占硬件资源的, 
		否则当进程崩溃又占用硬件资源的时候, 系统就杀不掉进程了
		所以呢, 系统内部有: 
			fd vnode 总表, 设备总表(设备指针和状态)等表结构, 但是都不会被进程独占, 
			进程要使用资源的时候, 都是通过任务队列投递任务的方式占用资源-时间片, 
			这样才能确保系统在进程崩溃的时候kill 掉进程
	注意: 
		系统设备总表初始化只会在系统启动的时候初始化一次, 而且会记录到临时表中, 
		这样下次查找设备的时候就不用if 判断设备是什么设备了, 
		当然设备标志就是表示设备是否正常的标志, 系统每次使用设备的时候都会判断设备是否繁忙, 使用设备


	所以有下面的过程设计: 
		--No.1
			进程表结构, 也叫PCB(进程控制块): sys\proc.h
			unix 系统的每个进程都有一个进程表结构--proc{}, 当进程调用一个API 的时候, 
			内核就访问proc{} , 并且找到proc{} 中的p_fd . 

		--No.2
			proc{}->p_fd 指向进程的filedesc{} 结构, filedesc{} 翻译作文件描述, 
			它的用途是什么不重要, 重要的是里面有两个指针: 
				*1.fd_ofileflags -- fd 状态数组,即文件描述符状态,也是下标索引,常见有: close-on-exec, mapped-from-device
				*2.fd_ofiles		 -- fd 实体数组,根据fd 的int 数值直接按数组下标索引fd 实体位置, 极速索引
			关键解析1: 
				fd 的查找方式实际是直接数组下表索引, 最快最稳定, 但是fd_ofiles 的实验原理
				可能为向量, 但是我觉得会是数组: 
					第一数组不用消耗资源, 而且默认65536 多个void*
					实际的缓冲区大小为:
						sizeof(int)*65536 = 2^16*2^4 = 1KB*2^6*2^4 --32 bit
						fd_ofileflags 同理需要1KB*2^6*2^4 --32 bit, 共64*16*2KB -- 32 bit
						**fd_ofileflags=fd_ofiles;**(这两个值一致)

		--No.3
			内核先从fd_ofileflags 数组中获取文件状态, 如果文件已经打开(当然打开时安全权限模块不在这里, 
			但是如果文件已经打开, 那么才索引下一步的fd_ofiles 获取文件实体的指针file{} )
			文件总控制结构file{} , 有两个指针, 一个类型识别: 
				f_ops	: 通用fd 操作函数, 有5种: read,write,ioctl,select,close
				f_data: caddr_t f_data的实际定义类型为char*, 是fd 数据实体, 
								当f_type值为DTYPE_VNODE, f_data指向了一个struct vnode结构体
								当f_type值为DTYPE_SOCKET, f_data指向了一个struct socket结构体
				f_type: 文件类型标识, 内核在file{} 层首先就是读f_type 判断fd 类型, 必读
			关键解析2: 
				每个f_data 无论是socket 还是file , 对fd vnode 总表而然都是唯一的vnode 元素, 
				地址不能重复, 也没有fd 值, fd 的值实际只是进程fd 文件指针数组中的下标而已, 并不代表什么, 
				而f_ops 的大小是5个函数指针的大小, 指向5个函数实体, 共享库调用-只读
				最后, fd vnode 总表可能是哈系机构哦
				<epoll 的实现也是通过监视总表v_node 结构来实现的, 这样才能用epoll 监视不同类型的fd>

		--No.4
			*4.1--查看当前系统的fd 最大容量(跟内存有关, 8G 内存=709511): 
						cat /proc/sys/fs/file-max
			*4.2--查看当前进程的fd 最大容量(默认: 65536): 
						ulimit -n

		--No.5 分区表: 
			*5.1.分区守则: 
				靠近0 扇区和最后一个扇区, 都用1G 空间间隔, 磁盘空间不足你可以用1M 来间隔这样可以防止重新分区的时候造成的各种问题
			*5.2.4个盘的原则是最好的, 因为其实分区表只有4条记录最多, 详情如下: 
				 0扇区往下数446字节是第一分区记录开始
									462字节是第二分区记录开始
									478字节是第三分区记录开始
									494字节是第四分区记录开始
									510字节是分区表结束--刚好64字节=分区表
									最后两个识别符号: 55 AA
									没一条分区表记录16字节, 55 就是一个字节, 因为是短整形1bit 也够存-128～+128了

			分区表记录例子:
								80 01 01 00	 |	 0B FE BF FC	 |	 3F 00 00 00	 |	 7E 86 BB 00
								激活 开始磁头扇区柱面 分区格式 结束磁头扇区柱面	首个扇区地址			总扇区数量
			 全部清0 就变成了未分配的磁盘, 可以自由分配, 如果你要保留一个分区, 其它分区都不改, 则保留你想保留的, 
			 其他全部清0, 但是注意: 重改的分区表容易错乱, 最好还是整个盘重新分区
*/
