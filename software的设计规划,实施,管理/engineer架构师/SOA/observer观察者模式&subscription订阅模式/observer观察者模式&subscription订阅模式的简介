//observer观察者模式 & subscription订阅模式:
/*
1.这两个设计模式, 是比较主从明显的设计模式, 主要区别:
	observer观察者:
		适合一对一, 一对多的情况;
		无订阅过程, 强制推送, 接收者必须接收, 不能拒绝;

	subscription订阅模式:
		适合一对一, 一对多, 多对多的情况;
		有订阅过程, 自选推送, 接收者可以接收数据, 可以拒绝数据;

	总结:
		'observer观察者模式', 由于被观察的对象只有一个, 所以不适合多对多的情况, 
		但相对'subscription订阅模式', 'observer观察者模式'比较简单, 
		因为'observer观察者模式'并没有订阅机制, 不用检查访问者是否已经订阅了内容;


	目前的SOA 面向服务设计模式(非OOP 面向对象设计), 大部分都采用'subscription订阅模式',
	订阅了某个service, 就能接收到推送内容, 在MQ 消息队列框架中经常用;

	而且由于MQ 消息队列框架, 无论是互联网APP 还是汽车行业的autosar 中间件, 都会用到MQ,
	因此, SOA 面向服务设计模式, 'subscription订阅模式', 现在比较火红;
	只要是MQ, 无论是异步MQ, 还是实时MQ, 都是'subscription订阅模式'模式的(比较偏向面向服务设计模式);



2.应用场景:
	observer观察者模式:
		一对多的强制推送关系, 应用场景还挺多的, 比如:
			主服务器与从服务器的更新同步-> 主服务器更新, 从服务器直接强制跟着更新, 这种场景简单, 一般使用观察模式;

	subscription订阅模式:
		多对多的自选推送关系, 应用场景还挺多的, 比如:
			客户端有多个, 服务器也有多个, 客户端选择自己需要的service 进行订阅, 接受选定的服务器数据, 这种场景简单, 一般使用订阅模式;



3.observer观察者模式 & subscription订阅模式, 是OOP 还是SOA?:
	observer观察者模式 & subscription订阅模式, 一般是属于SOA, 并不是OOP,
	OOP 面向对象, 一般的最小粒度, 是类, 类封装;
	SOA 面向服务, 一般的最小粒度, 是service, 是app 应用群;
	因此, observer观察者模式 & subscription订阅模式, 常见在SOA 设计中;



4.其他问题:
	* 推送丢失 & 接收签名问题
	* cache data缓存 & 高速响应设计
	* 推送格式问题(文本=json/xml, 数值=定制数据格式)
	...
	以上具体的问题, 交给MQ 框架解决, 这里不做过多叙述, 有兴趣可以查看具体每款MQ 的详细实现, 本节只谈设计模式;
*/
