unix 的稳定和成功, 很大程度的上归功于: 
	各个开发者在开始时作出的设计抉择. 
	这些决策, 连同设计哲学, 编程艺术, 技术文化一起, 成就了unix 的成功. 

	即使是unix 的世界里面, unix 的通用性也一直受到怀疑.  这可以算是unix 系统的一种通病. 
	软件断层, 系统架构各异, 但至少也有posix and SUSv4 标准支撑unix 跨平台编程. 

	纯种unix 文件在字节层次以上再无结构可言, 文件删除了就没法恢复. 
	unix 的安全模型公认地太过原始, 做也控制有欠精致的地方. 命名方式混乱.  
	或许拥有文件系统本身就是一个错误. 



unix 设计准则:
1. 模块原则: 使用简洁的接口拼合<简单的组件>
2. 清晰原则: 清晰胜于机巧
3. 组合原则: 设计时考虑拼接组合
4. 分离原则: 策略和机制分离, 接口和引擎分离
5. 简洁原则: 设计要简洁, 复杂度能低则低
6. 吝啬原则: 除非确无它法, 不要编写庞大的程序. 
7. 透明性原则: 设计要可见, 以便审查和调试
8. 健壮原则: 健壮源于透明和简洁
9. 表示原则: 把知识叠入数据以求逻辑质朴而健壮
10.通俗原则: 接口设计避免标新立异
11.沉默原则: 如果一个程序没什么好说的, 就沉默
12.补救原则: 出现异常时, 马上退出并给出足够多的错误信息
13.经济原则: 宁花机械一分钟, 不花程序员一秒
14.生成原则: 避免手工hack, 尽量编写程序去生成程序
15.优化原则: 雕琢前先要有原型
16.多样原则: 尽量不要给程序封口, 要留有拓展接口以便快速拓展
17.拓展原则: 尽量不要给程序封口, 要留有拓展接口以便快速拓展



//*************************************************************************

程序优化:
1.程序员最强的优化技术就是不做优化. (但是这必须是面对稳定的现成系统来说, 新搭建的系统不考虑)
也就是工作中的系统就别优化!!

有几个理由支持这项禅式忠告, 其中一个是摩尔定律的指数效应:
最聪明, 最便宜, 常常也是最迅速的性能提升方法, 就是等上几个月, 期望硬件性能更好. 
考虑到硬件和程序员时间成本比率, 总有更值得打发时间的事, 别去优化一个已经营运中的系统. 


2.先估量, 后优化. 
如果有证据证明应用程序的确存在大量逻辑缺陷导致程序运行缓慢, 仅当遇到这种情况的情况下, 你才能去优化程序. 
但是在付诸实施前, 你必须先估量一下优化涉及的各个方面, 和具体的实施手段. 
这也是类似给一间旧房屋做装修一样麻烦. 


3.不要<倒腾/纠结>风格的问题, 换一种风格也还是一副德性, 浪费时间做无用功. 
你需要融入一个团队的第一件事不是将代码改成自己的模式, 而且学！！

//*************************************************************************



程序的复杂度: 
	尽可能简单, 但别简单过头. 
everything should be made as simple as possible but no simpler !!

keep it simple, stupid !!



